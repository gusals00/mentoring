# 유지보수성

코드는 쓰이는 횟수보다 읽히는 횟수가 훨씬 많다.

보통은 코드를 읽은 후 코드를 작성하는 단계로 넘어간다. 그리고 현실에서의 작성의 대부분은 기존 코드를 수정하거나 확장하는 걸 뜻한다. 이를 유지보수라고 하기도 하고 개발이라 부르기도 한다. 어느 쪽이건 코드 어딘가를 고쳐야 한다는 사실은 변함이 없다.

<br>

테스트 코드를 유지보수하기 어렵게 만드는 테스트 냄새들을 알아보자.

## 중복

중복은 하나의 개념이 여러 차례에 걸쳐 표현되거나 복제된 것이다. 즉 필요 없는 반복을 말한다.

중복이 나쁜 이유는 개념과 논리를 곳곳에 흩어놓아 코드를 이해하기 어렵고 불투명하게 만든다. 코드를 수정하려면 중복된 곳을 모두 찾아 일일이 손봐줘야 하게 된다.

<br>

중복의 유형은 다음과 같다.

- 상수 중복
    - 특정 문자열이나 숫자가 테스트 코드에서 반복되는 것을 말한다.
    - 지역 변수로 만들어서 제거할 수 있다.
- 구조 중복
    - 데이터만 다를 뿐 처리 로직이 똑같은 상황을 말한다.
    - 별도의 메소드로 분리해서 해결할 수 있다.
- 의미중복
    - 같은 기능이나 개념을 다른 방식으로 구현한 상황을 말한다. 구조 중복을 포함하고 있지만 눈에 띄지 않기 때문에 알아채기 어렵다.
    - 구조 중복으로 바꾸고, 구조 중복을 제거하는 방식으로 해결할 수 있다.

<br>

중복 제거도 과유불급이 될 수 있다. 최우선 목표는 코드를 읽기 쉽게 유지하여 읽는 이에게 그 의도와 기능을 명확히 전달하는 것이다.

이 사실을 잊지 않는다면 가독성을 위해 일부러 중복을 남겨둬야 할 상황도 있다는 것을 이해할 수 있다.

## 조건부 로직

조건부 로직을 포함한 테스트는 제 역할을 못할 가능성이 높다.

<br>

우리는 코드가 해야 할 일과 동작을 파악할 때도 테스트를 활용한다. 우리가 실수하면 테스트가 바로 알려줄 거라 믿고, 안심하고 코드를 고치기도 한다.

조건부 로직은 이 두 가지 모두를 더 어렵게 하고 오류 발생 가능성을 높인다.

<br>

코드에 조건부 로직이 들어 있으면 코드가 훨씬 어려워 진다.

결론적으로, 테스트 메소드는 if, else, for, while, switch 같은 조건부 실행 구조를 가져서는 안 된다. 이는 테스트 대상이 복잡할수록 더 중요하다.

## 양치기 테스트

간혈적으로 실패하는 양치기 테스트는 외부의 요소에 의존하는 테스트에서 일어나기 쉽다. 

시간에 의존하는 테스트는 테스트를 실행할 때마다 결과가 달라질 수 있다. 처음 테스트를 작성했을 때는 테스트가 실패하다가 빌드할 때 운 좋게 성공해서 문제가 없는 코드라고 오해할 수도 있다.

<br>

벗어나는 방법은 다음과 같다.

1. 회피한다.
    1. 비결정적인 모든 원흉을 깔끔히 잘라내면 된다. 예를 들어 타임스탬프 대신 파일명 뒤에 숫자를 붙여서 정렬할 수도 있다.
2. 제어한다.
    1. 그게 여의치 않다면 제어를 시도해볼 수 있다. 값을 원하는 순서로 반환하는 가짜 객체로 난수 발생기를 교체하는 방법이 떠오른다.
3. 격리한다.
    1. 문제의 원흉을 회피하거나 제어할 방법을 찾지 못했다면, 골칫거리를 코드베이스에서 가능한 좁은 구석으로 격리하는 걸 시도해보자. 이렇게 하면 코드의 대부분을 비결정적 행동으로부터 해방하고, 단 한 곳에서만 그 골칫거리와 씨름하면 된다.

## 파손된 파일 경로

파손된 파일 경로는 코드를 움직이지 못하게 꽁꽁 동여매어 개발자 컴퓨터 외에는 어디에서도 돌아가지 못하게 한다.

<br>

테스트 코드에서 파일을 다룰 때 절대 경로는 무조건 피해야 한다. 용인될 수 있는 상황도 있을지 모르겠지만, 모두 없애버리는 게 기본 원칙이다.

가능하다면 반드시 상대 경로를 쓰고, 정 안되면 시스템 속성이나 환경 변수로 한 단계 더 추상화하여 접근하자.

<br>

File 대신 InputStream, OutputStream을 사용하면 이들이 인터페이스이기 때문에 원하면 언제든 테스트 더블로 교체할 수 있다는 장점이 있다.

<br>

기본적으로 프로젝트에 필요한 모든 자원은 프로젝트 루트 디렉터리의 하위에 두는 걸 원칙으로 하자. 이렇게 하면 코드와 빌드 스크립트 어디에서건 상대 경로를 사용할 수 있는 기반이 갖춰진다.

또한, 테스트 코드에서만 사용하는 데이터 파일은 테스트 코드와 같은 위치에 두고 클래스패스로 접근하면 편하다.

## 끈질긴 임시 파일

끈질긴 임시 파일이란 임시 파일이 임시적이지 않고 다음번 테스트 수행 시 까지도 지워지지 않고 버티고 있는 상황을 말한다.

<br>

가정은 일을 그르치는 지름길이다. 하지만 임시 파일이 정말 임시적이라 가정하곤 한다. 덕분에 디버깅하고 싶지 않은 깜짝 놀랄 상황이 발생하곤 한다.

사실, 테스트 목적상 꼭 필요한 경우만 아니라면 파일을 절대 사용하지 않는 것이 가장 좋다.

<br>

파일 사용은 무조건 최소한으로 자제해야 한다.

파일 I/O 를 사용하면 문자열 등의 인메모리 데이터를 다룰 때보다 테스트가 현저히 느려진다.

<br>

임시 파일에 대처하는 간단한 지침은 다음과 같다.

- @Before 메소드에서 파일을 삭제하라.
- 가능하면 임시 파일명도 고유하게 지어라.
- 파일이 있어야 하는지를 명시하라.

## 잠자는 달팽이

테스트를 느리게 하는 요소 중에 하나는 테스트 코드를 실행하는 동안 메인 쓰레드를 blocking 하는 코드들이다.

비동기 로직들이 실행된 후의 시점을 알 수 없어서 예측하는 시간 동안 메인 쓰레드를 blocking 하는 방법을 사용하는 것인데, 이런 테스트는 신뢰할 수도 없고, 테스트를 느리게 한다. 

<br>

테스트 쓰레드는 작업 쓰레드가 일을 마치는 즉시 알 수 있어야 한다. 이를 이용하면 버려지는 시간을 되찾을 수 있다.

## 픽셀 퍼펙션

픽셀 퍼펙션은 기본 타입 단언과 매직 넘버의 특수한 형태다. 컴퓨터 그래픽스 분야에서 상당히 빈번하게 발견되는 냄새이다.

<br>

두 박스 사이의 연결 여부를 테스트하는 테스트 코드를 작성해야 한다고 할 때, 선이 그려져 있는지의 여부를 픽셀 단위로 검사하는 코드가 있다면 입력이 조금만 바뀌어도 테스트가 실패하게 된다.

<br>

의미상으로는 훨씬 상위 개념을 검사하면서도 실제로는 점의 좌표와 색상처럼 훨씬 낮은 수준의 개념을 검사하게 된다.

두 박스 사이의 연결 여부를 테스트한다면 점이나 좌표를 직접 단언할 필요는 없다. 대신 사용자가 정의한 메소드로 추상화해서 복잡한 것을 숨겨야 한다.

## 메소드 간 응집력 결핍

응집력은 잘 작성된 객체지향 코드의 핵심 특성이다. 응집력이란 클래스 하나는 사물 하나, 즉 하나의 추상화 개념을 표현한다는 뜻이다. 그래서 우리는 강한 응집력을 원한다.

<br>

메서드 간이라 함은 같은 클래스에 속한 메서드 간의 공통점이 많으냐를 기준으로 응집력의 강약을 정한다는 의미다.

단위 테스트 관점에서 해석하면, 한 클래스의 모든 테스트가 같은 픽스처를 이용해야 한다고 표현할 수 있다. 반대로 말하면 다른 픽스처를 이용하는 테스트 메서드는 독립된 테스트 클래스로 나눠야 한다.

<br>

메서드 간 응집력 결핍이란 테스트 클래스 하나에 속한 테스트 메서드들이 서로 다른 픽스처 객체를 사용한다는 뜻이다.

코드가 복잡해진 탓에 각 필드의 역할이 무엇인지, 어느 테스트가 어느 픽스처 객체를 사용하는지, 셋업에서는 어느 객체를 어떻게 설정해야 하는지 알기 어렵다.

<br>

복잡 다양한 픽스처 조합이 필연적이라 판단되면, 이 응집력 결핍 현상을 없앨 방법은 두 가지가 남는다.

1. 새로운 테스트 클래스를 만들어서 테스트 메서드 일부를 옮기고, 필요하다면 공통 로직을 담아둘 기반 클래스를 추출한다.
2. 별도의 클래스가 제공하는 유틸리티 메서드를 이용해서 테스트 메서드 각자가 필요한 픽스처를 직접 생성한다.

## 요약

유지보수를 어렵게 하는 테스트 냄새를 살펴보았다.

<br>

테스트 코드에서도 중복 하나하나가 유지보수를 훨씬 어렵게 만든다는 사실을 배웠다.

테스트 코드에 조건부 로직이 있으면 테스트가 실제 수행한 일이 무엇인지 알 수 없게 되는 것을 알았다.

간혈적으로 실패하는 양치기 테스트와 다른 컴퓨터에서는 실패하게 만드는 파일 경로 문제를 설명했다.

끈질긴 임시 파일은 사라지지 않고 주변을 배회하다가 이들이 지워졌으리라 가정하고 있는 다음 테스트에 큰 혼란을 안겨준다.

잠자는 달팽이라는 냄새는 Thread#sleep을 호출하는 멀티스레드 코드에서 자주 나타난다. 훨씬 빨랐어야 할 테스트가 다른 일을 기다리며 가만히 멈춰있게 한다.

픽셀 퍼펙션은 그래픽스 분야에서 사용하는 과도하게 정밀한 단언문이다. 컴퓨터 그래픽스는 매직 넘버와 기본 타입 단언을 조합해서 광역 단언을 만들어 냈다.

파라미터화된 혼란을 분석해본 결과 JUnit의 Parameterized 테스트 러너는 조심히 다뤄야 한다는 교훈을 얻었다.

마지막으로, 테스트에서 응집력이 의미하는게 무엇인지, 그리고 그것이 부족해서 곤란해진 상황에 대처하는 방법을 살펴봤다.
