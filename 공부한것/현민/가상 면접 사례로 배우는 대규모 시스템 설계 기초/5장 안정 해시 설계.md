# 안정 해시 설계

수평적 규모 확장성을 달성하기 위해서는 요청 또는 데이터를 서버에 균등하게 나누는 것이 중요하다.

안정 해시는 이 목표를 위해 보편적으로 사용하는 기술이다.

<br>

## 해시 키 재배치(rehash) 문제

N개의 캐시 서버가 있다고 하자. 이 서버들에 부하를 균등하게 나누는 보편적인 방법은 아래 해시 함수를 사용하는 것이다.

`serverIndex = hash(key) % N`

<br>

이 방법은 서버 풀의 크기가 고정되어 있고, 데이터 분포가 균등할 때는 잘 동작한다.

하지만 서버가 추가되거나 삭제되는 경우 문제가 생긴다.

1번 서버가 죽으면 1번 서버에 보관되어 있는 키 뿐만 아니라 대부분의 키가 재분배되고, 대부분의 캐시 클라이언트가 데이터가 없는 서버에 접속하게 된다. 그 결과로 대규모 캐시 미스가 발생하게 될 것이다.

안정 해시는 이 문제를 효과적으로 해결해준다.

## 안정 해시

안정 해시(consistent hash)는 해시 테이블 크기가 조정될 때 평균적으로 오직 k/n개의 키만 재배치하는 해시 기술이다.

해시함수 f로는 SHA-1을 사용한다고 가정해보자.

![image](https://github.com/gusals00/mentoring/assets/87007552/3d697c0c-d049-40af-a15c-71442607f5bc)


해시 공간의 시작과 끝을 이어서 해시 링을 만들고, 해시 공간 위에 서버를 배치한다.

캐시할 키 또한 해시 링 위의 어느 지점에 배치할 수 있다.

<br>

어떤 키가 저장되는 서버는, 해당 키의 위치로부터 시계 방향으로 링을 탐색해 나가면서 만나는 첫 번째 서버이다.

k0은 서버0에 저장되고, k1은 서버1에 저장되는 형식이다.

<br>

이렇게 하면, 아래처럼 서버를 추가/삭제 하더라도 키 가운데 일부만 재배치하면 된다.

![image](https://github.com/gusals00/mentoring/assets/87007552/acd965d0-0ff0-46b7-8bd6-101589188671)


새로운 서버4가 추가되어도 k0만 재배치됨을 볼 수 있다.

<br>

**기본 구현법의 두 가지 문제**

서버가 추가되거나 삭제되는 상황을 감안하면 파티션(인접한 서버 사이의 해시 공간)의 크기를 균등하게 유지하는 게 불가능하다.

어떤 서버는 작은 해시 공간을, 어떤 서버는 큰 해시 공간을 할당 받는 상황이 가능해지게 된다.

키의 균등 분포를 달성하기가 어렵다.

![image](https://github.com/gusals00/mentoring/assets/87007552/1d4880e6-ced5-4a88-b182-1712bcdb1bcb)


위처럼 서버가 배치 되어 있다고 하면, 서버1과 서버3은 아무 데이터도 갖지 않지만, 대부분의 키는 서버2에 보관될 것이다.

<br>

이 문제를 해결하기 위해 제안된 기법이 가상 노드(virtual node) 또는 복제(replica)라 불리는 기법이다.

<br>

**가상 노드**

가상 노드는 실제 노드 또는 서버를 가리키는 노드로서, 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다.

![image](https://github.com/gusals00/mentoring/assets/87007552/50cec6e4-25f3-49ca-a699-de98470d75c5)


위 그림을 보면 서버0과 서버1은 3개의 가상 노드를 갖는다. 서버0을 링에 배치하기 위해 세 개의 가상 노드를 사용하고 있다.

따라서 그림처럼 각 서버는 하나가 아닌 여러 파티션을 관리해야 한다.

<br>

마찬가지로 키위 위치로부터 시계방향으로 링을 탐색하다 만나는 최초 가상 노드가 해당 키가 저장될 서버가 된다.

가상 노드의 개수를 늘리면 키의 분포는 점점 더 균등해진다. 표준편차가 작아져서 데이터가 고르게 분포되기 때문이다.

가상 노드의 개수를 늘리면 표준 편차의 값은 떨어지지만, 가상 노드 데이터를 저장할 공간을 더 많이 필요하게 될 것이다. 시스템 요구사항에 맞도록 적절히 조절해야 할 것이다.

## **마치며**

안정 해시의 이점은 다음과 같았다.

- 서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다.
- 데이터가 보다 균등하게 분포하게 되므로 수평적 규모 확장성을 달성하기 쉽다.
- 핫스팟 키 문제를 줄인다. 특정한 샤드에 대한 접근이 지나치게 빈번하면 서버 과부하 문제가 생길 수 있다.