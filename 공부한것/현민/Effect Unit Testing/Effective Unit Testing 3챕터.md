# 3. 테스트 더블

스텁과 터마가 등장한 가장 큰 이유는 제품 코드가 온전히 준비되기 전까지 사용할 대용품이 필요했기 때문이다. 대용품이 있다면 주변 모듈을 다 갖추지 못했더라도 코드 일부분을 따로 컴파일하고 실행해볼 수 있었다.

<br>

오늘날의 개발자 테스트에서는 이들 객체의 쓰임새가 훨씬 다양해졌다. 종속 모듈 없이 컴파일하고 실행하려는 애초의 용도는 그 비중이 많이 줄어들었다.

대신 테스트 추종 프로그래머에 의해 다양한 테스트 전용 장치가 만들어지면서 요즘은 테스트 대상 코드를 격리하고, 속도를 개선하고, 예측 불가능한 요소를 제어하고, 특수한 상황을 시뮬레이션하고, 감줘진 정보를 얻어내는 등의 용도로까지 쓰이고 있다.

<br>

이처럼 목적에 따라 비슷한 듯 하면서도 다른 객체를 사용하는데 그 전부를 통틀어 **테스트 더블**이라고 한다.

## 테스트 더블의 위력

코드는 덩어리다. 서로 참조하는 코드들이 그물처럼 얽혀있다. 각각의 조각은 약속된 동작을 수행한다.

어떤 동작은 원자적이라 클래스나 메소드 안에서 모두 처리되는 반면 어떤 동작은 다른 코드 조각과의 교류를 통해 완성된다.

<br>

종종 어떤 코드 조각이 원하는 동작을 올바로 수행하는지 검증하려 할 때, 주변 코드를 모두 교체하여 테스트 환경 전반을 통제할 수 있다면 가장 좋다. 이렇게 테스트 대상 코드와 협력 객체를 잘 분리하면 좋다. 

테스트하려는 코드를 주변에서 분리하는 것이 테스트 더블을 활용하는 가장 기본적인 이유다.

### 테스트 대상 코드를 격리한다

테스트 대상 코드를 격리한다는 것은 세상의 모든 것을 두 가지로 분류한다는 뜻이다.

1. 테스트 대상 코드
2. 테스트 대상 코드와 상호작용하는 코드

<br>

테스트 대상 코드를 격리하겠다는 것은 테스트하려는 코드를 그 외의 모든 코드에서 떼어 놓겠다는 의미다. 그 결과로 테스트는 초점이 분명해지고, 이해하기도 쉬워지고, 설정하기도 간편해진다.

그 외의 모든 코드에는 테스트 대상 코드가 호출하는 코드도 포함된다.

### 테스트 속도를 개선한다

테스트 대상에 집중하기 위해 테스트를 실행하는데 오래 걸리는 종속 객체는 연산 없이 결과만 반환하는 테스트 더블로 대체할 수 있다.

이렇게 하면 테스트 코드의 피드백 과정을 빨라지게 할 수 있다.

### 예측 불가능한 실행 요소를 제거한다

테스트란 동작을 정의하고 명세와 일치하는지 확인하는 작업이다. 대상 코드가 완벽히 결정적이라서 불확정 요소가 없다면 간단하고 명확한 일일 것이다. 코드와 테스트 코드가 결정적이 되려면 몇 번을 테스트하건 항상 같은 결과가 나오도록 해야한다.

<br>

비결정적 요소의 가장 전형적인 예는 시간과 관련된 동작이라고 볼 수 있다. 예측할 수 없는 요인을 다뤄야할 때도 역시나 테스트 더블이 해결책이 될 수 있다.

항상 똑같은 시간을 알려주는 테스트 더블로 시스템 시계를 갈아 끼워주면 훨씬 쉽게 예측할 수 있다.

<br>

협력 객체를 통해 변수를 제거해서 테스트하려는 조건과 시나리오를 명확히 하는 근본 이유는 결과에 영향을 주는 모든 요소를 결정적으로 만들기 위해서이다.

### 특수한 상황을 시뮬레이션한다

네트워크 연결이 갑자기 끊겼을 때 테스트 대상이 어떻게 대처하는지는 어떻게 확인할 수 있을까?

실행 도중에 테스트가 컴퓨터 네트워크 인터페이스를 비활성화시킬 수만 있으면 되는데, 이런 식의 네트워크 오류를 만들어내려면 테스트 더블 외에는 달리 방법이 없다. 연결 요청을 처리하는 부분을 테스트 더블로 대체해서 예외를 발생시키면 된다.

### 감춰진 정보를 얻어낸다

private 필드를 테스트해야 한다면 private 필드에 접근하는 public 메소드를 구현 코드에 추가하는 방법도 있지만 테스트 목적 외에는 쓸일 없는 메소드를 제품 코드에 추가하는 것은 좋지 않다.

이 경우 테스트 더블을 이용하면 테스트 전용 메소드는 테스트 코드에만 추가하면 된다.

## 테스트 더블의 종류

테스트 더블의 종류는 테스트 스텁, 가짜 객체, 테스트 스파이, Mock 객체가 있다.

### 테스트 스텁

테스트 스텁의 목적은 원래의 구현을 최대한 단순한 것으로 대체하는 것이다. 

가장 간단한 예로는 항상 일정한 값을 반환하도록 만들어진 메소드가 있다.

### 가짜 객체

테스트 스텁에 비하면 가짜 객체는 정성이 꽤 들어간 테스트 더블이다. 반환값을 하드코딩하는 테스트 스텁의 특성상 각자의 시나리오에 맞는 스텁을 따로 구현해야 한다.

그에 반해 가짜 객체는 진짜 객체의 행동을 흉내 내지만, 진짜 객체를 사용할 때 생기는 부수 효과나 연쇄 동작이 일어나지 않도록 경량화하고 최적화한 것이라고 볼 수 있다.

<br>

가짜 객체는 영속성과 관련된 코드를 테스트할 때 유용하다. 

테스트가 실제 데이터베이스에 접근한다면 테스트 실행 속도를 느리게 만들 것이다. 실제 데이터베이스가 아니라 인메모리 데이터베이스를 가짜 객체로 만들어 쓰면 훨씬 빠른 속도를 보장할 수 있다.

### 테스트 스파이

테스트 스파이는 테스트 대상에 잠입해 프로그래머가 궁금한 내용을 알려주는 역할을 한다.

입력 인자로 사용되는 객체가 테스트에 필요한 정보를 알려주는 API를 제공하지 않는다면, 그 객체를 테스트 스파이로 대체할 수 있다.

<br>

테스트 스파이는 목격한 일을 기록해두었다가 나중에 테스트가 확인할 수 있게끔 만들어진 테스트 더블이다.

### Mock 객체

Mock 객체는 특수한 형태의 테스트 스파이다.

특정 조건이 발생하면 약속된 행동을 하도록 할 수 있고, 예기지 않은 일이 발생했을 때 실패하도록 하는 정교한 테스트를 작성할 수도 있다.

<br>

Mock 객체 라이브러리에는 JMock, Mockito, EasyMock 등이 있다.

## 테스트 더블 활용 지침

### 용도에 맞는 더블을 선택하라

가장 명확한 원칙은 테스트를 가장 읽기 쉽게 만들어주는 선택을 하라는 것이다.

스텁은 질문하고 Mock은 행동하는 특성을 생각하자.

<br>

두 객체간 상호작용의 결과로 특정 메소드가 호출되었는지 확인하고 싶다면 Mock 객체를 써야 할 가능성이 높다.

협력 객체는 원하는 값만 내려주면 되고 협력 객체가 테스트 대상 객체에 넘겨줄 응답도 테스트에서 통제할 수 있다면 테스트 스텁을 사용하는게 좋다.

필요한 서비스나 컴포넌트를 미처 준비하지 못해 스텁을 대용품으로 사용하고 있는데, 시나리오가 너무 복잡해졌거나 테스트 코드가 관리하기 어려울 만큼 복잡해졌다면 가짜 객체를 구현하는 것을 고려해보자.

### 준비하고, 시작하고, 단언하라

단위 테스트의 구조에 관해 대다수 프로그래머가 동의하는 확고한 규약이 있다. 필요한 객체들을 준비하고, 실행하고, 결과를 단언하는 세 단계로 테스트를 구성한다는 준비-시작-단언이라는 규약이다.

<br>

행위 주도 개발 진영에서도 준비-시작-단언과 유사한 용어와 구조가 사용된다. (Given) 주어진 상황에서, (When) 어떤 일이 발생했을 때, (Then) 특정 결과를 기대한다.

우리가 기대하는 행위를 더 직관적인 언어로 표현하기 위해 고뇌한 결과물이다. given-when-then이 흐름을 보면 더 부드럽고 행위라는 관점에서 사고를 더 자연스럽게 표현할 수 있다.

<br>

세 영역 중 하나가 비대하다고 느껴진다면, 너무 많은 것을 한꺼번에 검사하려는 테스트일 가능성이 높다. 더 작은 단위의 기능을 집중적으로 검사하는 테스트로 나눌 필요가 있다는 신호다.

### 구현이 아니라 동작을 확인하라

Mock 객체에 예상을 너무 상세하게 설정하는 프로그래머를 종종 볼 수 잇는데, 이는 흔히 저지르는 실수 중 하나다.

테스트와 관련된 모든 것을 Mock 객체로 만들고, 객체 간의 사소한 메소드 호출 하나까지 깐깐하게 정의하는 걸 말한다.

<br>

검증 목적과 관련 없는 지극히 사소한 변경마저도 테스트를 실패하게 하면 안된다.

테스트는 오직 한 가지만 검사해야 하고 그 의도를 명확히 전달하도록 작성되어야 한다.

### 자신의 도구를 선택하라

어떤 도구를 선택해도 되지만, 중요한 것은 테스트 코드는 지금이나 앞으로나 읽기 쉽고 간결하고 관리하기 쉬워야 한다는 것이다.

<br>

JMock의 테스트 더블은 대상 코드가 그 어떤 것도 자기 마음대로 호출하면 안된다고 믿는다. 이 가정을 완화하려면 스텁을 사용해야 한다.

Mockito의 테스트 더블은 대상 코드가 언제건 아무것이나 호출해도 된다고 믿는다. 이 가정을 더 강화하려면 우리가 직접 메소드 호출 여부를 확인해야 한다.

### 종속 객체를 주입하라

진짜 객체를 다른 것과 교체할 방법이 없다면 테스트 더블도 무용지물이다.

종속 객체를 다른 객체로 교체해야만 쉽게 검사할 수 있다면 그 객체를 사용하는 곳과 생성하는 곳을 달리 하는 것이 좋다. 즉, 종속 객체를 private 필드에 저장하거나 팩토리 메소드 등을 통해 외부로부터 얻도록 해야 한다.

<br>

종속 객체 주입법을 통해 종속 객체를 외부에서 안으로 집어넣는 방식이 훨씬 좋다. 보통은 생성자 주입 방식을 많이 애용한다.

## 요약

테스트 대상 코드를 격리해야지만 모든 시나리오를 시뮬레이션하고 모든 동작을 검증할 수 있다.

종종 시간을 단축할 목적으로도 테스트 더블을 이용한다.

테스트 더블을 활용하면 예측 불가능한 요소를 예측할 수 있게 바꿀 수 있어 테스트 인생을 훨씬 안락하게 만들어준다.

테스트 더블을 통해서만 시뮬레이션 할 수 있는 특수한 상황이 있을 수도 있고, 테스트 전용 코드를 넣기 위해 제품 설계를 바꾸는 꺼림직한 일도 테스트 더블로 막을 수 있다.

<br>

테스트 더블은 테스트 스텁, 가짜 객체, 테스트 스파이, Mock 객체라는 네 가지 형태가 있었다.

극한까지 단순화된 테스트 스텁은 불필요한 협력 객체를 쳐내는 데 가장 효과적이다.

가짜 객체는 진짜 객체가 사용하기 어렵거나 귀찮을 때 쓸 수 있는 번개처럼 빠른 대용품이다.

테스트 스파이는 본래는 접근할 수 없었던 내부 정보가 궁금할 때 사용하면 좋다.

Mock 객체는 동작을 동적으로 재설정하거나 기대한 상호작용이 정말로 일어났는지 확인할 수 있도록 특화된 테스트 스파이다.

<br>

테스트 더블 활용 지침으로는 첫 번째로 당면한 상황과 조건에 적합한 테스트 더블을 선택하는 요령을 이야기했다.

특히 Mock 객체를 사용할 때는 핵심과 거리가 먼 자잘한 구현은 확인하지 않는 것이 중요하다. 의도한 동작이 제대로 일어났는지 검사했다면 Mock 객체가 해야 할 일은 충분히 한 것이다. 동작이 완료 되기까지의 세부 과정은 본질과는 거리가 있으니 최대한 너그럽게 눈감아주자.

<br>

종속 객체를 대상 코드 안에서 직접 생성하는 것보다, 외부에서 주입할 수 있도록 통로를 열어 두는 것이 검사를 훨씬 쉽게 하는 지름길이다.
