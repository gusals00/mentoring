# 테스트 속도 개선

좋은 단위 테스트는 수행 시간도 짧다. 하지만 테스트 스위트의 덩치가 커질수록 피드백 주기가 길어지는 건 피할 수 없다.

<br>

테스트 시간과 빌드 시간이 짧아야 하는 이유와 느린 빌드를 극복하기 위한 전략을 하나씩 살펴보자.

크게 두 가지 측면에서의 전략을 집중적으로 살펴볼 것이다.

- 테스트 속도 개선
    - 테스트를 빠르게 해줄 실마리를 찾기 위해 코드를 파헤치는 작업이다.
- 빌드 속도 개선
    - 관심 대상을 이전까지의 테스트 코드의 상세 내용에서 빌드 스크립트가 테스트를 실행하는 방식으로 바꿔본다.
    - 구체적으로는 고성능 컴퓨터나 다수 컴퓨터를 이용한 병렬 실행을 통해 빌드 시간 단축을 노려볼 것이다.

## 속도 개선을 위해서

옛날부터 프로그래머는 코드를 가능한 한 빠르게 만들기 위해 힘써왔다. 과거에는 이유가 확실했다. 당시의 하드웨어는 코드에 바라는 요구사항과 제약이 엄격했다. 즉, 가용 메모리나 레지스터의 수, CPU가 명령어를 실행하는 데 걸리는 사이클 등을 일일이 고려해야 했다.

요즘은 이런 제약이 많이 약해진 것이 사실이지만, 여전히 컴퓨터가 일을 끝내길 기다려야 할 때가 많다.

### 더 빠르게!

테스트가 빨리 끝나야 하는 이유는 피드백이 늦어질수록 피해가 더 커지기 때문이다. 

좁게 보면 개발자는 작업을 마무리하지 못하고 검증 결과를 기다리게 된다.

그리고 넓게 보면 빌드가 너무 늦어져서 개발자는 일부 테스트만 수행한 후 나머지는 빌드 서버에 맡긴 채 다음 작업을 시작하게 된다. 빌드 서버가 뒤늦게 문제를 발견하면 개발자는 하던 일을 멈추고 이전 작업을 다시 검토해야 한다. 결과적으로 집중력을 잃고 생산성도 떨어진다.

<br>

그래서 우리는 빠른 피드백을 바라지만, 아직 **어떻게**라는문제가 남아있다. 테스트와 빌드 속도를 개선하여 피드백 주기를 단축해줄 묘책에는 어떤 것이 있을까?

### 상황 속으로

느린 테스트와 느린 빌드에 대한 접근 방식은 기본적으로 같다.

무엇이 문제라고 미리부터 가정하지 말고 테스트가 어떻게 실행되는지 분석하여 정확한 상황 데이터부터 구하자. 이렇게 주요한 병목지점을 찾은 다음 알고 있는 수단을 총동원해서 해결하면 된다.

### 빌드 프로파일링하기

빌드를 느리게 하는 가장 큰 원인은 거의 언제나 테스트다. (외부 프로세스를 너무 많이 실행하거나 파일시스템에 자주 접근해서 생기는 오버헤드도 흔한 원인이다.)

그래도 확실한 것이 최고니, 빌드 전체의 성능을 간단히 프로파일링해서 어느 작업이 가장 긴 시간을 잡아먹는지 확인하자.

<br>

테스트를 최적화해서 어떠한 형태의 개선을 이끌어낼 수 있는지, 그리고 그것이 전체 그림에 어떠한 영향을 주는지 이해하는 것이 중요하다. 대부분의 경우 가장 긴 시간을 허비하는 건 역시 테스트지만, 가끔은 다른 것이 CPU를 차지하고 있을 때도 있으니 직접 확인해주는 게 좋다.

### 테스트 프로파일링하기

최적화 대상을 테스트로 정했다면 현재 병목구간이 어디인지부터 찾아야 한다.

자바 프로파일러를 사용할 수 있다. 프로파일러가 생성한 개요나 보고서가 큰 도움이 되겠지만, 그것만으로는 병목구간을 찾지 못하겠다면 그야말로 본격적인 프로파일링에 돌입해야 한다.

<br>

보고서의 Time 컬럼은 특정 패키지, 클래스, 개별 테스트 메소드가 몇 초나 걸렸는지 보여준다. 가장 느린 테스트를 찾기에 제일 효과적인 방법은 아닐지라도, 필요한 정보는 볼 수 있다.

이런 보고서는 아주 기본적인 도구지만 범위를 좁혀가며 느린 테스트를 찾을 수 있기 때문에 아주 효과적이다. 반면 프로파일러를 통해 개별 테스트의 소비기간을 일일이 확인하려 했다가는 수 시간이 훌쩍 지나갈 수도 있으니 그리 권장하지 않는 방법이다.

> **지속성 통합 서버 활용하기**
지속적 통합은 팀에서 이루어진 모든 작업 내용을 빈번히 동기화하기 위한 실천법이다. 보통은 하루에도 수차례 이상 통합하여 개발자 간 코드베이스의 차이가 크게 벌어지지 않도록 한다. 이를 더 효율적으로 하기 위해 별도의 지속적 통합 서버를 구축해두면 팀원 전체가 항상 같은 코드를 바라보고 작업할 수 있게 된다.

지속적 통합 서버는 보통 버전 관리 시스템을 주시하다가 변경이 발생하면 자동으로 전체 소스코드를 빌드한다. 컴파일이나 테스트 그리고 그 외의 어떤 작업에서라도 잘못된 것이 발견되면 빌드는 실패하고, 마지막 커밋에서 무언가 잘못되었다고 개발팀에 통지한다.

개발자는 자신의 작업과 관련된 테스트만 수행하도록 하여 느린 빌드 문제를 어느 정도 해결할 수 있다. 개발자가 버전 관리 시스템에 코드를 밀어 넣을 때마다 지속적 통합 서버가 모든 테스트를 실행할 것이고, 개발자에게 선택받지 못한 테스트에서 문제가 발견되면 바로 알려줄 것이기 때문이다.

이 방식은 단위 테스트의 피드백 주기를 단축해주니 고려해볼 만하다. 하지만 개발자에게 선택받은 테스트가 문제를 찾아내지 못한다면 개발자가 매번 모든 테스트를 돌릴 때와 비교해서 문제를 발견하는 시점이 늦어질 수 있다는 단점이 있다.
> 

## 테스트 코드 속도 높이기

테스트 코드 속도 개선의 핵심 전략은 느린 부분을 찾아내어 더 빠르게 만들거나 아예 실행시키지 않는 것이다.

테스트를 느려지게 할 수 있는 위험요소를 몇 가지 살펴보자.

### 피곤하지 않다면 잠들지 말라

테스트를 빠르게 유지하려면 테스트가 필요 이상으로 멈춰있게 해서는 안 된다.

Thread.sleep()은 사용하지 말자. 대신 동기화 객체를 활용하면 훨씬 신뢰할 수 있는 결과를 얻게 될 것이다.

### 덩치 큰 기반 클래스를 경계하라

흔히 볼 수 있는 테스트 속도 저하의 원인 중에는 개발자가 만든 기반 클래스도 포함되어 있다.

이들 기반 클래스는 보통 공통의 셋업과 티어다운 메소드 그리고 여러 가지 유틸리티 메소드를 제공한다. 그래서 테스트 작성자에게는 편리하지만 숨겨진 대가를 치러야만 한다.

하위 클래스의 모든 테스트가 이런 유틸리티 기능 전부를 사용하는 경우는 거의 없다. 따라서 기능을 필요로 하지 않는 테스트 케이스에서도 쓸데없이 반복 수행되어 성능을 떨어뜨리지는 않는지 잘 살펴야 한다.

**구조적 성능 저하 요인**

JUnit이 계층 구조를 다루는 방식 때문에 테스트 클래스의 계층 구조가 깊어질수록 셋업과 티어다운 메소드가 누적되어 테스트를 점점 느려지게 한다.

JUnit이 테스트를 실행하는 방식은 아래와 같다.

1. 리플렉션을 이용해 java.lang.Object에 닿을 때까지 전체 클래스 계층 구조를 훑으며 모든 @BeforeAll을 찾아낸다.
2. 상위 클래스부터 시작해 찾아낸 @BeforeAll 메소드를 차례로 실행한다.
3. 각각의 @Test 메소드를 실행하기 전에는 모든 상위 클래스를 훑으며 발견한 @BeforeEach 메소드를 모두 실행한다.
4. 테스트 완료 후에는 모든 @AfterEach 메소드를 찾아 실행하고, 한 클래스 안의 테스트가 모두 끝나면 @AfterAll 메소드를 찾아 모두 실행한다.

<br>

다른 클래스를 상속하면 그 클래스의 셋업과 티어다운을 매번 실행한다는 것이다. 그래서 계층이 깊어질 수록 낭비되는 CPU 시간도 길어질 것이다.

이런 낭비를 피하려면 상속보다는 컴포지션을 애용하라. 그리고 자바의 static 임포트를 사용하고 유틸리티 메소드나 셋업/티어다운을 위해서는 JUnit의 @Rule 기능을 활용해보자.

### 불필요한 셋업과 티어다운을 경계하라

@BeforeEach와 @AfterEach 메소드는 테스트 하나당 한 번씩 실행된다. 무시할 만큼 작은 오버헤드일 수도 있지만, 어떤 경우엔 제법 많은 시간을 낭비할 때도 있고, 그 시간은 계속 누적된다.

<br>

셋업을 한번만 실행해도 되는 테스트 클래스라면 해결책은 간단하다. @BeforeEach를 @BeforeAll로 바꿔주면 끝이다.

### 테스트에 초대할 손님은 까다롭게 선택하라

테스트 시간을 단축하려면 테스트가 수행하는 코드의 양을 줄여라. 더 정확하게는 테스트와 관련 없는 협력 객체를 잘라내어 테스트 대상의 범위를 가능한 한 좁혀주면 된다.

<br>

각 테스트에서 중요하지 않은 부분을 스텁으로 교체함으로써 지루한 빌드 시간을 단축할 수 잇다. 계산량이 많은 컴포넌트를 쏜살같은 테스트 더블로 교체하면 CPU가 처리해야 할 명령어가 줄어들어 테스트가 훨씬 빨리 끝나게 된다.

### 로컬하게, 그리고 빠르게 유지하라

메모리에서 몇 바이트를 읽는 데는 1마이크로 초도 걸리지 않는다. 같은 데이터라도 클라우드 서비스에서 가져오려면 지역 변수를 읽는 것보다 10만 배는 더 걸린다.

테스트를 가능한 로컬하게 유지하고 네트워크 사용을 배제해야 하는 이유가 여기 있다.

<br>

로컬하지 않은 것들을 테스트 더블로 대체하면 테스트를 격리할 수 있고 불확실한 외부 요소가 사라져서 신뢰성이 높아진다. 더불어 네트워크 장애나 웹 서비스 타임아웃 같은 특수 상황도 시뮬레이션 할 수있게 된다.

단위 테스트에서는 네트워크를 호출하지 않는 것을 기본 원칙으로 한다.

### 데이터베이스의 유혹을 뿌리쳐라

되도록 테스트 대상 코드와 가까운 협력 객체를 가짜 객체로 교체하는 것이 좋다. 테스트 대상 코드와 협력 객체 사이에서 일어나는 일만 확인하면 되는 것이지, 협력 객체와 또 다른 협력 객체 사이에서는 무슨 일이 일어나건 상관 없기 때문이다.

나아가 가장 가까운 협력 객체를 대체해야 테스트 대상과 협력 객체 간 상호작용을 일관된 수준의 추상화 용어로 서술하기 유리하다.

<br>

데이터베이스는 되도록 사용하지 않는 것이 좋다. 데이터베이스 접근은 시간이 오래 걸리고, 그곳에 저장할 데이터도 단위 테스트의 검사 내용과는 대부분 무관하기 때문이다.

잘 저장되는지도 분명 확인해야겠지만, 이는 통합 테스트와 같은 별도의 테스트에 맡기면 된다.

### 파일 I/O보다 느린 I/O는 없다

테스트를 빠르게 유지하려면 파일시스템 접근을 최소화해야 한다.

테스트가 사용하는 파일 I/O와 대상 코드에서 사용하는 파일 I/O 두 가지 측면만 잘 살피면 된다. 기능 수행에 꼭 필요한 파일 I/O도 있지만, 꼭 필요하지는 않거나 오히려 테스트하려는 동작을 방해하는 경우도 많이 있다.

<br>

테스트 코드에서 어쩔 수 없이 파일을 사용해야 하는 경우라면 처음 읽은 데이터를 캐싱해서 딱 한 번만 읽고 더이상 읽을 필요 없도록 하자.

<br>

제품 코드에서 파일 시스템을 읽고 쓰는 가장 대표적인 예는 로깅이다. 거의 모든 경우에 로깅 기능 자체도 쉽게 꺼버릴 수 있으니 누구나 간단히 사용할 수 있는 빌드 성능 최적화 기법 중 하나다.

## 빌드 속도 높이기

최적화 대상이 직접 작성한 코드나 테스트가 아니더라도 핵심은 변하지 않는다. 병목지점이 어디인지를 파악하는 것이다.

<br>

빌드 성능을 제한하는 근본 요소는 CPU 아니면 I/O다.

CPU 병목은 더 빠른 CPU를 사용하거나, 더 많은 CPU 코어를 사용하거나, 더 많은 컴퓨터를 사용해서 개선할 수 있다.

I/O 병목은 더 빠른 디스크를 사용하거나, 더 많은 쓰레드를 사용하거나, 더 많은 디스크를 사용해서 개선할 수 있다.

<br>

실무에 적용할만한 해법은 다음과 같다.

- 디스크 작업을 가속하기 위한 빠른 디스크 사용
- 더 많은 CPU와 쓰레드를 활용하기 위한 빌드 병렬화
- 더 빠른 CPU를 위한 클라우드로의 선회
- 복수의 컴퓨터에 빌드 작업 분산 실행

### 램 디스크를 활용한 초고속 I/O

고가의 하드 드라이브를 새로 사지 않고도 빠른 디스크를 얻을 방법이 있다. 컴퓨터의 램에 파일 시스템을 구현한 가상 디스크를 활용하면 된다.

메모리 일부를 가상 디스크 파티션으로 할당하면 그 위에 파일을 읽고 쓸 수 있다. 일반 디스크와 전혀 다를 게 없다. 대신 하드디스크와 달리 물리적인 회전 없이 메모리에 바로 읽고 쓰기 때문에 비교할 수 없이 빠른 성능을 체험할 수 있다.

다만, 이렇게 만들어진 램 디스크의 성능도 최신의 SSD와 비교하면 약간 더 빠른 수준이다. 그리고 요즘의 운영체제는 자체적으로 파일을 메모리에 매핑하여 디스크 I/O의 성능을 끌어올리고 있는데, 아직 이러한 전통적인 하드디스크 방식은 램 디스크와는 현격한 차이를 좁히지 못하고 있다.

### 빌드 병렬화하기

어떠한 빌드라도 언제나 컴퓨터의 능력 전부를 끌어 쓸 수는 없다.

<br>

여러분의 빌드는 모든 코어를 활용하고 있는가? 빌드 대부분을 CPU가 처리하고 있다면 코어를 둘 다 사용하면 하나만 사용할 때보다 빌드 시간을 거의 절반으로 줄일 수 있다.

빌드가 전적으로 CPU에만 의존하지는 않고 디스크 I/O에도 많은 시간을 소모한다면, 병렬화는 심지어 단일 코어 CPU에서도 효과가 좋다. CPU가 빌드의 80%를 차지하고 하드디스크가 나머지 20%를 차지한다고 가정해보자. 그렇다면 하드디스크의 응답을 기다리며 CPU가 놀고 있는 시간만큼을 개선할 수 있다.

<br>

테스트를 여러 쓰레드로 실행한다고 해서 모든 쓰레드가 동시에 실행되는 것은 아니다. 사실은 단순히 여러 쓰레드 사이를 왔다 갔다 하며 실행하게 된다. 단일 코어 CPU에서라면 무조건이다.

따라서 한 테스트 쓰레드가 디스크 I/O를 기다리는 동안 CPU는 다른 쓰레드의 코드를 실행할 수 있다.

### 고성능 CPU에 짐 떠넘기기

일반적인 빌드는 CPU를 기다리며 대부분의 시간을 보낸다. 심각한 병목 원인은 대부분 CPU이고, CPU만 업그레이드하면 곧바로 빌드 시간 단축으로 이어질 가능성이 높다.

하지만 CPU를 내 맘대로 교체할 수 있는 것도 아니니 다른 방법을 찾아야 한다.

<br>

AWS를 통해 가상 서버를 할당하고, 가상 서버가 할당되었음을 확인한 빌드 스크립트는 rsync를 이용하여 개발자의 코드베이스를 그 서버와 동기화한 후, ssh로 빌드 명령을 서버에 전달한다.

이렇게 하면 개발자의 CPU는 거의 아무런 일도 하지않는다.

### 빌드 분산하기

대다수의 빌드가 빠른 CPU의 덕을 본다 하니 빠른 걸로 한 16개쯤 달아버리면 어떨까?

그렇지만 컴퓨터 여러 대와 그 각각에 설치된 모든 코어에 작업을 분산하는 방법도 진지하게 고민해볼 필요가 있다.

<br>

그렇다면 빌드를 여러 컴퓨터로 분산하려면 어떻게 해야 할까?

1. 필요한 코드와 데이터 등의 자원을 빌드에 쓰일 원격 컴퓨터로 복제해야 한다.
2. 해당 컴퓨터에 시작 명령을 전달하고 실행 결과와 로그를 다시 개발자 컴퓨터로 받아올 수단이 필요하다.

<br>

빌드는 소스코드를 바이트 코드로 컴파일하고, 테스트를 수행하여 결과를 출력한 후 전체 테스트 결과를 하나의 보고서로 취합하는 과정으로 이루어진다.

<br>

테스트 스위트를 조각내어 원격 컴퓨터에 밀어 넣어 실행하도록 하는 건 셸 스크립트를 사용하면 된다.

하지만 어려운 것은 컴파일 단계이다. 아무렇게나 나눈 소스 파일이 독립적으로 컴파일될 수는 없다. 코드 간의 종속성 때문에 훨씬 정교한 알고리즘을 동원해야나눌 수 있다.

결국, 종속성을 분석하고 구조화하여 공통 인터페이스만을 먼저 컴파일한 후 나머지 종속 모듈은 병렬로 컴파일하게끔 할 것이다.

<br>

자바 개발자라면 운이 좋은 편이다. 대부분의 자바 프로젝트에서는 테스트와 비교하면 컴파일은 순식간에 끝나기 때문에 컴파일 단계는 한 컴퓨터가 도맡아 처리하게 하고 테스트 단계 병렬화에만 집중해도 된다.

<br>

분산 컴퓨팅과 관련해서 좋은 소식은 이것이 더는 새로운 일이 아니란 것이다. 컴퓨터 간의 커뮤니케이션을 개선하기 위한 소프트웨어가 많다.

GridGain이 그런 기술 중 하나다. GridGain은 작업을 네트워크로 연결된 다른 컴퓨터, 즉 그리드(grid)로 분산해주는 오픈 소스 미들웨어다.

사무실의 로컬 네트워크상에 AWS와 유사한 클라우드 컴퓨팅 환경을 구축할 수 있다.

<br>

GridGain의 좋은 소식은 JUnit 테스트를 분산해주는 특화 기능을 제공한다는 것이고, 나쁜 소식은 그 기능을 사용하려면 테스트 스위트에 몇 가지를 더 설정해줘야 한다는 것이다.

## 요약

성능 향상 여지가 많은 병목 구간을 빠르게 찾아낼 방법을 생각해보았다. 여기서 기억해둬야 할 핵심 단어는 프로파일링이다.

<br>

테스트 코드에서 찾을 수 있는 최적화 요소를 알아보았다. 가장 흔한 성능 저하 요인으로는 필요보다 오래 기다리는 쓰레드, 복잡한 계층 구조로 인한 불필요한 코드 수행, 적절히 격리되지 못한 테스트, 네트워크를 이용하는 테스트, 파일시스템을 읽고 쓰는 테스트 등이 있었다.

<br>

또한, 빌드 방식을 바꿔서 속도를 높이는 방법도 찾아보았다. 예를 들면 하드디스크를 SSD나 램 디스크로 바꿔주면 I/O 속도의 신세계를 경험할 수 있다. 

속도 저하의 주범이 CPU라면 테스트 스위트를 병렬화하여 가용한 모든 CPU 코어를 활용해주면 큰 효과를 볼 수 있다. 한 걸음 더 나아가 원격 컴퓨터에까지 테스트를 분산 실행할 수도 있다.
