# 테스트

## 2.1 ~ 2.3

스프링이 개발자에게 제공하는 가장 중요한 가치는 **객체지향**과 **테스트**이다.

**변화에 대응하는 전략**

- IoC와 DI
    - 스프링의 핵심인 IoC와 DI는 오브젝트의 설계와 생성, 관계, 사용에 관한 기술이다.
    - 객체지향 프로그래밍 언어의 근본과 가치를 개발자가 손쉽게 적용하고 사용할 수 있게 도와준다.
    - 객체지향을 이용하여 복잡한 엔터프라이즈 애플리케이션을 효과적으로 개발하게 해준다.
- 테스트
    - 만들어진 코드를 확신하게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 준다.
    - 스프링의 다양한 기술을 활용하는 방법을 이해하고 검증하는데 효과적으로 사용될 수 있다.

**테스트의 유용성**

- 테스트는 코드를 수정한 뒤에도 처음과 동일한 기능을 수행하는 것을 보장해준다.
- 테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 돌아가는지를 확인해서, 만든 코드를 확신할 수 있게 하는 작업이다.
- 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다.

**웹을 통한 DAO 테스트 방법의 문제**

- DAO 뿐만 아니라 서비스 클래스, 컨트롤러 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다.
- 테스트 하는 중에 에러가 나거나 테스트가 실패하면 어디서 문제가 발생했는지 찾아내야 한다.
- 테스트를 수행하는데 참여하는 클래스와 코드가 너무 많기 때문에 이런 문제들이 발생한다.

**작은 단위의 테스트**

- 테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다.
- 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다. 그래야 테스트에서 문제가 생겼어도 문제가 생긴 부분이 명확해진다.
- 이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 **단위 테스트**라고 한다.
- 단위라는 것의 크기와 범위가 어느정도인지 정해진 것은 아니고, 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다.
- 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 본다.

단위 테스트는 하나의 관심사에 집중하여 테스트 하는 것이고, 작은 단위에서 테스트하기 때문에 어느 부분의 코드가 동작하지 않는지에 대해 상대적으로 명확하다.

**자동수행 테스트 코드**

테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다. 또한 테스트 코드는 별도로 테스트용 클래스를 만들어서 테스트 코드를 넣는 편이 낫다.

자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것이다. 번거로운 작업이 없고 테스트를 빠르게 실행할 수 있기 때문에 언제든 코드를 수정하고 나서 테스트를 해볼 수 있다.

**지속적인 개선과 점진적인 개발을 위한 테스트**

테스트는 최대한 작은 단위로 작성하며 작은 테스트를 수행하고 성공하면서 지속적 확신을 얻으며 개발하는 것이 좋다.

**UserDaoTest의 문제점**

- 수동 확인 작업의 번거로움
    - 결과를 단순히 콘솔 창에 출력하여 사람이 직접 확인해야 한다.
- 실행 작업의 번거로움
    - DAO가 수백개가 되고 그에 대한 main() 메소드도 그만큼 만들어진다면 전체 기능을 테스트해보기 위해 main() 메소드를 수백번 실행하는 수고가 필요하다.

**JUnit 테스트로 전환**

JUnit은 프레임워크다. 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다. 따라서 프레임워크에서 동작하는 코드는 main() 메소드도 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.

**테스트 메소드 전환**

JUnit 프레임워크에서 테스트를 작성할 때는 조건 두 가지를 따라야 한다.

- 메소드가 public으로 선언돼야 한다.
- 메소드에 @Test라는 어노테이션을 붙여줘야 한다.

**좋은 테스트의 특징**

- 일관성 있는 테스트
    - 테스트 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.
- 포괄적인 테스트
    - 테스트를 작성할 때는 꼼꼼하게 작성하는 편이 좋다.
    - 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.

**기능설계를 위한 테스트**

만들어진 코드를 보고 이것을 어떻게 테스트할지 생각하는 것이 아니라 추가하고 싶은 기능을 테스트코드로 표현해보자고 생각하면 기능설계를 위한 테스트를 만들 수 있다.

getUserFailure() 테스트에는 만들고 싶은 기능에 대한 조건, 행위, 결과가 잘 표현되어있다.

- 조건 : 가져올 사용자 정보가 존재하지 않는 경우
- 행위 : 존재하지 않는 id로 get()을 실행하면
- 결과 : 특별한 예외가 던져진다.

기능 설계, 구현, 테스트라는 일반적인 개발 흐름 중 기능설계에 해당하는 부분을 테스트코드가 일부 담당한다고 볼 수 있다.

이런식으로 추가하고 싶은 기능을 일반 언어가 아니라 테스트코드로 표현해서, 마치 코드로 된 설계 문서처럼 만들어 놓은 것이라고 생각해보자, 그 후 실제 기능을 가진 애플리케이션 코드를 만들고 나면, 바로 테스트를 실행해서 설계한대로 코드가 동작하는지 빠르게 검증할 수 있다.

**테스트 주도 개발(TDD)**

만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법을 말한다.

실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다는 것이 TDD의 기본 원칙이다.

**장점**

- 테스트를 먼저 만들고 테스트가 성공하도록 하는 코드만 작성하기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들 수 있다.
- 테스트를 작성하는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아지기 때문에 코드에 대한 피드백을 빠르게 받을 수 있게 된다.
- 테스트가 성공하는 것을 보면서 작성한 코드에 대한 확신을 가질 수 있다.

**JUnit 프레임워크가 테스트 메소드를 실행하는 과정**

1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
    - 왜 테스트 메소드를 실행할 때마다 새로운 오브젝트를 만들까?
        - 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해서다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

**픽스처**

테스트를 수행하는데 필요한 정보나 오브젝트를 말한다. 

일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성해 두면 편리하다.

## 2.4 스프링 테스트 적용

```java
public class UserDaoTest {
    private UserDao dao;

    @Before
    public void setUp() {
        ApplicationContext context= new GenericXmlApplicationContext("applicationContext.xml");
        this.dao= context.getBean("userDao", UserDao.class);
    }
    ...
}
```

JUnit 특성상 매번 새 오브젝트를 만들게 되는데, 위 코드는 애플리케이션 컨텍스트도 메소드 개수만큼 만들어진다는 것이 문제이다.

애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화하는데, 시간을 많이 필요로 하는 자체적인 초기화 작업을 진행하는 빈, 독자적으로 많은 리소스를 할당하거나 독립적인 쓰레드를 띄우는 빈들을 사용할 때는 문제가 생길 수 있다.

독자적인 리소스나 쓰레드를 사용하는 빈을 사용하는 경우의 문제는 사용한 리소스를 깔끔하게 정리해주지 않으면 다음 테스트에서 새로운 애플리케이션 컨텍스트를 만들며 문제가 생길 수 있다는 점이다.

테스트는 일관성있는 실행 결과를 보장해야 하고, 테스트의 실행 순서가 결과에 영향을 미치지 않아야 한다. 다행히도 애플리케이션 컨텍스트는 초기화되고 나면 내부의 상태가 바뀌는 일은 거의 없다. 빈은 싱글톤으로 만들었기 때문에 상태를 갖지 않기 때문이다.

따라서 애플리케이션 컨텍스트는 한 번만 만들고 여러 테스트가 공유해서 사용해도 된다.

**테스트를 위한 애플리케이션 컨텍스트 관리**

```java
// @Runwith(SpringJUnit4ClassRunner.class) // (JUnit4)
@ExtendWith(SpringExtension.class) // (JUnit5)
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest {
    @Autowired ApplicationContext context;
		...
}
```

위와 같이 작성하면 테스트에서 사용할 애플리케이션 컨텍스트 하나를 만들고 공유하도록 지정할 수 있다.

- @RunWith, @ExtendWith는 JUnit에서 테스트 클래스를 확장할 때 사용한다.
- @ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정 파일 위치를 지정한 것이다.
- @Autowired는 테스트용 애플리케이션 컨텍스트 내부에 있는 정의된 타입의 빈(위의 경우 ApplicationContext)을 찾아서 주입해준다.

다른 클래스에서도 위 어노테이션을 붙이면 하나의 애플리케이션 컨텍스트를 공유할 수 있다.

**@Autowired**

기본적으로 타입이 일치하는 빈을 인스턴스 변수에 주입해주는 역할이다. 별도의 생성자, 수정자 등이 필요 없다. 별도의 DI 설정 없이 필드의 타입정보를 이용해 빈을 자동으로 가져올 수 있다. 이런 방법을 타입에 의한 자동 와이어링이라고 한다.

ApplicationContext 타입이 @Autowired로 불러와졌던 이유는 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록하기 때문이다. 따라서 애플리케이션 컨텍스트에는 ApplicationContext 타입의 빈이 존재하는 셈이고 DI도 가능한 것이다.

```java
@Autowired UserDao dao;
```

굳이 컨텍스트를 가져와 getBean()을 사용하는 것이 아니라, UserDao 타입을 @Autowired 해도 애플리케이션 컨텍스트에서 빈을 가져올 수 있다.

@Autowired는 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없다. 타입으로 가져올 빈 하나를 선택할 수 없는 경우에는 변수의 이름과 같은 이름의 빈이 있는지 확인한다. 변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다.

**DI와 테스트**

특정한 구현체 하나만 쓸 때는 굳이 인터페이스를 통한 DI를 해야할까? 그래도 인터페이스를 통해 DI하는것이 좋다. 이유는 다음과 같다.

- 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다.
    - 인터페이스를 사용하고 DI를 적용하는 것은 많은 비용이 들지 않지만, 적용하지 않았을 경우 변경이 필요할 때 수정에 들어가는 시간과 비용의 부담이 크다.
- 다른 차원의 서비스 기능을 도입하는데 도움이 된다.
    - 1장에서 만든 DB 커넥션 개수를 카운팅하는 부가기능이 예다. 이 경우에도 인터페이스를 통한 느슨한 결합 덕에 쉽게 이전의 코드를 고치지 않고 새로운 기능을 가진 구현 클래스를 만들고 적용할 수 있었다.
- 효율적인 테스트를 만들기 위해서이다.
    - 테스트를 잘 활용하려면 자동으로 실행 가능하며 빠르게 동작 하도록 테스트 코드를 만들어야 한다. 그러기 위해서는 가능한 작은 단위의 대상에 국한해서 테스트해야 한다. DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는데 중요한 역할을 한다.

**테스트 코드에 의한 DI**

DI는 스프링 컨테이너에 의해서만 수행될 수 있는 작업은 아니다. 오브젝트 팩토리인 DaoFactory를 이용해서 프레임워크의 도움 없이 직접 DI를 적용해보기도 했다.

```java
@Before
    public void setUp() {
        DataSource dataSource = new SingleConnectionDataSource(
                "jdbc:mysql://localhost/testdb",
                "spring",
                "book",
                true
        );
        userDao.setDataSource(dataSource); // 코드에 의한 수동 DI
```

이와 같이 DataSource를 내가 사용하고 싶은 DataSource로 바꿔도 무관하다.

 하지만 이 방식은 매우 주의해서 사용해야 한다. 이미 애플리케이션 컨텍스트에서 설정 정보를 따라 구성한 오브젝트를 가져와 의존관계를 강제로 변경했기 때문이다.

스프링 테스트 컨텍스트 프레임워크를 적용했다면 애플리케이션 컨텍스트는 테스트 중에 딱 한 개만 만들어지고 모든 테스트에서 공유해서 사용한다. UserDao 빈의 의존관계를 변경하면 나머지 모든 테스트를 수행하는 동안 변경된 애플리케이션 컨텍스트가 계속 사용될 것이다. 이는 별로 바람직하지 못하다.

그럼에도 애플리케이션 컨텍스트를 오염시켜서 테스트하고 싶다면, @DirtiesContext라는 어노테이션을 클래스나 메소드에 추가해서 진행할 수 있다. @DirtiesContext를 추가하면, 이 어노테이션이 붙은 클래스나 메소드에서는 애플리케이션 컨텍스트를 공유하지 않고 매번 새로 만들어준다.

**테스트를 위한 별도의 DI 설정**

보통은 위와 같이 애플리케이션 컨텍스트를 오염시키는 방식 보다는 테스트를 위한 설정파일을 하나 더 만드는 방식을 사용한다.

test-applicationContext.xml 이라는 파일을 생성하고, 바라보는 DB만 테스트용으로 바꿔서 사용할 수 있다.

```java
@ExtendWith(SpringExtension.class) // (JUnit5)
@ContextConfiguration(locations="/test-applicationContext.xml")
public class UserDaoTest {
```

이와 같이 locations에 파일 위치만 바꿔주면 테스트 환경에 적합한 구성을 가진 설정파일을 이용해서 테스트를 진행할 수 있다. 애플리케이션 컨텍스트도 한 개만 만들어서 모든 테스트에서 공유할 수 있다.

**컨테이너 없는 DI 테스트**

UserDao는 아예 스프링 컨테이너를 사용하지 않고도 테스트를 만들 수 있다.

UserDao나 DataSource 구현 클래스 어디에서도 스프링의 API를 직접 사용한다거나 애플리케이션 컨텍스트를 이용하는 코드는 존재하지 않는다.

UserDaoTest는 사실 UserDao 코드가 DAO로서 DB에 정보를 잘 등록하고 잘 가져오는지만 확인하면 된다. 스프링 컨테이너에서 UserDao가 동작함을 확인하는 일은 UserDaoTest의 기본적인 관심사가 아니다.

```java
public class UserDaoTest {
  UserDao dao;

  ...

  @BeforeEach
  public void setUp() {
    ...
    dao = new UserDao();
    DataSource = new SingleConnectionDataSource(
      "jdbc:mysql://localhost/testdb", "spring", "book", true
    );
    dao.setDataSource(dataSource);
  }
}
```

위와 같이 작성하면 테스트를 위한 DataSource를 직접 만드는 번거로움은 있지만, 애플리케이션 컨텍스트를 아예 사용하지 않으니 코드는 더 단순해지고 이해하기 편해졌다. 애플리케이션 컨텍스트가 만들어지는 번거로움이 없어졌으니 테스트시간도 절약할 수 있다.

DI는 객체지향 프로그래밍 스타일이다. 따라서 DI를 위해 컨테이너가 반드시 필요한 것은 아니다. DI컨테이너나 프레임워크는 DI를 편하게 적용하도록 도움을 줄 뿐, 컨테이너가 DI를 가능하게 해주는 것은 아니다.

DI를 어디에 적용할지 고민되는 경우, 효과적인 테스트를 만들기 위해서는 어떤 필요가 있을지를 생각해보면 도움이 된다. 두 개의 모듈이 강하게 결합되어 있어 DI가 불가능한 구조로 만든다면 테스트할 때 불편해진다거나, 자동화된 테스트가 아예 불가능하지 않을까 의심해보자. 일반적으로 테스트하기 좋은 코드가 좋은 코드일 가능성이 높다.

**침투적 기술과 비침투적 기술**

침투적 기술은 애플리케이션 코드가 특정 기술 관련 API나 인터페이스, 클래스 등에 종속되는것을 말한다. 비침투적 기술은 애플리케이션 로직이 특정 기술 관련 API나 인터페이스, 클래스 등에 종속되지 않는다.

비침투적 기술은 종속되지 않는 순수한 코드를 유지할 수 있게 해준다. 스프링은 이러한 비침투적 기술의 대표적인 예다. 그래서 스프링 컨테이너 없는 DI 테스트도 가능한 것이다.

**DI를 이용한 테스트 방법 선택**

DI를 테스트에 이용하는 세 가지 방법은 다음과 같았다.

- 테스트 코드에 의한 DI
- 테스트를 위한 별도의 DI 설정
- 컨테이너 없는 DI 테스트

항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가상 우선적으로 고려하자. 이 방법이 테스트 수행 속도가 가장 빠르고 테스트 자체가 간결하다. 테스트를 위해 필요한 오브젝트의 생성과 초기화가 단순하다면 이 방법을 가장 먼저 고려해야 한다.

여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트 해야 하는 경우 스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리하다. 테스트에서 애플리케이션 컨텍스트를 사용하는 경우에는 테스트 전용 설정파일을 따로 만들어 사용하는 편이 좋다. 보통 개발환경, 테스트환경, 운영환경 각각 다른 설정 파일을 만들어 사용하는 경우가 일반적이다.

테스트 설정을 따로 만들었다고 하더라도 예외적인 의존관계를 강제로 구성해서 테스트해야 할 경우가 있다. 이때는 컨텍스트에서 DI받은 오브젝트에 다시 테스트 코드로 수동 DI하는 방법을 사용하면 된다. 테스트 메소드나 클래스에 @DirtiesContext 어노테이션을 붙이는 것을 잊지 말자.

## 2.5 학습 테스트로 배우는 스프링

때로는 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성해야 한다. 이런 테스트를 **학습 테스트**라고 한다.

학습 테스트의 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것이다. 자신이 테스트를 만들려고 하는 기술이나 기능에 대해 얼마나 제대로 이해하고 있는지, 그 사용 방법을 바로 알고 있는지를 검증하려는 게 목적이다.

테스트 코드를 만드는 과정을 통해 API의 사용 방법도 익히고 내가 가진 기술에 대한 지식도 검증할 수 있다.

**학습 테스트의 장점**

- 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
    - 다양한 조건에 따라 어떻게 기능이 다르게 동작하는지 확인해보려면 수동으로 값을 입력하거나 코드를 계속 수정해가며 예제를 다시 실행해야 한다. 학습 테스트는 자동화된 테스트 코드로 만들어지기 때문에 다양한 조건에 따라 기능이 어떻게 동작하는지 빠르게 확인할 수 있다.
- 학습 테스트 코드를 개발 중에 참고할 수 있다.
    - 학습 테스트는 다양한 기능과 조건에 대한 테스트 코드를 개별적으로 만들고 남겨둘 수 있다.
    - 개발자들은 필요하다면 언제든지 학습 테스트로 만들었던 코드를 참고해볼 수 있다. 또는 좀 더 나은 사용 방법을 발견했다면 학습 테스트의 코드를 수정해서 다른 개발자와 공유할 수 있다.
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
    - 요즘은 모든 제품이 매우 빠르게 업데이트된다. 이렇게 새로운 버전으로 업그레이드를 할 때 API 사용법에 미묘한 변화가 생긴다거나, 기존에는 잘 동작하던 기능에 문제가 발생할 수도 있다.
    - 학습 테스트에 애플리케이션에서 자주 사용하는 기능에 대한 테스트를 만들어 놓았다면 새로운 버전의 프레임워크나 제품을 학습 테스트에만 먼저 적용해본다. 기존에 사용했던 API나 기능에 변화가 있거나 업데이트된 제품에 버그가 있다면, 학습 테스트를 통해 미리 확인할 수가 있다.
- 테스트 작성에 대한 좋은 훈련이 된다.
    - 테스트를 작성하는데 아직 충분히 훈련되어 있지 않거나 부담을 갖고 있다면, 먼저 학습 테스트를 작성해보면서 테스트 코드 작성을 연습할 수 있다.
- 새로운 기술을 공부하는 과정이 즐거워진다.
    - 책이나 레퍼런스 문서 등을 그저 읽기만 하는 공부는 쉽게 지루해진다.

스프링 학습 테스트를 만들 때 참고할 수 있는 가장 좋은 소스는 바로 스프링 자신에 대한 테스트 코드다. 스프링은 꼼꼼하게 테스트를 만들어가며 개발해온 프레임워크다. 거의 모든 기능에 대해 방대한 양의 테스트가 만들어져 있다.

**버그 테스트**

**버그 테스트**란 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말한다.

버그가 발생한 경우, 무턱대고 코드를 수정하는 것 보다 먼저 버그 테스트를 만들어보는 편이 좋다. 버그 테스트는 일단 실패하도록 만든 뒤에, 버그 테스트가 성공할 수 있도록 애플리케이션 코드를 수정해나간다.

버그 테스트의 필요성과 장점은 다음과 같다

- 테스트의 완성도를 높여준다.
    - 버그는 기존 테스트에서 미처 검증하지 못했던 부분이 있기 때문에 버그가 생기는 것이므로 불충분했던 테스트를 보완해주는 역할을 한다.
- 버그의 내용을 명확하게 분석하게 해준다.
    - 버그가 있을 때 그것을 테스트로 만들어서 실패하게 하려면 어떤 이유 때문에 문제가 생겼는지 명확히 알아야 한다. 따라서 버그를 좀 더 효과적으로 분석할 수 있고 그 과정에서 그 버그로 인해 발생할 수 있는 다른 오류를 함께 발견할 수도 있다.
    - 예를 들어 예외적인 상황이나 입력 값 때문에 발생하는 오류였다면, 테스트 코드를 만들면서 오류를 발생시키는 값의 범위가 어떤 것인지 분석해볼 기회가 주어진다. 테스트의 중요한 기법 중 하나인 동등분할이나 경계값 분석을 적용해볼 수도 있다.
- 기술적인 문제를 해결하는데 도움이 된다.
    - 때로는 버그가 있다는 건 알겠지만 그 원인이 무엇인지 정확하게 파악하기 힘들 때가 있다. 이럴 땐 동일한 문제가 발생하는 가장 단순한 코드와 그에 대한 버그 테스트를 만들어보면 도움이 된다.

동등 분할

- 같은 결과를 내는 값의 범위를 구분해서 각 대표 값으로 테스트를 하는 방법을 말한다. 어떤 작업의 결과의 종류가 true, false 또는 예외발생 세 가지라면, 각 결과를 내는 입력 값이나 상황의 조합을 만들어 모든 경우에 대한 테스트를 해보는 것이 좋다.

경계값 분석

- 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트하는 방법이다. 보통 숫자의 입력 값인 경우 0이나 그 주변 값 또는 정수의 최대값, 최소값 등으로 테스트해볼 수 있다.

# 2.6 정리

- 테스트는 자동화돼야 하고, 빠르게 실행할 수 있어야 한다.
- main() 테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다
- 테스트 결과는 일관성이 있어야 한다.
    - 코드의 변경 없이 환경이나 테스트 실행 순서에 따라서 결과가 달라지면 안 된다.
- 테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나쁠 수 있다.
    - 네거티브 테스트 먼저 작성하는 습관을 들이자.
- 코드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
- 테스트하기 쉬운 코드가 좋은 코드다.
- 테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 TDD도 유용하다.
- 테스트 코드도 애플리케이션 코드와 마찬가지로 적절한 리팩토링이 필요하다.
- @Before, @After를 사용해서 테스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다.
- 동일한 설정파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.
- @Autowired를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI 할 수 있다.
- 기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성하자.
- 오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용하다.
