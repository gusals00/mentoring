# 신뢰성

테스트를 작성하는 이유이기도 한 신뢰할 수 있는 코드를 만들기 위해서는 테스트 자체도 믿음직해야 한다.

소프트웨어 개발에는 코드를 수정하고 개선하고 관리하는 일이 빠질 수 없는데, 만약 테스트를 믿지 못한다면 아무 관련 없어 보이는 코드라도 쉽사리 바꾸지 못한다.

<br>

테스트의 신뢰성에 누를 끼치는 주요 요인과 믿지 못할 테스트로 인한 문제 및 관련 테스트 냄새를 하나씩 살펴보자.

## 주석으로 변한 테스트

주석으로 변한 테스트는 아무런 설명도 없이 읽는 이에게 혼란만을 안겨준다.

<br>

먼저 그 테스트에 무슨 일이 있었는지 알만한 사람을 찾아 물어보자. 기억하는 사람이 없다면 다음을 따르자.

1. 목적을 이해하려 노력해보고 검증해본다. 성공했다면 주석을 풀고 파악한 목적이 더 잘 표현되게끔 리팩토링한다.
2. 실패했다면 미련 없이 지워버린다.

<br>

주석으로 변한 코드는 절대 실행될 수 없는 죽은 코드다. 주석 처리한 이유를 바로 알아내지 못했다면 앞으로도 영원히 알아내지 못할 가능성이 높다. 그렇다면 테스트를 깨끗이 제거하는 게 차라리 낫다.

주석으로 변한 테스트는 주석 처리한 이유를 찾기 위해 프로그래머의 아까운 시간을 좀먹게 하는 고약한 냄새다.

## 오해를 낳는 주석

오해를 낳는 주석은 거짓말을 늘어놓는 제멋대로인 녀석이다. 그 주석을 곧이곧대로 믿고 엉뚱한 곳에서 헤매는 프로그래머를 종종 볼 수 있다.

<br>

잘못된 주석은 있는 것만 못한 주석이 된다. 가장 좋은 것은 주석이 필요 없는 테스트 코드를 작성하는 것이다.

주석 없이는 동작을 이해하기 어려운 코드가 있다면 아직 코드를 충분히 리팩토링하지 못했다는 뜻이다. 변수명을 더 잘 지어주거나 코드 블록을 서술적인 이름의 private 메소드로 추출해야 했을지도 모른다.

<br>

좋은 주석은 ‘무엇’이 아닌 ‘왜’를 설명하는 주석이 좋은 주석이다. 코드가 무엇을 하는지 설명하는 주석은 무조건 코드 냄새라고 보면 된다. 그런 주석이 필요 없을 만큼 쉽게 읽을 수 있는 코드를 작성해야 한다.

## 절대 실패하지 않는 테스트

절대 실패하지 않는 테스트는 결코 좋은 게 아니다. 사고가 나도 알려줄 리 만무하며, 오히려 테스트에 통과했으니 문제없을 것이라는 잘못된 인식을 심어줄 수 있으니 없느니만 못하다.

<br>

예외가 발생하길 기대하는 테스트를 작성할 때는 예외가 발생하지 않았을 때 반드시 fail()을 불러줘야 한다는 사실을 잊어선 안 된다. 이는 JUnit4부터 사용 가능한 @Test의 expected 속성으로 대체할 수 있다. 하지만 이 방식은 예외 객체에 접근할 기회가 사라져 깊이 있는 단언이 불가능하다.

<br>

테스트라면 실패해야 할 상황에서는 반드시 실패해야 한다.

## 지키지 못할 약속

테스트가 자신이 내세운 것보다 훨씬 적은 것을 검사하거나, 심지어 아무것도 검사하지 않는다는 게 지키지 못할 약속의 본질적인 문제다.

이런 일은 크게 세 가지 경우에 생긴다.

- 아무 일도 안 하는 테스트
- 무언가 일은 하지만, 정작 검증은 전혀 하지 않는 테스트
- 이름값 못하는 테스트

<br>

코드를 주석 형태로 남겨 놓기 보다는 아예 지워버리고,

단언문을 빠뜨리지 않도록 신경 쓰고,

테스트의 이름과 실제로 검사하는 내용이 일치하는지 살펴야 한다.

<br>

단언문부터 먼저 작성하고 테스트 코드를 다 채운 후에 테스트의 이름을 결정하는 것도 좋은 방법이다.

## 낮아진 기대치

쉬운 길을 찾다 보니 검증 정확도와 정밀도까지 낮춰버리는 테스트 냄새를 낮아진 기대치라고 한다.

낮아진 기대치는 실패해야 할 상황에서도 실패하지 않는 강건한 테스트를 만들어낸다.

<br>

낮아진 기대치에 대한 확실한 대처법은 기준을 다시 높여서 예상한 바를 정확하게 검사하는 것이다.

그렇다고 완전무결한 정확함만이 꼭 미덕은 아니다. 픽셀 퍼펙션은 너무 정밀한 테스트가 가져올 수 있는 잠재적인 단점을 상기해주는 좋은 예다. 그러니 테스트에 가장 적절한 추상화 수준을 항시 고민해야 한다.

## 플랫폼 편견

플랫폼 편견이란 모든 플랫폼을 동등하게 다루지 못하는 테스트 냄새라고 할 수 있다.

<br>

플랫폼에 의존하는 테스트는 테스트를 어디서 실행하는지에 따라 테스트의 실행 결과가 달라지게 만든다. 다른 플랫폼에서는 실패하는 테스트지만, 테스트가 성공한다고 믿게 만든다.

플랫폼 별로 테스트를 해야하는 상황이라면 제품 코드를 리팩토링 하는 것을 검토해야 한다. 제품 코드 내부에 플랫폼에 종속된 로직을 제거하고 플랫폼별로 달라지는 요소를 파라미터로 받을 수 있게 하면 된다.

## 조건부 테스트

조건부 테스트란 테스트 안에 숨겨진 조건 때문에 테스트의 이름이 의미하는 것과 다르게 동작하는 걸 말한다.

<br>

테스트에서 조건문을 찾아내면 모든 갈래가 확실한 실패 조건을 가졌는지 확인하자.

테스트 안의 조건문은 자칫 개발자를 오해하게 할 수 있는 나쁜 신호다. 실패해야 할 상황인데 성공할 수도 있고, 심지어 제대로 검증하고 성공했다 해도, 디버거로 확인해보기 전까지는 정말로 기대한 경로를 따라 실행된 것인지 확신할 수 없다.

<br>

기본적으로 테스트 메소드의 모든 분기에는 자신만의 실패 조건이 있어야 한다. 하지만 엄밀히 말하면 테스트하려는 시나리오와 동작이 분기별로 서로 다르다는 뜻이니 각각을 독립된 테스트로 갈라놓는 것이 옳다.
