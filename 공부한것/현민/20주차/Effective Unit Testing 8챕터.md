# 제 2의 JVM 언어를 활용한 테스트 작성

## JVM 언어 혼용의 조건

제 2의 JVM 언어의 역사는 파이썬 언어의 JVM 버전인 자이썬(Jython)을 선보이면서 시작되었다. 사용자를 충분히 확보하지 못하여 실질적인 개발이 중단되었지만, 또 다른 JVM 언어들이 등장하는 계기가 되어주었다.

### 일반적인 이점

이들 JVM 언어는 자신만의 독특한 프로그래밍 방식을 제공한다.

그루비는 자바 코드와의 매끄러운 상호운용성과 간소화된 문법이 주는 간결함을 특징으로 하며, JRuby는 중괄호가 넘쳐나는 자바 문법과는 완전히 다른 세게를 보여준다.

스칼라는 객체지향 언어인 자바에 함수형 프로그래밍의 힘을 더해주고, 클로저는 리스프와 같은 전형적인 함수형 프로그래밍 언어다.

<br>

이들 언어로 얻을 수 있는 잠재적 이점은 다음과 같다.

- 자질구레한 문법이 적어 핵심 로직이 잘 드러난다.
- 더 읽기 쉬운 데이터 구조를 제공한다.
- 표준 데이터 타입을 편하게 다룰 수 있는 메소드를 추가로 제공한다.
- 더 강력한 기능을 언어 차원에서 지원한다.

### 테스트 작성하기

구조적인 탁월함과 표현력, 풍부한 API, 강력한 기본 기능이 주는 장점은 테스트 작성에도 그대로 적용된다.

**성능보다 가독성**

제품 개발에 그루비나 루비와 같은 동적 언어를 사용하길 꺼리는 이유 중 하나는 바로 성능이다.

표현력과 간결함 문법을 얻을 수 있지만, 최고의 성능을 얻을 수 없기 떄문이다. 하지만 테스트 코드 관점에서 보면 느린 성능은 치명적인 걸림돌이 되지 않는다.

테스트에서 더 중요한 것은 결국 가독성이고, 가독성은 동적 언어가 자랑하는 특징이다.

**“미끼”로써의 테스트**

이처럼 동적 언어는 테스트라는 작업 성격에 더 적합한 언어다. 또한, 자동화된 테스트에만 제한적으로 적용하고 제품 코드는 익숙한 자바로 계속 작성할 수 있다. 따라서 새로운 언어를 익히고 적용하는 부담도 크지 않다.

물론 여러 언어를 함께 쓰는 게 꼭 좋은 점만 있는 건 아니다. 빌드 프로세스가 더 복잡해지고, 제품의 API가 다른 자바 코드에서 사용하기 알맞은 형태인지 확인하기 어렵게 된다.

**테스트용 언어는 따로 있다**

목적을 테스트 작성으로 한정한다면 다양한 JVM 언어 중에서도 우열을 가릴 수 있다.

테스트 작성에는 대체로 간결한 문법과 다목적 데이터 구조를 제공하는 언어가 적합하다.

그렇다면 가장 적합한 언어는 루비와 그루비다. 루비는 아주 단순한 문법으로 유명하며, 그루비는 자바 프로그래머가 익히기에 더 쉽다.

## BDD 도구의 뛰어난 표현력

BDD는 한 TDD 실천자가 테스트의 의도를 더 명확하게 표현하기 위한 용어를 찾는 과정에서 탄생하였다.

사실 테스트라는 단어는 원하는 동작을 정의한다는 정신을 잘 반영하지 못하며 의미가 너무 함축적이다.

그래서 개발자 커뮤니티에서는 테스트와 테스트보다는 명세(스펙)와 행위(동작)라는 용어를 거론하기 시작했다.

<br>

더 적합한 용어를 찾으려는 노력의 부산물로, BDD 커뮤니티는 JUnit 등 기존 테스트 프레임워크의 대안도 다수 만들어낼 수 있었다. 이들 도구는 기대하는 동작과 테스트의 의도를 더 명확하게 드러내 주는 동시에 산만한 문법은 뒤로 숨겨준다.

### easyb로 작성한 그루비 명세

프로그래머가 테스트를 얼마나 쉽게 작성할 수 있는가는 테스트 프레임워크의 효용성을 평가하는 중요 지표 중 하나다. 또 다른 중요 지표는 테스트의 목적을 설명하는 데 필요한 문법의 양이다.

필요한 문법이 많을수록 본질과 관련 없는 부가요소가 늘어나므로 의도를 파악하기가 점점 더 어려워지는 경향이 있다.

<br>

easyb는 문자열 상수로 표현할 수 있는 자유로움과 given-when-then의 구조의 사이에서 절묘한 조화를 보여준다.

```java
scenario “새 리스트는 비어 있다.”, {
    given “새 리스트를 만든다.”, {
        list = new List()    
    }     
    then “리스트는 비어 있어야 한다.”, {
        list.isEmpty().shouldBe true    
    }
}

scenario “원소를 포함한 리스트는 비어 있지 않다.”, {
    given “새 리스트를 만든다.”, {
        list = new List()    
    }
    when “원소를 하나 넣는다.“, {
        list.add(new Object())
    }     
    then “리스트는 비어 있지 않아야 한다.”, {
        list.isEmpty().shouldBe false
    }
}
```

이런 구조는 의미가 불분명한 API를 많이 다루는 특수 영역을 검증할 때 특히 유용하지만, 한눈에 알 수 있을 정도로 API가 명백한 대상에게는 다소 장황하게 느껴질 수 있다.

### 테스트의 표현력을 높여주는 스폭

스폭 프레임워크로 작성한 명세는 easyb 시나리오와 거의 흡사하다.

```java
class ListSpec extends Specification {
    def setup() {
        list = new List()    
    }     

    def “처음에는 비어 있다.”() {
        expect:
            list.isEmpty() == true    
    }    

    def “원소를 넣으면 더 이상 비어 있지 않다.”() {
        when:
            list.add(new Object())
        then:
            list.isEmpty() == false   
    }
}
```

다만, 동작 방식 면에서는 스폭이 easyb에 비해 훨씬 선언적이다.

이 스폭이란 것은 feature라는 독특한 생명주기를 갖는 메소드를 실행하도록 만들어진 프레임워크다.

feature 메소드의 생명주기는 총 여섯 단계로 나뉘며 각 단계를 블록이라 부른다.

- when 블록에는 테스트 대상 코드를 자극할 때 실행하는 코드를 담는다.
- expect나 then 블록 안의 문장은 단언문으로 취급되며, 평과 결과는 물론 참이어야 한다.
- setup 혹은 given 블록은 생략하는 경우가 많다. feature 메소드에서 첫 블록보다 앞서 기술된 모든 코드가 암묵적으로 setup으로 간주하기 때문이다.
- cleanup 블록은 JUnit의 @After 메소드와 비슷한 용도이다.
- where 블록은 언제나 feature 메소드의 마지막에 자리하며, feature 메소드를 파라미터화하여 실행한다.

### 스폭의 또 다른 무기, 테스트 더블

스폭 프레임워크는 비 final 클래스와 인터페이스의 테스트 더블을 생성해주는 기능을 기본으로 제공한다.

스폭의 용어로는 mock 이라고 하며 다음과 같이 두 가지 생성 방식을 제공한다.

```java
def screen = Mock(Screen) // '동적' 방식
Keyboard keyboard = Mock() // '정적' 방식, 프레임워크가 변수의 타입을 보고 적절한 Mock을 알아서 결정해준다.
```

당연히 이 테스트 더블도 다양한 상황에 대응하기 위한 설정 메소드를 제공한다. 예를 들어 메소드가 하드코딩된 값만 반환하는 스텁으로 만들려면 다음처럼 하면 된다.

```java
keyboard.receive() >> “스텁으로 만든 고정된 입력입니다.”
```

## 요약

제 2의 JVM 언어의 장점은 훨씬 간결한 문법과 언어의 강력한 기본 기능 덕분에 전반적으로 더 가독성 높은 코드를 작성할 수 있다는 것이다.

테스트에 동적 언어를 사용하는 이유가 위험부담 없이 새로운 언어를 익히기 위해서건, 그 언어의 장점에 이끌려서건 상관없이, 분명 테스트의 많은 부분이 개선될 것이다.

<br>

그루비는 자바와 비슷하면서도 훨씬 간결한 문법과 뛰어난 표현력 그리고 언어의 유연함으로 인해 많은 프로그래머에게 사랑받고 있다.

더 구체적으로 보면, 세미콜론과 괄호 그리고 키워드 역시 생략할 수 있는 경우가 많다. 변수의 타입은 문맥에 맞게 자동으로 할당해주고, 기본 접근제한자가 public이라 대부분의 경우엔 따로 명시해줄 필요가 없다. 이런 작은 개선이 모여서 테스트를 더 간결하고 분명하게 만들어준다.

<br>

easyb와 스폭이라는 오픈 소스 BDD 프레임워크를 이용하여 원하는 동작을 표현하는 모습도 보았다. 이는 정통적인 JUnit과는 상당히 다른 표현 방식이자, 많은 경우에 더 나은 방식이기도 하다.
