# 메소드

## 49. 매개변수가 유효한지 검사하라

메소드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. 이런 제약은 반드시 문서화해야 하며, 메소드 몸체가 시작되기 전에 검사해야 한다.

오류를 발생한 즉시 잡지 못하면 해당 오류를 감지하기 어려워지고, 감지하더라도 오류의 발생 지점을 찾기 어려워진다.

<br>

매개변수 검사를 제대로 하지 못하면 몇 가지 문제가 생길 수 있다.

1. 메소드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
2. 메소드가 잘 수행되지만 잘못된 결과를 반환할 수 있다.
3. 메소드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어놓아서 미래의 알 수 없는 시점에 이 메소드와는 관련 없는 오류를 낼 수 있다.

다시 말해 매개변수 검사에 실패하면 실패 원자성을 어기는 결과를 낳을 수 있게된다.

<br>

public과 protected 메소드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.

매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.

<br>

자바 7에 추가된 java.util.Objects.requireNonNull 메소드는 유연하고 사용하기도 편하니, 더 이상 null 검사를 수동으로 하지 않아도 된다. 원하는 예외 메세지도 지정할 수 있고, 입력을 그대로 반환하므로 값을 사용하는 동시에 null 검사를 수행할 수 있다.

자바9에서는 Objects에 범위 검사 기능도 더해졌다. checkFromIndexSize, checkFromIndex, checkIndex 라는 메소드들인데 예외 메세지를 지정할 수 없고, 리스트와 배열 전용으로 설계됐다.

<br>

메소드 몸체 실행 전에 매개변수 유효성을 검사해야 한다는 규칙에도 예외는 있다. 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때, 혹은 계산 과정에서 암묵적으로 검사가 수행될 때다.

- 예를 들어 Collections.sort(List) 처럼 객체 리스트를 정렬하는 메소드의 리스트 안의 객체들은 모두 상호 비교될 수 있어야 한다.
- 만약 상호 비교될 수 없는 타입의 객체가 들어 있다면, 그 객체와 비교할 때 ClassCastException을 던질 것이다.
- 따라서 비교하기 앞서 리스트 안의 모든 객체가 상호 비교될 수있는지 검사해봐야 별다른 실익이 없다.

<br>

**정리**

메소드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야 한다.

그 제약들을 문서화하고 메소드 코드 시작 부분에서 명시적으로 검사해야 한다.

## 50. 적시에 방어적 복사본을 만들라

자바는 안전한 언어다.

- 네이티브 메소드를 사용하지 않는다.
    - 버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌 오류에서 안전하다.
- 자바의 클래스는 시스템의 다른 부분에서 무슨 짓을 하든 불변식이 지켜진다.

<br>

클라이언트가 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍 해야 한다.

- 아무리 자바라 해도 다른 클래스로부터의 침범을 아무런 노력 없이 다 막을 수 있는 건 아니다.
- 악의적인 의도를 가진 사람들이 시스템의 보안을 뚫으려는 시도가 늘고 있다.
- 평범한 프로그래머도 실수로 클래스를 오작동하게 만들 수 있다.

<br>

불변인 클래스를 만들었다고 해도 클래스가 클라이언트로부터 받거나 클라이언트로 반환하는 구성요소가 가변이라면 외부에 의해 불변식이 깨질 수 있다.

- 외부 공격으로부터 인스턴스 내부를 보호하려면 가변 매개변수 각각을 방어적으로 복사해야 한다.
- 반환하는 요소가 가변이라면 접근자가 가변 필드의 방어적 복사본을 반환하면 된다.

<br>

매개변수를 방어적으로 복사하는 목적이 불변 객체를 만들기 위해서만은 아니다.

메소드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지를 생각해야 한다.

되도록 불변 객체들을 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어든다.

<br>

**정리**

클래스가 클라이언트로부터 받거나 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.

복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하자.

## 51. 메소드 시그니처를 신중히 설계하라

1. 메소드 이름을 신중히 짓자.
    - 이해할 수 있고, 같은 패키지에 속한 다른 이름들과 일관되게 짓는 게 최우선 목표다.
    - 그다음 목표는 개발자 커뮤니티에서 널리 받아들여지는 이름을 사용하고, 긴 이름을 피하자.
2. 편의 메소드를 너무 많이 만들지 말자
    - 모든 메소드는 각각 자신의 소임을 다해야 한다. 메소드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어렵다.
    - 메소드가 너무 많으면 이를 구현하는 사람과 사용하는 사람 모두를 고통스럽게 한다.
    - 아주 자주 쓰일 경우에만 별도의 약칭 메소드를 두자. 확신이 서지 않으면 만들지 말자.
3. 매개변수 목록은 짧게 유지하자.
    - 4개 이하가 좋다. 일단 4개가 넘어가면 매개변수를 전부 기억하기가 쉽지 않다.
    - 같은 타입의 매개변수 여러 개가 연달아 나오는 경우가 특히 해롭다. 사용자가 순서를 기억하기 어려울뿐더러, 실수로 순서를 바꿔 입력해도 그대로 컴파일되고 실행된다.
    - 과하게 긴 매개변수 목록을 짧게 줄여주는 방법들은 아래와 같다.
        1. 여러 메소드로 쪼갠다.
        2. 매개변수 여러 개를 묶어주는 도우미 클래스를 만들자. 일반적으로 이런 도우미 클래스는 정적 맴버 클래스로 둔다.
        3. 빌더 패턴을 메소드 호출에 응용한다. 이 기법은 매개변수가 많을 때, 특히 그중 일부는 생략해도 괜찮을 때 도움이 된다.
        4. boolean보다는 원소 2개짜리 열거 타입이 낫다.(메소드 이름상 boolean을 받아야 의미가 더 명확할 때는 예외다) 열거 타입을 사용하면 코드를 읽고 쓰기가 더 쉬워지고, 나중에 선택지를 추가하기도 쉽다.

## 52. 다중정의는 신중히 사용하라

```java
public class CollectionClassifier {
	public static String classify(Set<?> s){
		return "집합";
	}
	public static String classify(List<?> s) {
		return "리스트";
	}
	public static String classify(Collection<?> s) {
		return "그 외";
	}

	public static void main(String[] args) {
		Collection<?>[] collections = {
			new HashMap<String>(),
			new ArrayList<BigInteger>(),
			new HashMap<String,String>().values()
		};
		for(Collection<?> c : collections){
			System.out.println(classify(c));
		}
	}
}
```

위 코드가 “집합”, “리스트”, “그 외”를 차례로 출력할 것 같지만, 실제로 수행해보면 “그 외”만 세 번 연달아 출력하는 이유가 뭘까?

- 다중정의된 세 classify 중 어느 메소드를 호출할지가 **컴파일타임**에 정해지기 때문이다.
- 컴파일타임에는 for문 안의 c는 항상 Collection<?> 타입이기 때문이다.

이처럼 직관과 어긋나는 이유는 **재정의한 메소드는 동적으로 선택되고, 다중정의한 메소드는 정적으로 선택되기 때문**이다.

<br>

다중정의가 혼동을 일으키는 상황을 피해야 한다. 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.

다중정의하는 대신 메소드 이름을 다르게 지어주는 길도 항상 열려 있다.

생성자는 이름을 다르게 지을 수 없으니 두 번째 생성자부터는 무조건 다중정의가 된다. 하지만 정적 팩토리라는 대안을 활용할 수 있는 경우가 많다.

매개변수 수가 같은 다중정의 메소드가 많더라도, 그중 어떤 것이 주어진 매개변수 집합을 처리할지가 명확히 구분된다면 헷갈릴 일은 없을 것이다.

- 즉, 매개변수 중 하나 이상이 근본적으로 다르면 헷갈릴 일이 없다.
    - 근본적으로 다르다는 건 두 타입(null이 아닌)의 값을 어느 쪽으로든 형변환할 수 없다는 뜻이다.
    - 이 조건만 충족하면 어느 다중정의 메소드를 호출할지가 매개변수들의 런타임 타입만으로 결정된다.
    - ex) ArrayList의 int를 받는 생성자와 Collection을 받는 생성자

## 53. 가변인수는 신중히 사용하라

가변인수 메소드는 명시한 타입의 인수를 0개 이상 받을 수 있다.

가변인수 메소드를 호출하면, 가장 먼저 인수의 개수와 길이가 같은 배열을 만들고 인수들을 이배열에 저장하여 가변인수 메소드에 건네준다.

```java
static int min(int... args){
	if(args.length == 0) throw new IllegalArgumentException("인수가 1개 이상 필요합니다.");
	int min = args[0];
	for(int i = 1; i < args.length; i++){
		if(args[i] < min) min = args[i];
	}
	return min;
}
```

인수가 1개 이상이어야 할 때도 있다. 하지만 위 방식에는 문제가 있다.

인수를 0개만 넣어 호출하면 컴파일타임이 아닌 런타임에 실패하고, 코드도 지저분하다.

```java
static int min(int firstArg, int... remainingArgs){
	int min = firstArg;
	for(int arg: remainingArgs){
		if(arg < min)
			min = arg;
	return min;
}
```

다음 코드처럼 매개변수를 2개 받도록 하면 된다. 첫 번째로는 평범한 매개변수를 받고, 가변인수는 두 번째로 받으면 앞서의 문제가 말끔히 사라진다.

<br>

그런데 성능에 민감한 상황이라면 가변인수가 걸림돌이 될 수 있다. 가변인수 메소드는 호출될 때마다 배열을 새로 하나 할당하고 초기화하기 때문이다.

이때 사용할 수 있는 멋진 패턴이 있다.

- 예를 들어 해당 메소드 호출의 95%가 인수를 3개 이하로 사용한다고 해보자.
- 그렇다면 다음과 같이 인수가 0개인 것부터 4개인 것까지 5개를 다중정의하고, 마지막 다중정의 메소드가 인수 4개 이상인 5%의 호출을 담당하게 할 수 있다.

```java
public void foo() {}
public void foo(int a1) {}
public void foo(int a1, int a2) {}
public void foo(int a1, int a2, int a3) {}
public void foo(int a1, int a2, int a3, int... rest) {}
```

- 따라서 메소드 호출 중 단 5%만이 배열을 생성한다.
- 보통 때는 별 이득이 없지만, 꼭 필요한 특수 상황에서는 필요할 수 있다.

## 54. null이 아닌, 빈 컬렉션이나 배열을 반환하라

컬렉션이나 배열 같은 컨테이너가 비었을 때 null을 반환하는 메소드를 사용할 때면 클라이언트에서 항상 null 상황을 처리하는 방어 코드를 넣어줘야 한다.

<br>

때로는 빈 컨테이너를 할당하는 데도 비용이 드니 null을 반환하는 쪽이 낫다는 주장도 있다. 하지만 이는 두 가지 면에서 틀린 주장이다.

1. 성능 분석 결과 이 할당이 성능 저하의 주범이라고 확인되지 않는 한, 이 정도의 성능 차이는 신경 쓸 수준이 못 된다.
2. 빈 컬렉션과 배열은 굳이 새로 할당하지 않고도 반환할 수 있다.

    ```java
    public List<Cheese> getCheeses(){
    	return cheesesInStock.isEmpty() ? Collections.emptyList() : new ArrayList<>(cheesesInStock);
    }
    ```

    - 매번 똑같은 빈 ‘불변’ 컬렉션을 반환할 수 있다.
        - `Collections.emptyList()`, `Collections.emptySet()`, `Collections.emptyMap()`
    - 배열을 쓸 때도 마찬가지다.
        - `return cheesesInstock.toArray(new Cheese[0]);`

<br>

**정리**

null이 아닌, 빈 배열이나 컬렉션을 반환하라.

null을 반환하는 API는 사용하기 어렵고 오류 처리 코드도 늘어난다. 그렇다고 성능이 좋은 것도 아니다.

## 55. 옵셔널 반환은 신중히 하라

보통을 T를 반환해야 하지만 특정 조건에서는 아무것도 반환하지 않아야 할 때 T 대신 Optional<T>를 반환하도록 선언하면 된다.

옵셔널을 반환하는 메소드는 예외를 던지는 메소드보다 유연하고 사용하기 쉬우며, null을 반환하는 메소드보다 오류 가능성이 작다.

<br>

옵셔널은 반환값이 없을 수도 있음을 API 사용자에게 명확히 알려준다.

메소드가 옵셔널을 반환한다면 클라이언트는 값을 받지 못했을 때 취할 행동을 선택해야 한다.

1. 기본값을 설정한다.
    - `max(words).orElse(”단어 없음…”);`
    - 기본값을 설정하는 비용이 커서 부담이 될 때는 Supplier<T>를 인수로 받는 orElseGet을 사용하면 값이 처음 필요할 때 Supplier<T>를 사용해 생성하므로 초기 설정 비용을 낮출 수 있다.
2. 상황에 맞는 예외를 던진다.
    - `max(toys).orElseThrow(TemperTantrumException::new);`
3. 옵셔널에 항상 값이 채워져 있다고 확신한다면 곧바로 값을 꺼내 사용하는 선택지도 있다.
4. 앞서의 기본 메소드로 처리하기 어려워 보인다면 filter, map, flatMap, ifPresent를 고려해보자.
    - isPresent 메소드는 원하는 모든 작업을 수행할 수 있지만 신중히 사용해야 한다. isPresent는 앞서 언급한 메소드들로 대체할 수 있으며, 그렇게 하면 더 짧고 명확하고 용법에 맞는 코드가 된다.

    ```java
    Optional<ProcessHandle> pratentProcess = ph.parent();
    System.out.println("부모 PID: " + (parentProcess.isPresent() ?
    		String.valueOf(parentProcess.get().pid()) : "N/A"));
    
    // 위 코드는 Optional의 map을 사용하여 아래와 같이 다듬을 수 있다.
    
    System.out.println("부모 PID: " +
    		ph.parent().map(h -> String.valueOf(h.pid()))).orElse("N/A"));
    ```


반환값으로 옵셔널을 사용한다고 해서 무조건 득이 되는 건 아니다. 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안 된다.

빈 Optional<List<T>> 를 반환하기보다는 빈 List<T>를 반환하는 게 좋다.

<br>

그렇다면 어떤 경우에 메소드 반환 타입을 T 대신 Optional<T>로 선언해야 할까?

- 결과가 없을 수 있으며, 클라이언트가 이 상황을 특별하게 처리해야 한다면 Optional<T>를 반환한다.
- Optional<T>를 반환하는 데는 대가가 따른다. Optional도 엄연히 새로 할당하고 초기화해야 하는 객체이고, 그 안에서 값을 꺼내려면 메소드를 호출해야하니 한 단계를 더 거치는 셈이다.
    - 따라서 성능이 중요한 상황에서는 옵셔널이 맞지 않을 수 있다.
- 박싱된 기본 타입을 담는 옵셔널은 기본 타입 자체보다 무거울 수 밖에 없다. 그래서 자바 API 설계자는 int, long double 전용 옵셔널 클래스들을 준비해놨다. OptionalInt, OptionalLong, OptionalDouble이다.
    - 이렇게 대체재까지 있으니 박싱된 기본 타입을 담은 옵셔널을 반환하는 일은 없도록 하자.
- 옵셔널을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는 게 적절한 상황은 거의 없다.

<br>

**정리**

값을 반환하지 못할 가능성이 있고, 호출할 때마다 반환값이 없을 가능성을 염두에 둬야 하는 메소드라면 옵셔널을 반환해야 할 상황일 수 있다.

하지만 옵셔널 반환에는 성능 저하가 뒤따르니, 성능에 민감한 메소드라면 null을 반환하거나 예외를 던지는 편이 나을 수 있다.

옵셔널을 반환값 이외의 용도로 쓰는 경우는 매우 드물다.

## 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라

API를 올바로 문서화하려면 공개된 모든 클래스, 인터페이스, 메소드, 필드 선언에 문서화 주석을 달아야 한다.

문서화 주석이 없다면 자바독도 그저 공개 API 요소들의 ‘선언’만 나열해주는 게 전부다. 문서가 잘 갖춰지지 않은 API는 쓰기 헷갈려서 오류의 원인이 되기 쉽다.

<br>

메소드용 문서화 주석에는 해당 메소드와 클라이언트 사이의 규약을 명료하게 기술해야 한다.

상속용으로 설계된 클래스의 메소드가 아니라면 그 메소드가 어떻게 동작하는지가 아니라 무엇을 하는지를 기술해야 한다.

<br>

문서화 주석에는 클라이언트가 해당 메소드를 호출하기 위한 전제조건을 모두 나열해야 한다. 또한 메소드가 성공적으로 수행된 후에 만족하는 사후조건도 모두 나열해야 한다.