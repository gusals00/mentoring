# 예외

## 69. 예외는 진짜 예외 상황에만 사용하라

```java
try {
    int i = 0;
    while(true)
        range[i++].climb();
} catch(ArrayIndexOutOfBoundsException e) {
}
```

JVM은 배열에 접근할 때마다 경계는 넘지 않는지 검사하는데, 반복문도 배열 경계에 도달하면 종료하기 때문에 같은 일이 중복되므로 하나를 생략한 것이다.

<br>

하지만 위와 같이 예외를 제어 흐름용으로 써서는 안 된다.

- 예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약하다.
- 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.
- 배열을 순회하는 표준 관용구는 앞서 걱정한 중복 검사를 수행하지 않는다. JVM이 알아서 최적화해 없애준다.

<br>

예외는 오직 예외 상황에서만 써야 한다.

## 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.

검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다.

<br>

프로그램에서 비검사 예외나 에러를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많다는 뜻이다.

프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.

## 71. 필요 없는 검사 예외 사용은 피하라

검사 예외가 프로그래머에게 주는 부담은 메소드가 단 하나의 검사 예외만 던질 때가 특히 크다.

이미 다른 검사 예외도 던지는 상황에서 또 다른 검사 예외를 추가하는 경우라면 기껏해야 catch 문 하나 추가하는 선에서 끝이다.

하지만 검사 예외가 단 하나뿐이라면 그 예외 때문에 try 블록을 추가해야 하고 스트림에서 직접 사용하지 못하게 된다.

이런 상황이라면 검사 예외를 안 던지는 방법이 없는지 고민해볼 가치가 있다.

<br>

검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다.

- 검사 예외를 던지는 대신 단순히 빈 옵셔널만 반환하면 된다.
- 이 방식의 단점이라면 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다는 것이다.

<br>

또 다른 방법으로, 검사 예외를 던지는 메소드를 2개로 쪼개 비검사 예외로 바꿀 수 있다.

```java
try {
    obj.action(args);
} catch(TheCheckedException e) {
    ...
}
```

아래와 같이 리팩토링 할 수 있다.

```java
if(obj.actionPermitted(args)) {
    obj.action(args);
} else{
    ...
}
```

<br>

**정리**

꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안정성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다.

API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.

복구 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자.

옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.

## 72. 표준 예외를 사용하라

표준 예외를 재사용하면 얻는 게 많다. 그중 최고는 API가 다른 사람이 익히고 사용하기 쉬워진다는 것이다. 많은 프로그래머에게 이미 익숙해진 규약을 그대로 따르기 때문이다.

또한 예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸린다.

<br>

Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자.

이 클래스들은 추상 클래스라고 생각하자. 이 예외들은 다른 예외들의 상위 클래스이므로, 즉 여러 성격의 예외들을 포괄하는 클래스이므로 안정적으로 테스트할 수 없다.

<br>

덱에 남아 있는 카드 수보다 큰 값을 건네면 어떤 예외를 던져야 할까?

인수 값이 무엇이었든 어차피 실패했을 거라면 IllegalStateException, 그렇지 않으면 IllegalArgumentException을 던지자.

## 73. 추상화 수준에 맞는 예외를 던지라

수행하려는 일과 관련 없어 보이는 예외가 튀어나오면 당황스러울 것이다.

메소드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 때 종종 일어나는 일이다.

이는 내부 구현 방식을 드러내어 윗 레벨 API를 오염시킨다. 다음 릴리스에서 구현 방식을 바꾸면 다른 예외가 튀어나와 기존 클라이언트 프로그램을 깨지게 할 수도 있다.

<br>

이 문제를 피하려면 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다.

```java
public E get(int index) {
    ListIterator<E> i = listIterator(index);
    try {
        return i.next();
    } catch(NoSuchElementException e) {
        throw new IndexOutOfBoundsException();
    }
}
```

저수준 예외가 디버깅에 도움이 된다면 예외 연쇄를 사용하는 게 좋다.

```java
try{
    ...
} catch(LowerLevelException cause) {
    throw new HigherLevelException(cuase);
}
```

<br>

무턱대고 예외를 전파하는 것보다야 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 안된다.

가능하다면 저수준 메소드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.

## 74. 메소드가 던지는 모든 예외를 문서화하라

메소드가 던지는 예외는 그 메소드를 올바로 사용하는 데 아주 중요한 정보다.

따라서 각 메소드가 던지는 예외 하나하나를 문서화하는 데 충분한 시간을 쏟아야 한다.

<br>

메소드가 던질수 있는 예외를 @throws 태그로 문서화하되, 비검사 예외는 메소드 선언의 throws 목록에 넣지 말자.

검사냐 비검사냐에 따라 API 사용자가 해야 할 일이 달라지므로 이 둘을 확실히 구분해주는 게 좋다.

자바독 유틸리티는 메소드 선언의 throws 절에 등장하고 메소드 주석의 @throws 태그에도 명시한 예외와 @throws 태그에만 명시한 예외를 시각적으로 구분해준다.