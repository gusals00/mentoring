# 모든 객체의 공통 메소드

## 10. equals는 일반 규약을 지켜 재정의하라

equals 메소드는 재정의하기 쉬워 보이지만 곳곳에 함정이 도사리고 있어서 자칫하면 끔찍한 결과를 초래한다.

<br>

문제를 회피하는 가장 쉬운 길은 아예 재정의하지 않는 것이다. 그냥 두면 그 클래스의 인스턴스는 오직 자기 자신과만 같게 된다.

**다음과 상황 중 하나에 해당한다면 재정의하지 않는 것이 최선이다.**

- 각 인스턴스가 본질적으로 고유하다.
  - 값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스 ex) Thread
- 인스턴스의 논리적 동치성을 검사할 일이 없다.
  - Pattern은 equals를 재정의해서 두 Pattern의 인스턴스가 같은 정규표현식을 나타내는지 검사할 수 있지만, 그럴 일이 없다면 굳이 재정의할 필요가 없다.
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
- 클래스가 private 이거나 package-private이고 equals 메소드를 호출할 일이 없다.

**그렇다면 equals를 재정의해야 할 때는 언제일까?**

- 객체 식별성(두 객체가 물리적으로 같은가)이 아니라 논리적 동치성을 확인해야 할 때 재정의한다.
- 주로 값 클래스들이 여기 해당한다. 값 클래스란 Integer와 String처럼 값을 표현하는 클래스를 말한다.
  - 값 클래스라고 해도 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장한다면 재정의하지 않아도 된다. Enum도 여기 해당한다.

**equals 메소드를 재정의할 때는 반드시 일반 규약을 따라야 한다.**

equals 메소드는 동치관계(집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산)를 구현하며, 다음을 만족한다.

null이 아닌 모든 참조 값 x, y, z 에 대해

- 반사성
  - x.equals(x) 는 true다.
- 대칭성
  - x.equals(y)가 true면 y.equals(x)도 true다.
- 추이성
  - x.equals(y)가 true이고 y.equals(z)도 true이면 x.equals(z)도 true다.
  - 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다. 상속 대신 컴포지션을 사용하자.
- 일관성
  - x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
  - equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다.
- null-아님
  - x.equals(null)은 false다

이 규약을 어기면 프로그램이 이상하게 동작하거나 종료될 것이고, 원인이 되는 코드를 찾기도 굉장히 어려울 것이다.

한 클래스의 인스턴스는 다른 곳으로 빈번히 전달된다. 그리고 수 많은 클래스는 전달받은 객체가 equals 규약을 지킨다고 가정하고 동작한다.

지금까지 내용을 종합해서 equals 메소드 구현 방법을 단계별로 정리해보자.

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.
3. 입력을 올바른 타입으로 형변환한다.
4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사한다.

float과 double을 제외한 기본 타입 필드는 == 연산자로 비교하고, 참조 타입 필드는 각각의 equals 메소드로, float과 double 필드는 각각 정적 메소드인 Float.compare, Double.compare로 비교한다.

때로는 null도 정상 값으로 취급하는 참조 타입 필드도 있다. 이런 필드는 정적 메소드인 Object.equals로 비교해 NullpointerException을 예방하자.

<br>

꼭 필요한 경우가 아니면 equals를 재정의하지 말자.

많은 경우에 Object의 equals가 여러분이 원하는 비교를 정확히 수행해준다.

재정의해야 할 때는 그 클래스의 핵심 필드 모두를 빠짐없이, 다섯 가지 규약을 확실히 지켜가며 비교해야 한다.

## 11. equals를 재정의하려거든 hashCode도 재정의하라

equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다.

그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.

아래는 Object 명세에서 발췌한 규약이다.

- equals 비교에 사용되는 정보가 변경되지 않았다면 애플리케이션이 실행되는 동안 그 객체의 hashCode 메소드는 몇 번을 호출해도 항상 같은 값을 반환해야 한다.
- equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
- equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.

<br>

hashCode 재정의를 잘못했을 때 크게 문제가 되는 조항은 두 번째다. 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.

```java
Map<PhoneNumber, String> m = new HashMap<>();
m.put(new PhoneNumber(707, 867, 5309), "제니");
```

위 코드 다음에 `m.get(new PhoneNumber(707, 867, 5309))`을 실행하면 “제니”가 나와야 할 것 같지만 실제로는 null을 반환한다.

hashCode를 재정의하지 않았기 때문에 논리적 동치인 두 객체가 서로 다른 해시코드를 반환하여 두 번째 규약을 지키지 못한다.

<br>

이 문제는 PhoneNumber에 적절한 hashCode 메소드만 작성해주면 해결된다.

```java
@Override
public int hashCode() {
		return 42;
}
```

위 코드는 모든 객체에게 똑같은 값만 내어주므로 모든 객체가 해시테이블의 버킷 하나에 담겨 연결 리스트처럼 동작한다.

그 결과 평균 수행 시간이 O(1)인 해시 테이블이 O(n)으로 느려지게 된다.

<br>

좋은 해시 함수라면 서로 다른 인스턴스에 대해 다른 해시코드를 반환한다. 다음은 좋은 hashCode를 작성하는 요령이다.

1. int 변수 result를 선언한 후 값 c로 초기화한다. 이때 c는 해당 객체의 첫 번째 핵심 필드를 단계 2.1 방식으로 계산한 해시코드다.
2. 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행한다.
   1. 해당 필드의 해시코드 c를 계산한다.
       1. 기본 타입 필드라면, Type.hashCode(f)를 수행한다.
       2. 참조 타입 필드면서 이 클래스의 equals 메소드가 이 필드의 equals를 재귀적으로 호출해 비교한다면, 이 필드의 hashCode를 재귀적으로 호출한다. 계산이 복잡해질 것 같으면 이 필드의 표준형을 만들어 그 표준형의 hashCode를 호출한다.
       3. 필드가 배열이라면, 핵심 원소 각각을 별도 필드처럼 다룬다. 모든 원소가 핵심 원소라면 Arrays.hashCode를 사용한다.
   2. 2.1에서 계산한 해시코드 c로 result를 갱신한다. `result = 31 * result + c`
3. result를 반환한다.

<br>

단계 2.b의 곱셈 31 * result는 필드를 곱하는 순서에 따라 result 값이 달라지게 한다. 그 결과 클래스에 비슷한 필드가 여러 개일 때 해시 효과를 크게 높여준다.

곱할 숫자를 31로 정한 이유는 31이 홀수이면서 소수이기 때문이다. 31을 이용하면 이 곱셈을 시프트 연산과 뺄셈으로 대체해 최적화할 수 있다. 31 * i는 (i << 5) - i와 같다.

<br>

성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안 된다. 속도야 빨라지겠지만, 해시 품질이 나빠져 해시테이블의 성능을 심각하게 떨어뜨릴 수도 있다.

hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자. 그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후에 계산 방식을 바꿀 수도 있다.

## 12. toString을 항상 재정의하라

Object의 기본 toString 메소드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.

이 메소드는 `클래스_이름@16진수로_표시한_해시코드` 를 반환할 뿐이다.

toString의 일반 규약에 따르면 간결하면서 사람이 읽기 쉬운 형태의 유익한 정보를 반환해야 한다.

<br>

toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.

실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다. 하지만 객체가 거대하거나 객체의 상태가 문자열로 표현하기에 적합하지 않다면 “맨해튼 거주자 전화번호부(총 14544321개)” 같은 요약정보를 담아야 한다.

<br>

toString을 구현할 때면 반환값의 포맷을 문서화할지 정해야 한다.

전화번호나 행렬 같은 값 클래스라면 문서화하기를 권한다. 포맷을 명시하면 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다.

포맷을 명시하기로 했다면, 명시한 포맷에 맞는 문자열과 객체를 상호 전환할 수 있는 정적 팩토리나 생성자를 함께 제공해주면 좋다.

단점도 있다.

- 포맷을 한번 명시하면 (그 클래스가 많이 쓰인다면) 평생 그 포맷에 얽매이게 된다. 만약 향후 릴리스에서 포맷을 바꾼다면 이를 사용하던 코드들과 데이터들은 엉망이 될 것이다.

<br>

포맷 명시 여부와 상관없이 toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자. 그렇지 않으면 이 정보가 필요한 프로그래머는 toString의 반환값을 파싱할 수밖에 없다. 성능이 나빠지고 필요하지도 않은 작업이다. 게다가 향후 포맷을 바꾸면 시스템이 망가지는 결과를 초래할 수 있다.

<br>

정적 유틸리티 클래스는 toString을 제공할 이유가 없다. 또한, 대부분의 열거 타입도 자바가 이미 완벽한 toString을 제공하니 따로 재정의하지 않아도 된다.

## 13. clone 재정의는 주의해서 진행하라

Cloneable 인터페이스는 아쉽게도 의도한 목적을 제대로 이루지 못했다.

가장 큰 문제는 clone 메소드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라는 데 있다.

그래서 Cloneable을 구현하는 것만으로는 외부 객체에서 clone 메소드를 호출할 수 없다.

<br>

메소드 하나 없는 Cloneable 인터페이스는 무슨 일을 할까?

- Object의 protected 메소드인 clone의 동작 방식을 결정한다.
- Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면 CloneNotSupportedException을 던진다.

Cloneable을 구현하는 모든 클래스는 clone을 재정의해야 한다.

이때 접근 제한자는 public으로, 반환 타입은 클래스 자신으로 변경한다.

이 메소드는 가장 먼저 super.clone을 호출한 후 필요한 필드를 전부 적절히 수정한다.(깊은 복사)

<br>

그런데 이 모든 작업이 꼭 필요한 걸까? 다행히도 이처럼 복잡한 경우는 드물다.

Cloneable을 이미 구현한 클래스를 확장한다면 어쩔 수 없이 clone을 잘 작동하도록 구현해야 한다.

그렇지 않은 상황에서는 **복사 생성자와 복사 팩토리라는 더 나은 객체 복사 방식을 제공할 수 있다.**

<br>

복사 생성자 / 복사 팩토리

```java
// 복사 생성자
public Yum(Yum yum) {...};

// 복사 팩토리
public static Yum newInstance(Yum yum) {...};
```

복사 생성자와 그 변형인 복사 팩토리는 CLoneable/clone 방식보다 나은 면이 많다.

- 언어 모순적이고 위험천만한 객체 생성 메커니즘(생성자를 쓰지 않는 방식)을 사용하지 않으며, 어성하게 문서화된 규약에 기대지 않고, 정상적인 final 필드 용법과도 충돌하지 않으며, 불필요한 검사 예외를 던지지 않고, 형변환도 필요치 않다.
- 해당 클래스가 구현한 인터페이스 타입의 인스턴스를 인수로 받을 수 있다.
  - ex) HashSet 객체 s를 TreeSet 타입으로 복제할 수 있다. `new TreeSet<>(s)`

## 14. Comparable을 구현할지 고려하라

순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여, 그 인스턴스들을 쉽게 정렬하고, 검색하고, 비교 기능을 제공하는 컬렉션과 어우러지도록 해야 한다.

<br>

compareTo 메소드로 수행한 동치성 테스트의 결과가 equals와 같게 하는 것이 좋다. 이를 잘 지키면 compareTo로 줄지은 순서와 equals의 결과가 일관되게 된다.

- compareTo의 순서와 equals의 결과가 일관되지 않은 클래스도 동작은 하지만, 이 클래스의 객체를 정렬된 컬렉션에 넣으면 해당 컬렉션이 구현한 인터페이스(Collection, Set, Map)에 정의된 동작과 엇박자를 낼 것이다.
  - 이 인터페이스들은 equals 메소드의 규약을 따른다고 되어 있지만, 정렬된 컬렉션들은 동치성을 비교할 때 equals 대신 compareTo를 사용하기 때문이다.
  - ex) 빈 HashSet 인스턴스를 생성하고 `new BigDecimal(”1.0”), new BigDecimal(”1.00”)`을 차례로 추가하면, 이 두 BigDecimal은 equals 메소드로 비교하면 서로 다르기 때문에 HashSet은 원소를 2개 갖게 된다.
    하지만 HashSet대신 TreeSet(정렬된 컬렉션)을 사용하면 원소를 하나만 갖게 된다. compareTo로 비교하면 두 BigDecimal 인스턴스가 똑같기 때문이다.

Comparable을 구현하지 않은 필드나 표준이 아닌 순서로 비교해야 한다면 비교자(Comparator)를 대신 사용한다.

비교자는 직접 만들거나 자바가 제공하는 것 중에 골라 쓰면 된다.

<br>

compareTo 메소드에서 필드의 값을 비교할 때 <와 > 연산자는 쓰지 말아야 한다. 그 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare 메소드나 Comparator 인터페이스가 제공하는 비교자 생성 메소드를 사용하자.

```java
// 정적 compare 메소드
new Comparator<>() {
		public int compare(Object o1, Object o2) {
				return Integer.compare(o1.hashCode(), o2.hashCode());
		}
};

// 비교자 생성 메소드를 활용한 비교자
Comparator.comparingInt(o -> o.hashCode()); 
```