# 직렬화

## 85. 자바 직렬화의 대안을 찾으라

직렬화의 근본적인 문제는 공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다는 점이다.

ObjectInputStream의 readObject 메소드를 호출하면서 객체 그래프가 역직렬화되기 때문이다. readObject 메소드는(Serializable 인터페이스를 구현했다면) 클래스패스 안의 거의 모든 타입의 객체를 만들어낼 수 잇는, 사실상 마법 같은 생성자다.

바이트 스트림을 역직렬화하는 과정에서 이 메소드는 그 타입들 안의 모든 코드를 수행할 수 있다. 그 타입들의 코드 전체가 공격 범위에 들어간다는 뜻이다.

<br>

역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메소드들을 가젯(gadget)이라고 부른다.

여러 가젯을 함께 사용하여 가젯 체인을 구성할 수도 있는데, 가끔씩 공격자가 기반 하드웨어의 네이티브 코드를 마음대로 실행할 수 있는 강력한 가젯 체인도 발견되곤 한다.

그래서 아주 신중하게 제작한 바이트 스트림만 역직렬화해야 한다.

<br>

가젯까지 갈 것도 없이, 역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화하는 것만으로 서비스 거부 공격에 쉽게 노출될 수 있다.

이런 스트림을 역직렬화 폭탄(deserialization bomb)라고 한다.

<br>

그렇다면 이런 문제들을 어떻게 대처해야 할까? 신뢰할 수 없는 바이트 스트림을 역직렬화하는 일 자체가 스스로를 공격에 노출하는 행위다.

**따라서 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.**

<br>

객체와 바이트 시퀀스를 변환해주는 다른 메커니즘에는 JSON과 프로토콜 버퍼 등이 있다.

JSON은 텍스트 기반이라 사람이 읽을 수 있고, 프로토콜 버퍼는 이진 표현이라 효율이 훨씬 높다. 또한 JSON은 오직 데이터를 표현하는 데만 쓰이지만, 프로토콜 버퍼는 문서를 위한 스키마(타입)를 제공하고 올바로 쓰도록 강요한다.

## 86. Serializable을 구현할지는 신중히 결정하라

Serialzable을 구현하면 릴리스한 뒤에는 수정하기 어렵다. 클래스가 Serializable을 구현하면 직렬화된 바이트 스트림 인코딩(직렬화 형태)도 하나의 공개 API가 된다.

<br>

커스텀 직렬화 형태를 설계하지 않고 자바의 기본 방식을 사용하면 직렬화 형태는 최소 적용 당시 클래스의 내부 구현 방식에 영원히 묶여버린다.

달리 말하면, 기본 직렬화 상태에서는 클래스의 private과 package-private 인스턴스 필드들마저 API로 공개하는 꼴이 된다(캡슐화가 깨진다).

<br>

직렬화가 클래스 개선을 방해하는 예

1. 스트림 고유 식별자
  - serialVersionUID라는 이름의 static final long 필드로, 이 번호를 명시하지 않으면 시스템이 런타임에 암호 해시 함수(SHA-1)를 적용해 자동으로 클래스 안에 생성해 넣는다.
  - 이 값을 생성하는 데는 클래스 이름, 구현한 인터페이스들 등 대부분의 클래스 멤버들이 고려된다.
  - 자동 생성되는 값에 의존하면 쉽게 호환성이 깨져버려 런타임에 예외가 발생할 것이다.
2. 버그와 보안 구멍이 생길 위험이 높아 진다.
  - 기본 역직렬화를 사용하면 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출된다.
3. 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다.
  - 직렬화 가능 클래스가 수정되면 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화할 수 있는지, 그리고 그 반대도 가능한지를 검사해야 한다.

<br>

상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안 되며, 인터페이스도 대부분 Serializable을 확장해서는 안 된다.

이 규칙을 따르지 않으면, 그런 클래스를 확장하거나 그런 인터페이스를 구현하는 이에게 커다란 부담을 지우게 된다.

## 87. 커스텀 직렬화 형태를 고려해보라

객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.

<br>

객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하면 크게 네 가지 면에서 문제가 생긴다.

1. 공개 API가 현재의 내부 표현 방식에 영구히 묶인다.
2. 너무 많은 공간을 차지할 수 있다.
3. 시간이 너무 많이 걸릴 수 있다.
4. 스택 오버플로를 일으킬 수 있다.

<br>

transient 한정자는 해당 인스턴스 필드가 기본 직렬화 형태에 포함되지 않는다는 표시다.

해당 객체의 논리적 상태와 무관한 필드라고 확실할 때만 transient 한정자를 생략해야 한다.

<br>

어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자.

- 이렇게 하면 직렬 버전 UID가 일으키는 잠재적인 호환성 문제가 사라진다.
- 성능도 조금 빨라진다. 런타임에 이 값을 생성하느라 복잡한 연산을 수행하지 않아도 되기 때문.

## 88. readObject 메소드는 방어적으로 작성하라

readObject 메소드가 실실적으로 또 다른 public 생성자이기 때문에 다른 생성자와 똑같은 수준으로 주의를 기울여야 한다.

보통의 생성자처럼 readObject 메소드에서도 인수가 유효한지 검사해야 하고 필요하다면 매개변수를 방어적으로 복사해야 한다.

readObject가 이 작업을 제대로 수행하지 못하면 공격자는 아주 손쉽게 해당 클래스의 불변식을 깨뜨릴 수 있다.

<br>

안전한 readObject 메소드를 작성하는 지침은 다음과 같다.

- private이어야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사하라.
  - 불변 클래스 내의 가변 요소가 여기 속한다.
- 모든 불변식을 검사하여 어긋나는 게 발견되면 InvalidObjectException을 던진다. 방어적 복사 다음에는 반드시 불변식 검사가 뒤따라야 한다.
- 역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면 ObjectInputValidation 인터페이스를 사용하라.
- 직접적이든 간접적이든, 재정의할 수 있는 메소드는 호출하지 말자.

## 89. 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라

싱글톤 클래스도 implements Serializable을 추가하는 순간 더 이상 싱글톤이 아니게 된다.

readResolve 기능을 이용하면 readObject가 만들어낸 인스턴스를 다른 것으로 대체할 수 잇다.

역직렬화한 객체의 클래스가 readResolve 메소드를 적절히 정의해뒀다면, 역직렬화 후 새로 생성된 객체를 인수로 이 메소드가 호출되고, 이 메소드가 반환한 객체 참조가 새로 생성된 객체를 대신해 반환된다.

<br>

readResolve를 인스턴스 통제 목적으로 사용한다면 객체 참조 타입 인스턴스 필드는 모두 transient로 선언해야 한다.

그렇지 않으면 readResolve 메소드가 수행되기 전에 역직렬화된 객체의 참조를 공격할 여지가 남는다.

<br>

직렬화 가능한 인스턴스 통제 클래스를 열거 타입을 이용해 구현하면 선언한 상수 외의 다른 객체는 존재하지 않음을 자바가 보장해준다.

인스턴스 통제를 위해 readResolve를 사용하는 방식이 완전히 쓸모없는 것은 아니다. 직렬화 가능 인스턴스 통제 클래스를 작성해야 하는데, 컴파일타임에는 어떤 인스턴스들이 있는지 알 수 없는 상황이라면 열거 타입으로 표현하는 것이 불가능하기 때문이다.

<br>

**정리**

불변식을 지키기 위해 인스턴스를 통제해야 한다면 가능한 한 열거타입을 사용하자.

여의치 않은 상황에서 직렬화와 인스턴스 통제가 모두 필요하다면 readResolve 메소드를 작성해 넣어야 하고, 그 클래스에서 모든 참조 타입 인스턴스 필드를 transient로 선언해야 한다.

## 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라

Serializable을 구현하기로 결정한 순간 언어의 정상 메커니즘인 생성자 이외의 방법으로 인스턴스를 생성할 수 있게 된다.

이 위험을 크게 줄여줄 기법이 하나 있다. 바로 직렬화 프록시 패턴이다.

<br>

직렬화 프록시 패턴

- 먼저, 바깥 클래스의 논리적 상태를 정밀하게 표현하는 중첩 클래스를 private static으로 선언한다. 이 중첩 클래스가 바로 바깥 클래스의 직렬화 프록시다.
- 중첩 클래스의 생성자는 단 하나여야 하며, 바깥 클래스를 매개변수로 받아야 한다. 이 생성자는 단순히 인수로 넘어온 인스턴스의 데이터를 복사한다.
- 그리고 바깥 클래스와 직렬화 프록시 모두 Serializable을 구현한다고 선언해야 한다.

<br>

제3자가 확장할 수 없는 클래스라면 가능한 한 직렬화 프록시 패턴을 사용하자.