# 일반적인 프로그래밍 원칙

## 57. 지역변수의 범위를 최소화하라

지역변수의 유효 범위를 최소로 줄이면 **코드 가독성과 유지보수성**이 높아지고 오류 가능성은 낮아진다.

<br>

지역변수의 범위를 줄이는 가장 강력한 기법은 ‘가장 처음 쓰일 때 선언하기’다.

- 사용하려면 멀었는데 미리 선언부터 해두면 가독성이 떨어진다. 변수를 실제로 사용하는 시점엔 타입과 초깃값이 기억나지 않을 수도 있다.
- 지역 변수를 생각 없이 선언하다 보면 변수가 쓰이는 범위보다 너무 앞서 선언하거나, 다 쓴 뒤에도 여전히 살아 있게 되기 쉽다.

<br>

거의 모든 지역변수는 선언과 동시에 초기화해야 한다. 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야 한다.

- try-catch문은 이 규칙에서 예외다.
    - 변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 try 블록 안에서 초기화해야 한다.
    - 변수 값을 try 블록 바깥에서도 사용해야 한다면 try 블록 앞에서 선언해야 한다.

<br>

메소드를 작게 유지하고 한 가지 기능에 집중하자.

- 한 메소드에서 여러 가지 기능을 처리한다면 그중 한 기능과만 관련된 지역변수라도 다른 기능을 수행하는 코드에서 접근할 수 있을 것이다.
    - 단순히 메소드를 기능별로 쪼개면 된다.

## 58. 전통적인 for문보다는 for-each문을 사용하라

for-each문은 반복자와 인덱스 변수를 사용하지 않으니 코드가 깔끔해지고 오류가 날 일도 없다.

하나의 관용구로 컬렉션과 배열을 모두 처리할 수 있어서 어떤 컨테이너를 다루는지는 신경쓰지 않아도 된다.

<br>

하지만 안타깝게도 for-each문을 사용할 수 없는 상황이 존재한다.

- 파괴적인 필터링
    - 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메소드를 호출해야 한다.
    - 자바 8부터는 Collection의 removeIf 메소드를 통해 컬렉션을 명시적으로 순회하는 일을 피할 수 있음.
- 변형
    - 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 한다.
- 병렬 반복
    - 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.

<br>

for-each 문은 컬렉션과 배열은 물론 Iterable 인터페이스를 구현한 객체라면 무엇이든 순회할 수 있다.

## 59. 라이브러리를 익히고 사용하라

표준 라이브러리를 사용하는 것의 이점

- 그 코드를 작성한 전문가의 지식과 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.
- 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다.
- 따로 노력하지 않아도 성능이 지속해서 개선된다.
- 기능이 점점 많아진다.
- 작성한 코드가 많은 사람에게 낯익은 코드가 된다. 자연스럽게 다른 개발자들이 더 읽기 좋고, 유지보수하기 좋고, 재활용하기 쉬운 코드가 된다.

<br>

메이저 릴리스마다 주목할 만한 수많은 기능이 라이브러리에 추가된다.

자바 프로그래머라면 적어도 java.lang, java.util, java.io와 그 하위 패키지들에는 익숙해져야 한다.

## 60. 정확한 답이 필요하다면 float와 double은 피하라

float와 double 타입은 과학과 공학 게산용으로 설계되었다. 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 근사치로 계산하도록 세심하게 설계되었다.

따라서 정확한 결과가 필요할 때는 사용하면 안 된다. 특히 금융 관련 계산과는 맞지 않는다.

금융 계산에는 BigDecimal, int 혹은 long을 사용해야 한다.

<br>

하지만 BigDecimal은 기본 타입보다 쓰기가 훨씬 불편하고, 훨씬 느리다.

BigDecimal의 대안으로 int 혹은 long 타입을 쓸 수도 있다. 그럴 경우 다룰 수 있는 값의 크기가 제한되고, 소수점을 직접 관리해야 한다.

<br>

**정리**

정확한 답이 필요한 계산에는 float나 double을 피하라.

소수점 추적은 시스템에 맡기고, 코딩 시의 불편함이나 성능 저하를 신경 쓰지 않겠다면 BigDecimal을 사용하라.

BigDecimal이 제공하는 여덟 가지 반올림 모드를 이용하여 반올림을 완벽히 제어 할 수 있다.

반면, 성능이 중요하고 소수점을 직접 추적할 수 있고 숫자가 너무 크지 않다면 int 나 long을 사용하라.

## 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

각각의 기본 타입에는 대응하는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다.

int, double, boolean에 대응하는 박싱된 기본 타입은 Integer, Double, Boolean이다.

<br>

오토방식과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수는 있지만, 차이가 사라지는 것은 아니다.

기본 타입과 박싱된 기본 타입의 주된 차이는 크게 세 가지다.

1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖는다.
    - 달리 말해 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.
2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null을 가질 수 있다.
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

<br>

기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.

그렇다면 박싱된 기본 타입은 언제 써야 하는가?

- 컬렉션의 원소, 키, 값으로 쓴다. 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야만 한다.
    - 자바 언어가 타입 매개변수로 기본 타입을 지원하지 않기 때문이다.
- 리플렉션을 통해 메소드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.

## 62. 다른 타입이 적절하다면 문자열 사용을 피하라

문자열(String)은 텍스트를 표현하도록 설계되었다. 그런데 문자열은 워낙 흔하고 자바가 잘 지원해주어 원래 의도하지 않은 용도로 쓰이는 경향이 있다.

<br>

1. 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
    - 많은 사람이 파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때 주로 문자열을 사용한다. 하지만 입력받을 데이터가 진짜 문자열일때만 그렇게 하는 게 좋다.
    - 기본 타입이든 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고, 없다면 새로 하나 작성하라.
2. 문자열은 열거 타입을 대신하기에 적합하지 않다.
    - 상수를 열거할 때는 문자열보다는 열거 타입이 월등히 낫다.
3. 문자열은 혼합 타입을 대신하기에 적합하지 않다.
    - 여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않은 생각이다.
4. 문자열은 권한을 표현하기에 적합하지 않다.
    - 문자열 대신 위조할 수 없는 키를 사용하라.
    - 만약 두 클라이언트가 같은 키를 사용한다면 의도치 않게 같은 변수를 공유하게 되고, 결국 두 클라이언트 모두 제대로 기능하지 못하게 된다.
    - 보안에도 취약하다. 악의적인 클라이언트라면 의도적으로 같은 키를 사용하여 다른 클라이언트의 값을 가져올 수도 있다.

<br>

**정리**

더 적합한 데이터 타입이 있거나 새로 작성할 수 있다면, 문자열을 쓰고 싶은 유혹을 뿌리쳐라.

문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고, 오류 가능성도 크다.

## 63. 문자열 연결은 느리니 주의하라

문자열 연결 연산자(+)는 여러 문자열을 하나로 합쳐주는 편리한 수단이다.

하지만 문자열 연결 연산자로 문자열 n개를 잇는 시간은 n^2에 비례한다. 문자열은 불변이라서 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하므로 성능 저하는 피할 수 없는 결과다.

<br>

성능을 포기하고 싶지 않다면 String 대신 StringBuilder를 사용하자.

## 64. 객체는 인터페이스를 사용해 참조하라

적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.

인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.

나중에 구현 클래스를 교체하고자 한다면 그저 새 클래스의 생성자(혹은 다른 정적 팩토리)를 호출해주기만 하면 된다.

<br>

단, 원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하며, 주변 코드가 이 기능에 기대어 동작한다면 새로운 클래스도 반드시 같은 기능을 제공해야 한다.

- 예를 들어 첫 번째 선언의 주변 코드가 LinkedHashSet이 따르는 순서 정책을 가정하고 동작하는 상황에서 이를 HashSet으로 바꾸면 문제가 될 수 있다.

<br>

적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의) 클래스를 타입으로 사용하자.

## 65. 리플렉션보다는 인터페이스를 사용하라

리플렉션 기능을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.

Class 객체가 주어지면 그 클래스의 생성자, 메소드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있고, 이어서 이 인스턴스들로는 그 클래스의 멤버 이름, 필드 타입, 메소드 시그니처 등을 가져올 수 있다.

나아가 Constructor, Method, Field 인스턴스를 이용해 각각에 연결된 실제 생성자, 메소드, 필드를 조작할 수도 있다.

<br>

리플렉션을 이용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있는데, 물론 단점이 있다.

- 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다.
- 리플렉션을 이용하면 코드가 지저분하고 장황해진다.
- 성능이 떨어진다.

<br>

리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할 수 있다.

- 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자.

## 66. 네이티브 메소드는 신중히 사용하라

자바 네이티브 인터페이스(JNI)는 자바 프로그램이 네이티브 메소드를 호출하는 기술이다.

네이티브 메소드란 C나 C++ 같은 네이티브 프로그래밍 언어로 작성한 메소드를 말한다.

<br>

네이티브 메소드의 메소드의 주요 쓰임은 다음 세 가지다.

1. 레지스트리 같은 플랫폼 특화 기능을 사용한다.
2. 네이티브 코드로 작성된 기존 라이브러리를 사용한다.
3. 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.

<br>

성능을 개선할 목적으로 네이티브 메소드를 사용하는 것은 거의 권장하지 않는다.

JVM은 그동안 엄청난 속도로 발전해왔다. 대부분 작업에서 지금의 자바는 다른 플랫폼에 견줄만한 성능을 보인다.

## 67. 최적화는 신중히 하라

최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고, 섣불리 진행하면 특히 더 그렇다.

성능 때문에 견고한 구조를 희생하지 말자. 빠른 프로그램보다는 좋은 프로그램을 작성하라.

좋은 프로그램이지만 원하는 성능이 나오지 않는다면 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것이다.

좋은 프로그램은 정보 은닉 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있다. 따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다.

<br>

구현상의 문제는 나중에 최적화해 해결할 수 있지만, 아키텍처의 결함이 성능을 제한하는 상황이라면 시스템 전체를 다시 작성하지 않고는 해결하기 불가능할 수 있다.

완성된 설계의 기본 틀을 변경하려다 보면 유지보수하거나 개선하기 어려운 꼬인 구조의 시스템이 만들어지기 쉽기 때문이다. 따라서 설계 단계에서 성능을 반드시 염두에 두어야 한다.

<br>

**정리**

빠른 프로그램을 작성하려 안달하지 말자. 좋은 프로그램을 작성하다 보면 성능은 따라오기 마련이다.

하지만 시스템을 설계할 때, 특히 API, 네트워크 프로토콜, 영구 저장용 데이터 포맷을 설계할 때는 성능을 염두에 두어야 한다.

시스템 구현을 완료했다면 성능을 측정해보자. 느리다면 프로파일러를 사용해 문제의 원인이 되는 지점을 찾아 최적화를 수행하라.