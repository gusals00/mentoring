# 람다와 스트림

## 42. 익명 클래스보다는 람다를 사용하라

자바에서 함수 타입을 표현할 때 추상 메소드를 하나만 담은 인터페이스를 사용했다. 이런 인터페이스의 인스턴스를 함수 객체라고 하여, 특정 함수나 동작을 나타내는 데 썻다.

익명 클래스 방식은 코드가 너무 길기 때문에 자바는 함수형 프로그래밍에 적합하지 않았다.

<br>

자바8부터는 추상 메소드 하나짜리 인터페이스는 함수형 인터페이스라는 특별한 대우를 받게 되었다. 그리고 함수형 인터페이스의 인스턴스를 람다식을 사용해 만들 수 있게 되었다.

람다식을 사용하면 컴파일러가 문맥을 살펴 타입을 추론해주기 때문에 매개변수 타입 등의 정보를 생략함으로써 코드가 훨씬 간결해진다.

<br>

하지만 람다가 무조건 좋은 건 아니다.

- 람다는 이름이 없고 문서화도 못 한다. 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.
- 람다는 함수형 인터페이스에서만 쓰인다. 예컨대 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니, 익명 클래스를 써야 한다.
- 추상 메소드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명 클래스를 쓸 수 있다.
- 람다는 자신을 참조할 수 없다. 따라서 함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 써야 한다.
  - 람다에서는 this 키워드는 바깥 인스턴스를 가리킨다. 반면 익명 클래스에서의 this는 익명 클래스의 인스턴스 자신을 가리킨다.

<br>

**정리**

익명 클래스는 함수형 인터페이스가 아닌 타입의 인스턴스를 만들 때만 사용하라.

## 43. 람다보다는 메소드 참조를 사용하라

람다가 익명클래스보다 나은 점 중에서 가장 큰 특징은 간결함이다.

그런데 자바에서는 **메소드 참조**를 이용하면 함수 객체를 람다보다도 더 간결하게 만들 수 있다.

<br>

메소드 참조는 매개 변수들까지도 생략할 수 있어 매개변수 수가 늘어날수록 메소드 참조로 제거할 수 있는 코드양도 늘어난다.

하지만 어떤 람다에서는 매개변수의 이름 자체가 프로그래머에게 좋은 가이드가 되기도 한다. 이런 람다는 길이는 더 길지만 메소드 참조보다 읽기 쉽고 유지보수도 쉬울 수 있다.

<br>

때로는 아래와 같이 람다가 메소드 참조보다 간결할 때가 있다. 주로 메소드와 람다가 같은 클래스에 있을 때 그렇다.

```java
service.execute(GoshThisClassNameIsHumongous::action);
service.execute(() -> action());
```

<br>

**정리**

메소드 참조 쪽이 짧고 명확하다면 메소드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하라.

## 44. 표준 함수형 인터페이스를 사용하라

자바가 람다를 지원하면서 API를 작성하는 모범 사례도 크게 바뀌었다. 예를 들어 상위 클래스의 기본 메소드를 재정의해 원하는 동작을 구현하는 템플릿 메소드 패턴의 매력이 크게 줄었다.

이를 대체하는 현대적인 해법은 같은 효과의 함수 객체를 받는 정적 팩토리나 생성자를 제공하는 것이다.

<br>

LinkedHashMap을 생각해보자. 이 클래스의 protected 메소드인 removeEldestEntry를 재정의하면 캐시로 사용할 수 있다.

잘 동작하지만 람다를 사용하면 훨씬 잘 해낼 수 있다. LinkedHashMap를 오늘날 다시 구현한다면 함수 객체를 받는 정적팩토리나 생성자를 제공했을 것이다.

<br>

java.util.function 패키지를 보면 다양한 용도의 표준 함수형 인터페이스가 담겨 있다. 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라.

기본 함수형 인터페이스는 다음과 같다.

- Operator 인터페이스
  - 반환값과 인수의 타입이 같은 함수
  - 인수가 1개인 UnaryOperator, 2개인 BinaryOperator로 나뉨
- Predicate 인터페이스
  - 인수 하나를 받아 boolean을 반환하는 함수
- Function 인터페이스
  - 인수와 반환 타입이 다른 함수
- Supplier 인터페이스
  - 인수를 받지 않고 값을 반환하는 함수
- Consumer 인터페이스
  - 인수를 하나 받고 반환값은 없는(특히 인수를 소비하는) 함수

<br>

표준 함수형 인터페이스 대부분은 기본 타입만 지원한다. 그렇다고 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자. 계산량이 많을 때는 성능이 처참히 느려질 수 있다.

그렇다면 코드를 직접 작성해야 할 때는 언제일까? 이 중 하나 이상을 만족한다면 전용 함수형 인터페이스를 구현해야 하는 건 아닌지 고민해야 한다.

- 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다.
- 반드시 따라야 하는 규약이 있다.
- 유용한 디폴트 메소드를 제공할 수 있다.

<br>

@FunctionalInterface 어노테이션을 사용하는 이유는 다음과 같다.

1. 해당 클래스의 코드나 설명 문서를 읽을 이에게 그 인터페이스가 람다용으로 설계된 것임을 알려준다.
2. 해당 인터페이스가 추상 메소드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
3. 그 결과 유지보수 과정에서 누군가 실수로 메소드를 추가하지 못하게 막아준다.

직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 어노테이션을 사용하라.

## 45. 스트림은 주의해서 사용하라

스트림 API는 다량의 데이터 처리 작업(순차적이든 병렬적이든)을 돕고자 자바 8에 추가되었다.

이 API가 제공하는 추상 개념 중 핵심은 두 가지다.

1. 스트림
  - 데이터 원소의 유한 혹은 무한 시퀀스를 뜻한다.
2. 스트림 파이프라인
  - 이 원소들로 수행하는 연산 단계를 표현하는 개념이다.
  - 소스 스트림에서 시작해 종단 연산으로 끝나며, 그 사이에 하나 이상의 중간 연산이 있을 수 있다.
  - 중간 연산들은 모두 한 스트림을 다른 스트림으로 변환하는데, 변환된 스트림의 원소 타입은 변환 전 스트림의 원소 타입과 같을수도 있고 다를수도 있다.
  - 종단 연산은 마지막 중간 연산이 내놓은 스트림에 최후의 연산을 가한다.
  - 지연 평가 된다.
    - 평가는 종단 연산이 호출될 때 이뤄지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다.
    - 이러한 지연 평가가 무한 스트림을 다룰 수 있게 해주는 열쇠다.

<br>

스트림을 제대로 사용하면 프로그램이 짧고 깔끔해지지만, 잘못 사용하면 읽기 어렵고 유지보수도 힘들어진다.

스트림과 반복문을 적절히 조합하는 게 최선이다. 기존 코드는 스트림을 사용하도록 리팩터링하되, 새 코드가 더 나아 보일 때만 반영하자.

## 46. 스트림에서는 부작용 없는 함수를 사용하라

스트림 패러다임의 핵심은 계산을 일련의 변환으로 재구성 하는 부분이다. 이때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수한 함수여야 한다.

즉, 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않아야 한다는 의미이다.

이렇게 하려면 스트림 연산에 건네는 함수 객체는 모두 부작용이 없어야 한다.

<br>

```java
Map<String, Long> freq = new HashMap<>();
try (Stream<String> words = new Scanner(file).tokens()) {
		words.forEach(word -> {
				freq.merge(word.toLowerCase(), 1L, Long::sum);
		});
}
```

위 코드의 모든 작업은 종단 연산인 forEach에서 일어나는데, 이때 외부 상태를 수정하는 람다를 실행하면서 문제가 생긴다.

forEach가 그저 스트림이 수행한 연산 결과를 보여주는 일 이상을 하는 것(위에서는 람다가 상태를 수정함)을 보니 나쁜 코드일 것 같은 냄새가 난다.

아래는 이를 올바르게 작성한 모습이다.

```java
Map<String, Long> freq;
try (Stream<String> words = new Scanner(file).tokens()) {
		freq = words
				.collect(groupingBy(String::toLowerCase, counting()));
}
```

forEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는 데는 쓰지 말자.

<br>

스트림을 올바로 사용하려면 수집기(collector)를 잘 알아둬야 한다. 가장 중요한 수집기 팩토리는 toList, toSet, toMap, groupingBy, joining이다.

## 47. 반환 타입으로는 스트림보다 컬렉션이 낫다.

스트림은 반복(iteration)을 지원하지 않는다. 따라서 스트림과 반복을 알맞게 조합해야 좋은 코드가 나온다.

API를 스트림만 반환하도록 짜놓으면 스트림을 for-each로 반복하길 원하는 사용자는 당연히 불만을 토로할 것이다.

<br>

Stream 인터페이스는 Iterable 인터페이스가 정의한 추상 메소드를 전부 포함할 뿐만 아니라, Iterable 인터페이스가 정의한 방식대로 동작한다. 그럼에도 for-each로 스트림을 반복할 수 없는 까닭은 바로 Stream이 Iterable을 확장(extend) 하지 않아서다.

<br>

Stream과 Iterable을 같이 사용하려면 다음과 같이 할 수 있다.

```java
for(ProcessHandle ph: (Iterable<ProcessHandle>)ProcessHandle.allProcesses()::iterator){
    // 프로세스를 처리한다.
}
```

작동은 하지만 실전에서 쓰기에는 너무 난잡하고 직관성이 떨어진다.

어댑터 메소드를 사용하면 상황이 나아진다. 자바는 이런 메소드를 제공하지 않지만 다음과 같이 쉽게 만들어낼 수 있다.

```java
public static <E> Iterable<E> iterableOf(Stream<E> stream) {
    return stream::iterator;
}
for(ProcessHandle processHandle : iterableOf(ProcessHandle.allProcesses())) {
    // 프로세스를 처리한다.
}
```

반대로, API가 Iterable만 반환하면 이를 스트림 파이프라인에서 처리하길 원할 수 있다. 이 역시 다음과 같이 구현할 수 있다.

```java
public static <E> Stream<E> streamOf(Iterable<E> iterable) {
    return StreamSupport.stream(iterable.spliterator(), false);
}
```

<br>

하지만 공개 API를 작성할 때는 스트림 파이프라인을 사용하는 사람과 반복문에서 쓰려는 사람 모두를 배려해야 한다.

사용자 대부분이 한 방식만 사용할 거라는 그럴싸한 근거가 없다면 말이다.

따라서 원소 시퀀스를 반환하는 공개 API의 반환 타입에는 Collection이나 그 하위 타입을 쓰는 게 일반적으로 최선이다.

반환 전부터 이미 원소들을 컬렉션에 담아 관리하고 있거나 컬렉션을 하나 더 만들어도 될 정도로 원소 개수가 적다면 ArrayList 같은 표준 컬렉션에 담아 반환하자. 그렇지 않다면 전용 컬렉션을 구현할지 고민하자.

## 48. 스트림 병렬화는 주의해서 적용하라

자바8부터는 parallel 메소드만 한 번 호출하면 파이프라인을 병렬 실행할 수 있는 스트림을 지원했다.

동시성 프로그래밍을 할 때는 안정성(safety)과 응답 가능(liveness) 상태를 유지하기 위해 애써야 한다.

<br>

데이터 소스가 Stream.iterate거나 중간 연산으로 limit을 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.

그 이유는 파이프라인 병렬화가 limit을 다룰 때 CPU 코어가 남는다면 원소를 몇 개 더 처리한 후 제한된 개수 이후의 결과를 버려도 아무런 해가 없다고 가정하기 때문이다. 따라서 주어진 개수의 결과를 모두 얻어도 남은 개수의 처리가 끝날때까지 기다리게 될 수 있게 된다.

<br>

대체로 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int의 범위, long 범위일 때 병렬화의 효과가 가장 좋다.

이 자료구조들은 모두 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어서 일을 다수의 쓰레드에 분배하기에 좋다는 특징이 있다. 나누는 작업은 Spliterator가 담당하며, Stream이나 Iterable의 spliterator 메소드로 얻어올 수 있다.

또한 이 자료구조들은 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있어 참조 지역성이 뛰어나다. 참조 지역성이 나쁘면 쓰레드는 데이터가 주 메모리에서 캐시 메모리로 전송되어 오기를 기다리며 대부분 시간을 멍하니 보내게 된다. 따라서 참조 지역성은 다량의 데이터를 처리하는 벌크 연산을 병렬화할 때 중요한 요소로 작용한다.

<br>

스트림 파이프라인의 종단 연산의 동작 방식 역시 병렬 수행 효율에 영향을 준다. 종단 연산에서 수행하는 작업량이 파이프라인 전체 작업에서 상당 비중을 차리하면서 순차적인 연산이라면 파이프라인 병렬 수행의 효과는 제한될 수밖에 없다.

종단 연산 중 병렬화에 가장 적합한 것은 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업인 축소(reduction)이다. anyMatch 처럼 조건에 맞으면 바라 반환되는 메소드도 병렬화에 적합하다. 반면 collect 메소드는 컬렉션들을 합치는 부담이 커 병렬화에 적합하지 않다.

<br>

스트림을 잘못 병렬화하면 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.

병렬화하는 편이 낫다고 믿더라도, 수정 후의 코드가 여전히 정확한지 확인하고 운영 환경과 유사한 조건에서 수행해보며 성능지표를 유심히 관찰하라.