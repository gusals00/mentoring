# 오브젝트와 의존관계

## 1.1 초난감 DAO

**DAO**

- DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트

**자바빈**

- 디폴트 생성자 :  파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 객체를 생성하기 때문
- 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 말한다. settter와 getter를 이용해 수정 또는 조회 할 수 있다.

**초난감 DAO의 문제**

- 각 메소드 내부에 핵심 로직이 아니라 부가 로직을 적용시켜 중복된 코드가 많다. 따라서 DB의 주소나 드라이버가 바뀌어야 할 때 모든 메소드를 찾아 변경해주어야 한다.
- main 메소드에서 테스트를 하고 있다.

## 1.2 DAO의 분리

**관심사의 분리**

- 객체지향의 세계에서는 모든 것이 변한다. 오브젝트에 대한 설계와 이를 구현한 코드가 변한다는 뜻이다. 사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다. 따라서 객체를 설계할 때 가장 염두에 둬야 할 사항은 **미래의 변화를 어떻게 대비할 것인가이다**.
- 그럼 어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까? **분리와 확장을 고려한 설계**를 해야한다.
- 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 함으로써 변화에 대비할 수 있다.
- 한 관심사가 변경되었을 때, 한 곳만 수정해도 되는 것이 이상적이다. 관심사별로 코드를 분리(결합도를 낮추고)해두고, 관심사에 맞게 모아두는(응집도를 높이고) 것이 좋다.
- 초난감 DAO에서는 코드의 중복을 메소드로 추출하여 관심사를 분리할 수 있다.

**상속을 통한 확장**

![image](https://github.com/gusals00/mentoring/assets/87007552/c26a4c3f-1bc4-44aa-91f0-4202b7cdfc14)


- 다음과 같이 변화가 일어나는 부분을 추상 메소드로 지정해서 추상 클래스를 만들어 놓으면 중복되는 부분에 대한 코드 재작성 없이 변화가 일어나는 부분만 작성해서 확장이 가능하다.
- 상속을 이용한 확장에 쓰이는 패턴
    - 템플릿 메소드 패턴
        - 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브 클래스에서 이런 메소드를 필요에 맞게 구현해 사용하는 방법이다.
    - 팩토리 메소드 패턴
        - 서브 클래스에서 객체 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드라고 한다.
        - 위 방식을 통해 객체 생성 방법을 슈퍼클래스에서 독립시키는 방법을 팩토리 메소드 패턴이라고 한다.
    - 상속의 단점
        - 자바는 다중 상속을 지원하지 않는다.
        - 상속을 통한 상하위 클래스 관계는 생각보다 밀접하다.
            - 슈퍼클래스의 변경이 있을 떄, 서브클래스를 같이 수정하거나 다시 개발해야 할 수도 있다.

**디자인 패턴**

- 디자인 패턴은 주로 객체지향 설계에 관한 것이며, 객체지향적 설계 원칙을 통해 문제를 해결한다. 패턴의 설계 구조는 대부분 비슷한데, 그 이유는 문제를 해결하기 위한 방법을 선택할 때, **클래스 상속**과 **오브젝트 합성**이라는 두 가지 길에서 크게 벗어나지 않기 때문이다.
- 패턴에서 가장 중요한 것은 패턴의 핵심이 담긴 목적 또는 의도이다.

**리펙토링**

- 기존의 코드를 외부의 동작 방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다.
- 리팩토링을 하면 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있다. 따라서 생산성이 올라가고, 코드의 품질이 높아지며 유지보수하기 용이해진다.

## 1.3 DAO의 확장

**상황**

- 추상 클래스를 만들어 서브 클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있도록 작성해놓은 상태이다.
- 변화의 성격이 다른 것을 분리해서 서로 영향을 주지 않은 채로 각각 필요한 시점에 독립적으로 변경할 수 있게 만드는 것이 핵심이다.
- 상속을 이용하니 단점이 명확했다. 상하위 관계가 밀접하여 슈퍼클래스를 맘대로 변화 시킬 수 없을 뿐더러 다른 DAO에 해당 슈퍼 클래스를 다시 상속시키면 중복 코드가 발생하는 문제가 있었다.

**클래스의 분리**

- UserDAO는 어떤 DB를 사용하는지 관심이 없고, DB에서 데이터만 가져오면 된다.
- DB를 연결하는 부분은 아예 다른 클래스로 분리해보자.

![image](https://github.com/gusals00/mentoring/assets/87007552/ed6226b8-630e-4def-b8e7-3120469cf7d5)


- 상속이 아니라 오브젝트의 합성을 이용해 문제를 해결할 수도 있다.
- 하지만 이렇게 하면 특정 클래스와 그 코드에 종속적이게 된다.

**인터페이스 도입**

![image](https://github.com/gusals00/mentoring/assets/87007552/08821566-2c41-4364-94ca-6f75b9ac61ab)


- UserDAO가 Connection을 얻는 클래스에 대해 자세한 정보를 알지 않아도 되도록 인터페이스를 도입한다.
- UserDAO는 makeNewConnection() 메소드를 실행시키면 Connection 객체가 반환되는것만 관심사이고 내부적으로 어떻게 구현 되었는지는 관심을 둘 필요가 없다.

**관계설정 책임의 분리**

- connectionMaker = new DConnectionMaker();
    - 여전히 UserDAO에는 어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 코드가 남아 있다.
    - 이 때문에 인터페이스를 이용한 분리에도 불구하고 여전히 UserDAO 변경 없이는 DB 커넥션 기능의 확장이 자유롭지 못하다.
- 아래와 같이 설정하여 UserDAO를 생성하여 이용하는 클라이언트가 ConnectionMaker 객체를 생성하고 주입해주는 책임을 갖게 되면서, UserDAO는 Connection에 대한 모든 책임에서 벗어날 수 있게 된다.
- 아래와 같이 작성하면 오브젝트의 관계는 설계 시에 결정되는 것이 아니라 런타임에 결정이 된다. 클라이언트에서 UserDAO가 사용할 오브젝트의 레퍼런스를 갖고 있다가 UserDAO를 생성할 때 넘겨주게 된다.

```java
public UserDAO(ConectionMaker connectionMaker) {
	this.connectionMaker = connectionMaker;
}
```

**개방 폐쇄 원칙(OCP)**

- 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
- UserDAO는 DB 연결 방법이라는 기능을 확장하는 데는 열려있다.
    - UserDAO는 단순히 클라이언트에서 주입해주는 객체만 변경함으로써 DB 연결 방법을 바꿀수 있는 점에서 **확장에는 열려 있다.** 다양한 DB 연결 방법을 확장할 수 있다.
    - UserDAO 코드를 전혀 수정할 필요 없이 DB 연결 방법을 바꿀 수 있다는 점에서 **변경에는 닫혀 있다.**
    

**높은 응집도와 낮은 결합도**

- 개방 폐쇄 원칙은 높은 응집도와 낮은 결합도로 설명 가능하다.
- 높은 응집도
    - 하나의 모듈, 클래스가 하나의 책임 또는 관심사에 집중되어 있다는 뜻이다.
    - 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수 있다.
        - 변경이 일어날 때 모듈의 많은 부분이 함께 변경되어야 한다면 높은 응집도를 갖고 있다고 볼 수 있다.
        - 모듈의 일부분에만 변경이 일어나도 된다면, 모듈 전체에서 어떤 부분이 바뀌어야 하는지 파악해야 하고, 그 변경으로 인해 바뀌지 않는 부분에 영향을 미치지 않는지 확인해야 하는 부담이 생긴다.
- 낮은 결합도
    - 책임과 관심사가 다른 오브젝트 또는 모듈과의 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다는 뜻이다.
    - 느슨한 연결은 관계를 유지하는데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것이다. 결합도가 낮아지면 변화에 대응하는 속도가 높아지고, 구성이 깔끔해지고 확장하기에도 편리해진다.
    - 결합도 라는것은 ‘하나의 오브젝트에서 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도’ 라고 설명할 수 있다.
    - 낮은 결합도란 하나의 변경이 발생할 때 다른 모듈과 오브젝트로 변경에 대한 요구가 전파되지 않는 상태를 말한다.
    - 클래스에서 다른 클래스를 사용할 때, 구체적인 클래스보다는 인터페이스를 사용하는 낮은 결합도에 유리하다.
    

**전략 패턴**

- 자신의 기능 컨텍스트에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.
- UserDAO는 전략 패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한 DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있게 분리했다.

## 1.4 제어의 역전(IoC)

**오브젝트 팩토리**

- 팩토리는 객체의 생성 방법을 결정하고, 그렇게 만들어진 오브젝트를 돌려 주는 역할을 하는 오브젝트를 말한다.
    - 오브젝트를 생성하는 부분과 생성된 오브젝트를 사용하는 부분을 명확히 나누기 위해 사용한다.

**제어의 역전**

- 간단히 프로그램 제어 흐름 구조가 뒤바뀌는 것이라고 설명할 수 있다.
- **일반적인 프로그램의 흐름**은 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다.
- **제어의 역전**은 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않고, 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하고, 위임받은 제어 권한을 갖는 오브젝트에 의해 결정되고 만들어진다.
- 예시
    - 팩토리
        - 이전까지는 클라이언트가 직접 어떤 클래스를 사용할지 구체적인 클래스를 결정했지만, 팩토리가 대신 어떤 클래스를 사용할지를 결정한다.
        - 클라이언트는 모든 제어 권한을 팩토리에게 위임한 것과 같다.
    - 서블릿
        - 서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출한다.
    - 템플릿 메소드 패턴
        - 서브 클래스에 작성한 메소드는 상위 클래스가 지정한 흐름에서 호출된다.

**라이브러리와 프레임워크**

- 라이브러리는 사용하는 코드가 애플리케이션 흐름을 직접 제어한다. 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다.
- 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 프레임워크는 이미 만들어진 틀이 있고, 거기에 개발자가 만든 코드가 프레임워크가 흐름을 주도하는 중에 사용된다.

## 1.5 스프링의 IoC

**스프링 빈**

- 스프링 컨테이너가 생성, 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 말한다.

**빈 팩토리**

- 스프링에서 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 말한다.

**애플리케이션 컨텍스트**

- 빈 팩토리를 확장한 IoC 컨테이너이다. 인터페이스이고, 이를 구현한 구체 클래스가 있다.
- 별도의 설정 정보를 참고해 빈의 생성, 관계설정 등의 제어작업을 총괄한다.
- 빈 팩토리는 빈의 생성과 제어의 관점에서 쓰이는 용어이고, 애플리케이션 컨텍스트는 스프링이 제공하는 애플리케이션 지원 기능도 포함하는 용어이다.
- @Configuration : 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있게 한다.
- @Bean : 객체 생성 메소드에 붙이면 해당 메소드가 생성한 객체를 스프링 빈으로써 활용할 수 있다.
- 동작 방식
    - 애플리케이션 컨텍스트는 설정정보를 등록하고 @Bean이 붙은 메소드의 이름을 가져와 빈 목록을 만들어둔다.
    - 클라이언트가 애플리케이션 컨텍스트의 getBean() 메소드를 호출하면 자신의 빈 목록에서 요청한 이름이 잇는지 찾고, 있다면 빈을 생성하는 메소드를 호출해 오브젝트를 생성한 후 클라이언트에 돌려준다.
- 장점
    - 클라이언트가 구체적인 팩토리 클래스를 알 필요가 없다.
        - 일관된 방식으로 원하는 클래스를 가져올 수 있다.
    - 팩토리처럼 오브젝트를 단순히 생성해주는 것이 아니라 종합 IoC 서비스를 제공해준다.
    - 빈을 검색하는 다양한 방법을 제공해준다.
        - 빈의 이름,타입으로 검색하거나, 특정 애노테이션이 설정되어있는 빈 검색 등 다양한 방식으로 빈을 가져올 수 있다.

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

- 스프링 빈을 가져오면, 매번 동일한 오브젝트를 돌려준다. 이렇게 매번 새로운 오브젝트를 만들지 않고, 동일한 오브젝트를 사용하는 디자인 패턴을 싱글톤 패턴이라고 한다.
- 왜 매번 만들지 않고 동일한 오브젝트를 돌려주도록 설계했을까?
    - 매번 클라이언트 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다면 부하가 걸려 서버가 감당하기 힘들기 때문이다.

**싱글톤 패턴의 단점**

- 상속이 불가능하다.
    - 생성자의 접근자가 private이라 상속이 불가능하다.
    - static 필드와 메소드를 사용하는 것도 문제이다.
    - 상속을 사용할 수 없으므로 객체지향의 큰 장점을 잃는다.
- 테스트가 힘들다.
    - 초기화 과정에서 필요한 오브젝트 등을 다이나믹하게 주입하기가 어렵다.
- 서버 환경에서 싱글톤을 보장하기 힘들다.
    - 서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다.
- 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
    - 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖는 것은 객체지향 프로그래밍에서는 권장되지 않는 프로그래밍 모델이다.

**싱글톤 레지스트리**

- 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 싱글톤 레지스트리이다.
- 장점
    - 평범한 자바 클래스를 싱글톤으로 활용할 수 있다.
        - static, private 생성자 등을 이용할 필요가 없다.
    - 테스트에서 싱글톤 방식으로 사용될 클래스를 활용할 수 있다.
        - 테스트 환경에 따라 자유롭게 오브젝트를 만들 수 있고 생성자 파라미터에 구현체를 주입하는데도 아무런 문제가 없다.
    - 스프링은 싱글톤 패턴을 사용하면서도 객체지향적인 설계방식과 원칙, 디자인 패턴 등을 적용하는데 아무런 제약이 없게 만들어주었다.
- 주의점
    - 싱글톤은 stateless여야 한다.
        - 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태 정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야 한다.
        - 읽기 전용 값을 가지는 것은 문제가 없지만, 공유되는 상태 정보를 가지면 동시성 문제가 발생할 수 있다.

**스프링 빈의 스코프**

- 빈이 생성되고 존재하고 적용되는 범위를 빈의 스코프라고 한다.
- 스프링 빈의 기본 스코프는 싱글톤이지만 경우에 따라 싱글톤 외의 스코프를 가질 수 있다.
    - 프로토타입 스코프
        - 컨테이너에 빈을 요청할 때마다 매번 새로운 빈을 만든다.
    - 요청 스코프
        - HTTP 요청이 생길 때마다 매번 새로운 빈을 만든다.
    - 세션 스코프
        - 웹의 세션과 비슷한 스코프를 갖는다.

## 1.7 의존관계 주입(DI)

**제어의 역전과 의존관계 주입**

- IoC라는 용어가 매우 느슨하게 정의되어 폭넓게 사용되는 용어이기 떄문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못한다.
- 그래서 나온 새로운 용어가 의존관계 주입이다. 스프링이 제공하는 기능에 대한 의도가 좀 더 명확히 드러난다.

**의존관계**

- A가 B에 의존하고 있다면 의존한다는 것은 A가 B를 사용하고, B가 변하면 A에 영향이 미친다는 것이다.

![image](https://github.com/gusals00/mentoring/assets/87007552/27fbe3b9-15ce-4299-b694-aa93cd81585c)


- UserDAO는 ConnectionMaker라는 인터페이스를 느슨하게 의존하고 있다. UML에서 말하는 의존관계는 이렇게 설계 모델의 관점에서 이야기하는 것이다.
- 모델이나 코드에서 클래스나 인터페이스를 통해 드러나는 의존관계 외에, 런타임 시에 오브젝트 사이에서 만들어지는 의존관계도 있다. 이를 런타임 의존관계 또는 오브젝트 의존관계라고 하는데 모델링 시점의 의존관계와는 성격이 다르다.

**의존 오브젝트**

- 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용 대상인 오브젝트를 말한다.

**의존관계 주입**

- 의존 오브젝트를 사용할 오브젝트와 의존 오브젝트의 관계를 런타임 시 연결해주는 작업을 말한다.
- 의존관계 주입이란 다음 세 가지 조건을 충족하는 작업을 말한다.
    - 클래스 모델이나 코드에서는 런타임 시점의 의존관계가 드러나지 않아야 한다. 즉, 인터페이스에 의존해야 한다.
    - 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.
    - 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.

**의존관계 검색**

- 의존관계를 맺는 방법이 외부로부터 주입이 아니라 스스로 검색을 이용한다.
- 런타임시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 IoC에게 맡기지만, 가져올때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.
- 의존관계 검색이 필요한 경우
    - 스프링 빈이 아닌 오브젝트에서 스프링 빈을 가져와야 할 때 유용하다.
        - 의존관계 주입을 원하는 오브젝트는 먼저 자기 자신이 컨테이너가 관리하는 빈이 돼야한다.

**의존관계 주입의 응용 방법**

- 기능 구현의 교환
    - 빈 생성 메소드의 반환 타입을 인터페이스로 두고 구현체를 갈아끼우는 방식
- 부가기능 추가
    - 기존 인터페이스 혹은 클래스를 상속하여 부가기능을 추가한 새로운 클래스를 만든 뒤 구현체를 바꾸는 방식
- 위 방법들은 기존에 작성된 코드를 변경하지 않고도 동작을 변경할 수 있다.

**메소드를 통한 의존관계 주입**

- 수정자 메소드를 이용한 주입
    - setXXX의 수정자를 이용해 DI 가능하다.
    - 한번에 하나의 파라미터만 가질 수 있다.
    - 부가적으로 입력 값에 대한 검증이나 그 밖의 작업도 수행 가능하다.
- 일반 메소드를 이용한 주입
    - 수정자 메소드처럼 setXXX로 시작해야 한다.
    - 한번에 여러 파라미터를 받을 수 있다.

## 1.8 XML을 이용한 설정

**XML의 특징**

- 단순한 텍스트 파일이다.
- 별도의 빌드 작업이 필요 없다.
- 환경이 바뀌어도 XML의 내용은 바뀔 필요가 없다.

**빈의 대표적 DI 정보**

- 빈의 이름 : 애노테이션에는 @Bean 메소드 이름이 빈의 이름이 되었다.
- 빈의 클래스 : 빈 오브젝트를 어떤 클래스를 이용해서 만들지를 정의한다.
- 빈의 의존 오브젝트 : 빈의 생성자나 수정자 메소드를 통해 의존 오브젝트를 넣어준다. 의존 오브젝트도 하나의 빈이므로 이름이 있고, 그 이름에 해당하는 메소드를 호출해 의존 오브젝트를 가져온다.

**XML 설정**

- <beans>를 루트 엘리먼트로 사용한다. <beans> 내부에는 여러개의 <bean>을 정의할 수 있다.
- 자바와 XML 비교
    - 빈 설정파일
        - @Configuration
        - &lt;beans&gt;
    - 빈 이름
        - @Bean methodName()
        - &lt;bean id=”methodName”&gt;
    - 빈 클래스
        - return new BeanClass();
        - class=”a.b.c…BeanClass&gt;

**DataSource**

- DB 커넥션을 가져오는 오브젝트의 기능을 추상화해서 비슷한 용도로 사용할 수 있게 만들어진 인터페이스
- DB 커넥션을 가져오는 기능 외에도 여러 개의 메소드를 추가적으로 갖고 있다.
