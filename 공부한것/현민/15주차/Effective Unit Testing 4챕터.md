# 가독성

테스트란 코드에 바라는 동작과 가정을 프로그래머 식으로 표현할 것이라 말할 수 있다.

따라서 테스트를 읽은 프로그래머는 코드가 **해야 할 일**을 이해할 수 있어야 한다. 또한, 테스트를 실행한 후에는 코드가 실제로 **한 일**이 무엇인지 말할 수 있어야 한다.

<br>

테스트의 핵심인 단언문은 대상 코드의 올바른 동작을 규정한다.

<br>

**결국, 테스트 코드는 읽기 쉬워야 한다.**

가독성을 떨어뜨리는 테스트 코드의 요소들을 살펴보자.

## 기본 타입 단언

단언문은 가정이나 의도를 명시해야 한다. 또한, 코드의 동작을 서술하는 문장이어야 한다.

기본 타입 단언이란 단언하려는 이유나 의도가 의미를 알 수 없는 단어나 숫자에 가려진 상황을 말한다. 다시 말해, 검사해야 할 동작보다 더 기초적인 요소에 집착하는 것을 말한다.

<br>

기본 타입을 단언하는 것은 대상 코드가 테스트하는 것이 무엇인지 헷갈리게 만든다. 테스트 코드는 읽는 입장에서 이해할 수 있도록 높은 수준의 추상화가 되어야 한다. 너무 낮은 수준의 추상화로 테스트 코드를 이해하기 어렵게 하지 않아야 한다.

```java
assertTrue(out.indexOf("test.txt:1 1st match") != -1);
```

개선 후

```java
assertThat(out.indexOf("test.txt:1 1st match"), is(not(-1));
assertTrue(out.contains("test.txt:1 1st match"));
```

<br>

테스트 코드에서 어떤 방식으로 의도를 표현할지 결정할 때, 코드 중복이나 성능보다 가독성과 명료성이 더 중요함을 기억해두자.

<br>

테스트에서 ≠나 ==등의 비교문을 사용하는 단언문을 발견하면 주저하지 말고 추상화 수준이 적절한지 되짚어보자. 비교 대상이 -1,0 등의 매직 넘버라면 더 생각할 것도 없다.

단언문을 즉시 이해할 수 없다면 기본 타입 단언에 해당하며 리팩토링 대상이 될 가능성이 높다.

## 광역 단언

광역 단언은 테스트 코드에서 너무 많은 것들을 단언하는 것이다. 

사소한 변경만 일어나도 테스트를 깨트리면, 테스트의 목적이 무엇인지를 희석한다. 테스트하려는 것이 무엇인지 정확히 이야기하기 어렵게 된다.

테스트 코드에서 테스트가 실패하는 이유는 오직 하나여야 한다. 테스트가 실패했는데 단언이 너무 많아 무엇 때문에 테스트가 실패했는지 모르면 안 된다.

<br>

지나치게 넓은 광역 단언과 마주쳤을 때 가장 먼저 해야 할 일은 본질과 관련 없는 세부 내용을 찾아 테스트에서 제거하는 것이다.

세분화된 주제에 충실한 테스트라야 실패했을 때 문제의 근본 원인을 빠르게 찾을 수 있다.

## 비트 단언

비트 단언은 기본 타입 단언의 특수한 형태다.

비트 연산자는 비트나 바이트 계산을 위해 프로그래밍 언어가 제공하는 훌륭한 기능이다.

하지만 비트나 바이트라는 저수준 개념을 사용함으로써 고수준의 논의가 낯선 비트 연산자 때문에 가려질 수 있다.

<br>

해결책은 간단하다. 비트 연산자를 부울 연산자로 교체해서 기대하는 결과를 명확하게 표현하면 된다.

## 부차적 상세정보

테스트 코드에 부수적인 정보가 넘쳐 흐를 때가 있는데, 이것을 부차적 상세정보라고 한다.

이를 개선하기 위해서는 다음의 지침을 잘 따르면 된다.

1. 핵심이 아닌 설정은 private 메소드나 셋업 메소드로 추출한다.
2. 적절한 인자와 서술형 이름을 사용하라
3. 한 메소드 안에서는 모두 같은 수준으로 추상화하라

## 다중 인격

다중 인격은 테스트는 오직 한 가지만 검사해야 한다는 원칙에 위배되는 테스트 냄새이다.

여러 개의 테스트 목적이 하나의 테스트 메소드를 공유하는 것을 말한다.

## 쪼개진 논리

쪼개진 논리는 테스트의 논리나 데이터가 필요 이상으로 여러 곳으로, 특히 여러 파일로 분리되어 있다는 것이다.

<br>

가독성을 높이려면 긴 메소드를 무조건 짧은 덩어리로 나누는것은 성급한 결론이다.

반드시 의미 있는 조각이어야만 인지능력에 도움이 되는 건 아니지만, 이왕이면 의미가 있을 때 효과도 배가 된다. 

무작정 작은 메소드로 추출하는건 곤란하다. 그보다는 같은 속성을 공유하는 의미 있는 조각이 어디까지인지 신경 쓰면서 나눠주는 세심함이 필요하다.

<br>

여러 곳으로 흩어진 정보는 프로그래머의 인지 부하를 가중시키고, 테스트의 의미와 의도를 파악하기 어렵게 한다.

<br>

쪼개진 논리를 해결하는 가장 간단한 방법은 필요한 외부 데이터와 코드를 모두 테스트 안으로 이주시키는 것이다.

데이터나 로직을 언제 통합 해야 할까?

어떤 데이터와 로직은 통합하는 것이 좋고, 어떤 것은 분리된 채로 놔두는 것이 낫다.

1. 짧다면 통합하라
2. 통합하기에 너무 길다면 팩토리 메소드나 테스트 데이터 생성기를 통해 만들어라.
3. 이마저도 쉽지 않다면 그냥 독립 파일로 남겨둬라.

가장 좋은 방법은 필요한 모든 정보를 테스트 안에 두는 것이다. 그러다보면 테스트가 너무 비대해지기도 하는데, 테스트 클래스에 도우미 메소드를 만들어서 살짝 거리를 두는 정도면 대부분 해결된다.

## 매직 넘버

매직 넘버란 소스코드 중 할당문이나 메소드 호출 등에 박혀 있는 숫자로 된 값을 말한다.

매직 넘버가 나쁜 이유는 뜻을 알 수 없기 때문이다.

<br>

지역 변수나 서술형 이름의 상수로 대체하는 게 매직 넘버를 없애고 의미 전달력을 키워주는 가장 보편적인 방법이다.

매직 넘버의 뜻을 표현하는 함수를 사용하는 방법도 있다.

## 셋업 설교

테스트 시나리오를 준비하기 위한 상당량의 코드를 셋업 메소드로 옮기곤 한다.

셋업 역시 테스트의 일부이기 때문에 셋업이 복잡해지면 테스트를 이해하기 어렵게 된다.

<br>

픽스처는 테스트가 실행하는 어떤 것이라고 할 수 있는데, 시스템 속성, 테스트 클래스에 정의된 상수, 셋업 메소드가 초기화한 private 멤버 등이 여기 속한다.

셋업의 역할이 테스트를 실행하기 위한 상태와 필요한 객체를 미리 만들어 놓는 것이다 보니 픽스처정의 대부분을 셋업에서 처리하게 된다.

<br>

개선 방법은 다음과 같다.

1. 셋업에서 핵심을 제외한 상세 정보는 private 메소드로 추출한다.
2. 알맞은 서술적 이름을 사용한다.
3. 셋업 내의 추상화 수준을 통일한다.

## 과잉보호 테스트

테스트 대상의 결과를 검증하면서, 의미 없는 것들을 함께 단언하는 것을 말한다.

핵심 단언이 실패하면 당연히 실패하게 될 단언을 작성하는 것을 예로 들 수 있다.

불필요한 단언문을 지워버리면 해결할 수 있다.

## 요약

기본 타입 단언은 고수준 개념을 너무 낮은 개념을 이용해서 검사한다.

대상 코드의 추상화 수준과는 거리가 한참 먼 기본 데이터 타입으로 비교하는 것이다.

<br>

광역 단언은 너무 많은 것을 바란다.

너무 많아서 극히 사소한 내용 하나만 바뀌어도 테스트가 실패해버린다.

<br>

비트 단언은 요구 조건을 표현하는 단언문에서 비트 연산자를 사용하는 것이다.

비트 연산자를 자주 접하지 못하는 개발자에게는 상당히 낯설다는 게 문제다.

<br>

부차적 상세정보는 테스트의 본질을 혼잡스럽고 중요치 않은 세부 사항 속에 파묻어 버린다.

<br>

다중 인격은 모든 기능을 단번에 검사하겠다는 욕심이 앞서서 다수의 독립된 테스트를 억지로 하나로 합쳐 놓아 생기는 혼란이다.

<br>

쪼개진 논리는 논리를 여러 파일로 흩어버려 추적하려는 개발자의 맥을 끊는다.

<br>

매직 넘버는 테스트 코드에 어질러져 있는 임의의 숫자이다.

중요한 정보를 담고 있을지도 모르지만, 명확한 이름을 지어주기 전까지는 그 의미를 알 방도가 없다.

<br>

셋업 설교는 장문의 셋업 메소드인데, 너무 세부적인 것까지 잔소리처럼 끊임없이 늘어놓는다.

<br>

과잉보호 테스트는 반드시 통과해야 할 핵심 단언문에 도달하는 과정에서 모든 선행조건 하나하나를 명시적으로 단언하는 데 열중한다.

<br>

코드는 작성되거나 수정되는 횟수보다 누군가에게 읽히는 횟수가 훨씬 많다. 그리고 코드를 이해할 수 있어야만 유지보수도 생각할 수 있다.
