# 서비스 추상화

자바에는 표준 스펙, 상용 제품, 오픈소스를 통틀어서 사용 방법과 형식은 다르지만 기능과 목적이 유사한 기술이 존재한다. 환경과 상황에 따라서 기술이 바뀌고, 그에 따라 다른 API를 사용하고 다른 스타일의 접근방식을 따라야 한다는 건 매우 피곤한 일이다.

지금까지 만든 DAO에 트랜잭션을 적용해보면서 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지 알아보자.

## 사용자 레벨 관리 기능 추가

현재 UserDao에는 CRUD만 제공한다. 그 외 어떤 비즈니스 로직도 제공하지 않는다.

새로운 요구사항이 들어와서 단지 정보를 넣고 검색하는 것 외에도 정기적으로 사용자의 활동내역을 참고해서 레벨을 조정해주는 기능이 필요해졌다고 가정해보자.

<br>

**요구사항**

- 사용자의 레벨은 BASIC, SILVER, GOLD 세 가지 중 하나다
- 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한 단계씩 업그레이드될 수 있다.
- 가입 후 50회 이상 로그인을 하면 BASIC에서 SILVER 레벨이 된다.
- SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
- 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.

### 필드 추가

**Level Enum**

첫 요구사항을 충족하기 위해 Level을 만들어야 한다고 가정하자. 

Level을 저장할 때 DB에는 varchar 타입으로 선언하고 “BASIC”, ‘SILVER”, “GOLD”로 저장할 수도 있겠지만, 이렇게 일정한 종류의 정보를 문자열로 넣는 것은 별로 좋아 보이지 않는다. 대신 각 레벨을 코드화해서 숫자로 넣자. 범위가 작은 숫자로 관리하면 DB 용량도 많이 차지하지 않고 가벼워서 좋다.

<br>

숫자로 넣기로 했다고 가정하면 User 객체에 추가할 프로퍼티 타입도 숫자로 하면 될까? 의미 없는 숫자를 프로퍼티에 사용하면 타입이 안전하지 않아서 위험할 수 있다.

```java
public class User {
    private static final int BASIC = 1;
    private static final int SILVER = 2;
    private static final int GOLD = 3;

    int level;

    public setLevel(int level) {
        this.level = level;
    }
}
```

위와 같이 상수 값을 정해놓고 int 타입으로 레벨을 사용한다고 해보자.

BASIC, SILVER, GOLD처럼 의미있는 상수도 정의해놨으니 깔끔하게 코드를 작성할 수 있긴 하지만, 문제는 Level의 타입이 int이기 때문에 정의한 Level의 범위에 속하지 않는 값을 넣는 실수를 해도 컴파일러가 체크해주지 못한다는 점이다.

<br>

그래서 숫자 타입을 직접 사용하는 것보다는 Enum을 이용하는게 안전하고 편리하다.

```java
public enum Level {
    BASIC(1), SILVER(2), GOLD(3);

    private final int value;

    Level(int value) {
        this.value = value;
    }

    public int intValue() {
        return value;
    }

    public static Level valueOf(int value) {
        switch (value) {
            case 1 -> BASIC;
            case 2 -> SILVER;
            case 3 -> GOLD;
            default -> throw new AssertionError("Unknown value: " + value);
        };
    }
}
```

이렇게 만들어진 Level enum은 내부에는 DB에 저장할 int 타입의 값을 갖고 있지만, 겉으로는 Level 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다. 또한 setLevel(1000)과 같은 코드는 컴파일러가 타입이 일치하지 않는다는 에러를 내면서 걸러줄 것이다.

<br>

**User 필드 추가**

```java
public class User {
    ...
    Level level;
    int login;
    int recommend;

    public Level getLevel() {
        return level;
    }
		public void setLevel(Level level) {
				this.level = level;
		}
		...
```

<br>

**UserDaoTest 수정**

```java
public class UserDaoTest {
    ...

    @BeforeEach
    public void setUp() {
        this.user1 = new User("user1", "김", "1234", Level.BASIC, 1 ,0);
        this.user2 = new User("user2", "현", "1234", Level.SILVER, 55, 10);
        this.user3 = new User("user3", "민", "1234", Level.GOLD, 100, 40);
    }
```

기존의 픽스처들에게 새로 추가된 세 필드의 값을 넣어준다.

```java
private void checkSameUser(User user1, User user2) {
        assertEquals(user1.getId(), user2.getId());
        assertEquals(user1.getName(), user2.getName());
        assertEquals(user1.getPassword(), user2.getPassword());
        assertEquals(user1.getLevel(), user2.getLevel());
        assertEquals(user1.getLogin(), user2.getLogin());
        assertEquals(user1.getRecommend(), user2.getRecommend());
    }
```

<br>

**UserDaoJdbc 수정**

```java
public UserDaoJdbc() {
        this.userRowMapper = (rs, rowNum) -> {
            User user = new User();
            user.setId(rs.getString("id"));
            user.setName(rs.getString("name"));
            user.setPassword(rs.getString("password"));
            **user.setLevel(Level.valueOf(rs.getInt("level")));
            user.setLogin(rs.getInt("login"));
            user.setRecommend(rs.getInt("recommend"));**
            return user;
        };
    }

public void add(User user) {
				this.jdbcTemplate.update("insert into users(id, name, password, level, login, recommend) values (?, ?, ?, ?, ?, ?)"
                    ,user.getId()
                    ,user.getName()
                    ,user.getPassword()
                    **,user.getLevel().intValue()
                    ,user.getLogin()
                    ,user.getRecommend());**
}

```

여기서 눈여겨볼 것은 Level 타입의 level 필드를 사용하는 부분이다. Level enum은 오브젝트이므로 DB에 저장될 수 있는 SQL 타입이 아니다. 따라서 DB에 저장 가능한 정수형 값으로 변환해줘야 한다.

Level에 미리 만들어둔 intValue() 메소드를 사용해서 int 값으로 매핑해주었다.

반대로 조회를 했을 경우 ResultSet에서는 DB의 타입인 int로 level 정보를 가져오기 때문에 Level.valueOf()를 통해 Level 객체로 다시 전환해주었다.

<br>

만약 이 부분에서 문자열로 작성된 SQL에 실수가 있었다면 어땠을까? 실행 전까지는 에러를 발견하지 못하고 런타임 상태가 되어야 예외가 발생했을 것이다.

JDBC가 사용하는 SQL은 컴파일 과정에서는 자동으로 검증이 되지 않는 단순 문자열에 불과하다. 우리는 미리미리 DB까지 연동되는 테스트를 잘 만들어뒀기 때문에 테스트만 돌려봤어도 해당 에러를 잡을 수 있었을 것이다.

테스트를 작성하지 않았다면 수정된 코드를 빌드하고 서버에 올려서 누군가 사용자의 정보를 읽고 쓰는 기능을 사용하기 전까지는 이런 오타조차 발견하기 힘들 것이다. 한참 후에 수동 테스트를 통해 에러 메세지를 보고, 그제서야 겨우 오타를 발견할 것이다.

그때까지 진행한 빌드와 서버 배치, 서버 재시작, 수동 테스트 등에 소모한 시간은 낭비에 가깝다.

빠르게 실행 가능한 포괄적인 테스트를 만들어두면 이렇게 기능의 추가나 수정이 일어날 때 그 위력을 발휘한다.

### 사용자 수정 기능 추가

사용자 관리 비즈니스 로직에 따르면 사용자 정보는 여러 번 수정될 수 있다. 성능을 극대화하기 위해, 수정되는 필드의 종류에 따라서 각각 여러 개의 수정용 DAO 메소드를 만들어야 할 때도 있다. 하지만 아직은 사용자 정보가 단순하고 필드도 몇개 되지 않고 수정이 자주 일어나지 않으므로 간단히 접근하자.

<br>

User 오브젝트를 전달하면 id를 참고해서 사용자를 찾아 필드 정보를 UPDATE 문을 이용해 모두 변경해주는 메소드를 하나 만들자.

**수정 기능 테스트 추가**

```java
@Test
public void update() {
    dao.add(user1);

    user1.setName("오민규");
    user1.setPassword("springno6");
    user1.setLevel(Level.GOLD);
    user1.setLogin(1000);
    user1.setRecommend(999);

    userDao.update(user1);

    User user1update = dao.get(user1.getId());
    checkSameUser(user1, user1update);
}
```

id를 제외한 나머지 내용을 바꾼 뒤 update()를 호출하고 다시 id로 조회해서 가져온 User 오브젝트와 수정한 픽스처 오브젝트를 비교한다.

<br>

**UserDao와 UserDaoJdbc 수정**

```java
public interface UserDao {
	...
	public void update(User user1);
}
```

```java
@Override
public void update(User user) {
	this.jdbcTemplate.update(
		"update users set name = ?, password = ?, level = ?, login = ?, recommend = ? where id = ? "
		, user.getName(), user.getPassword(), user.getLevel().intValue(), user.getLogin(), user.getRecommend(), user.getId());
}
```

**수정 테스트 보완**

기존 테스트는 성공했지만 꼼꼼한 개발자라면 이 테스트에 뭔가 불만을 가지고 의심스럽게 코드를 다시 살펴봐야 한다. JDBC 개발에서 가장 많은 실수가 일어나는 곳은 SQL 문장이다.

SQL 문법을 틀렸다면 런타임 도중에 예외가 날테지만, UPDATE 문장에서 WHERE절을 빼먹는 경우에는 테스트는 정상적으로 동작하는데 결과는 이상한 경우가 발생할 수 있다.

<br>

이 문제를 해결할 방법을 생각해보자.

첫 번째는 JdbcTemplate의 update()가 돌려주는 리턴 값을 확인하는 것이다. JdbcTemplate의 update()는 UPDATE나 DELETE 같이 테이블의 내용에 영향을 주는 SQL을 실행하는 영향받은 로우의 개수를 돌려준다.

에러가 발생하지 않고, 원하는 사용자의 정보는 변경됐음을 확인했더라도 영향받은 로우의 개수가 1보다 크다면 update() 메소드의 SQL에 문제가 있다는 사실을 알 수 있다.

<br>

두 번째는 테스트를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인하는 것이다. 사용자를 두 명 등록해놓고, 그 중 하나만 수정한 뒤에 수정한 사용자와 수정하지 않은 사용자의 정보를 모두 확인하면 된다.

### UserService.updateLevels()

이제 레벨 관리 기능을 추가해야 한다. 특정 시간마다 회원 중 레벨업 조건을 만족한 회원의 레벨을 올려주면 된다.

사용자 관리 로직은 어디다 두는 것이 좋을까? UserDaoJdbc는 적당하지 않다. DAO는 데이터를 어떻게 가져오고 조작할지를 다루는 곳이지 비즈니스 로직을 두는 곳이 아니다. 사용자 관리 비즈니스 로직을 담을 클래스를 하나 추가하자. 클래스 이름은 UserService로 한다.

UserService는 UserDao의 구현 클래스가 바뀌어도 영향받지 않도록 해야 한다. 데이터 엑세스 로직이 바뀌었다고 비즈니스 로직 코드를 수정하는 일이 있어서는 안된다. 따라서 DAO의 인터페이스를 사용하고 DI를 적용해야 한다. DI를 적용하려면 당연히 UserService도 스프링의 빈으로 등록돼야 한다.

**UserService 클래스와 빈 등록**

```java
public class UserService {
    UserDao userDao;

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

UserDao 오브젝트의 DI가 가능하도록 수정자 메소드도 추가한다.

그리고 스프링 설정파일에 userService 아이디로 빈을 추가하고 userDao 빈을 DI받도록 프로퍼티를 추가해준다.

**UserServiceTest 클래스**

먼저 간단히 UserService가 정상적으로 userDao를 주입 받는지만 확인해보자.

```java
@ExtendWith(SpringExtension.class)
@ContextConfiguration(locations="/test-applicationContext.xml")
class UserServiceTest {
    @Autowired 
		UserService userService;

    @Test
    public void bean() {
        assertNotNull(userService.userDao);
    }
}
```

**upgradeLevels() 메소드**

앞에서 살펴본 로직을 잘 보고 그대로 코드로 구현해보면 아래와 같은 메소드로 만들어낼 수 있다.

```java
public void upgradeLevels() {
        List<User> users = userDao.getAll();

        for (User user : users) {
            Boolean changed = null; // 레벨의 변화가 있는지를 확인하는 플래그

            if (user.getLevel() == Level.BASIC && user.getLoginCount() >= 50) {
                user.setLevel(Level.SILVER);
                changed = true;
            } else if (user.getLevel() == Level.SILVER && user.getRecommendCount() >= 30) {
                user.setLevel(Level.GOLD);
                changed = true;
            } else if (user.getLevel() == Level.GOLD) {
                changed = false;
            } else {
                changed = false;
            }

            if(changed) {
                userDao.update(user);
            }
        }
    }
```

**upgradeLevels() 테스트**

모든 케이스를 테스트하려면 각 레벨에서 업그레이드 되는 경우와 아닌 경우를 나눠서 각각 생각해보면 된다.

사용자 레벨은 세 가지가 있고, 경우는 두 가지가 있어서 총 여섯 가지의 경우가 있는데 GOLD는 변경이 일어나지 않기 때문에 다섯 가지 경우를 살펴보면 된다.

```java
List<User> users; // 테스트 픽스처

@BeforeEach
public void setUp() {
		users = Arrays.asList(
				 new User("bumjin", "박범진", "p1", Level.BASIC, 49, 0),
         new User("joytouch", "강명성", "p2", Level.BASIC, 50, 0),
         new User("erwins", "신승한", "p3", Level.SILVER, 60, 29),
         new User("madnite1", "이상호", "p4", Level.SILVER, 60, 30),
         new User("green", "오민규", "p5", Level.GOLD, 100, 100)
    );
}
```

테스트 픽스처는 위와 같이 만들었다. 로그인 횟수와 추천 횟수가 각각 기준 값인 50, 30 이상이 되면 SILVER와 GOLD로 업그레이드된다. 이럴 땐 테스트에 사용할 데이터를 경계가 되는 값의 전후로 선택하는 것이 좋다.

```java
  	@Test
    public void upgradeLevels() {
				userDao.deleteAll();
        for (User user : users) {
            userDao.add(user);
        }

        userService.upgradeLevels();

        checkLevel(users.get(0), Level.BASIC);
        checkLevel(users.get(1), Level.SILVER);
        checkLevel(users.get(2), Level.SILVER);
        checkLevel(users.get(3), Level.GOLD);
        checkLevel(users.get(4), Level.GOLD);
    }

    private void checkLevel(User user, Level expectedLevel) {
        User userUpdate = userDao.get(user.getId());
        assertEquals(userUpdate.getLevel(), expectedLevel);
    }
```

다섯 가지 종류의 사용자 정보를 저장한 뒤에 upgradeLevels() 메소드를 실행한다. 업그레이드 작업이 끝나면 사용자 정보를 하나씩 가져와 레벨의 변경 여부를 확인한다.

**UserService.add()**

처음 가입하는 사용자는 기본적으로 BASIC 레벨이어야 한다는 요구사항을 충족시켜보자.

이 로직은 어디에 담는 것이 좋을까? 일단 UserDaoJdbc의 add() 메소드는 적합하지 않아 보인다. UserDaoJdbc는 주어진 User 오브젝트를 DB에 정보를 넣고 읽는 방법에만 관심을 가져야지 비즈니스적인 의미를 지닌 정보를 설정하는 책임을 지는 것은 바람직하지 않다.

<br>

그렇다면 User 클래스에서 아예 level 필드를 Level.BASIC으로 초기화하는 것은 어떨까? 하지만 처음 가입할 때를 제외하면 무의미한 정보인데 단지 이 로직을 담기 위해 클래스에서 직접 초기화하는 것은 문제가 있어 보인다.

그렇다면 사용자 관리에 대한 비즈니스 로직을 담고 있는 UserService에 이 로직을 넣으면 어떨까? UserDao의 add() 메소드는 사용자 정보를 담은 User 오브젝트를 받아서 DB에 넣어주는 데 충실한 역할을 한다면, UserService에도 add()를 만들어두고 사용자가 등록될 때 적용할 만한 비즈니스 로직을 담당하게 하면 될 것이다.

<br>

먼저 테스트부터 만들어보자. 검증할 기능은 UserService의 add()를 호출하면 레벨이 BASIC으로 설정되는 것이다. 그런데 UserService의 add()에 전달되는 User 오브젝트에 level 필드에 값이 미리 설정되어 있는 경우에는 어떻게 할까? 이건 정하기 나름이다. 미리 설정된 값이 있다면 설정된 값을 이용하도록 하자.

테스트 케이스는 두 종류를 만들면 된다. 레벨이 미리 정해진 경우와 레벨이 비어있는 두 가지 경우에 각각 add() 메소드를 호출하고 결과를 확인하도록 만들자.

```java
 		@Test
    public void add() {
				userDao.deleteAll();

        User userWithLevel = users.get(4); // GOLD 레벨
        User userWithoutLevel = users.get(0);
        userWithoutLevel.setLevel(null);

        userService.add(userWithLevel);
        userService.add(userWithoutLevel);

        User userWithLevelRead= userDao.get(userWithLevel.getId());
        User userWithoutLevelRead= userDao.get(userWithoutLevel.getId());

        assertEquals(userWithLevelRead.getLevel(), userWithLevel.getLevel());
        assertEquals(userWithoutLevelRead.getLevel(), Level.BASIC);
    }
```

테스트는 준비됐으니 이제 테스트가 성공하도록 코드를 만들어보자.

```java
    public void add(User user) {
        if(user.getLevel() == null) {
            user.setLevel(Level.BASIC);
        }

        userDao.add(user);
    }
```

테스트가 조금 복잡한 것이 흠이다. 간단한 비즈니스 로직을 담은 코드를 테스트하기 위해 DAO와 DB까지 모두 동원되는 점이 조금 불편하다. 이런 테스트는 간단히 만드는 방법이 있는데, 뒤에서 다시 다뤄보자.

### 코드 개선

어느정도 요구사항은 맞춰졌지만, 만들어진 코드를 다시 한번 검토해보자. 작성된 코드를 살펴볼 때는 다음과 같은 질문을 해볼 필요가 있다.

- 코드에 중복된 부분은 없는가?
- 코드가 무엇을 하려는 것인지 이해하기 불편하지 않은가?
- 코드가 자신이 있어야 할 자리에 있는가?
- 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?

<br>

**upgradeLevels() 메소드 코드의 문제점**

이런 질문을 하며 UserService의 upgradeLevels() 메소드를 살펴보면 몇 가지 문제점이 보인다.

일단 for 루프 속에 들어 잇는 if/elseif/else 블록들이 읽기 불편하다. 레벨의 변화 단계와 업그레이드 조건, 조건이 충족됐을 때 해야 할 작업이 한데 섞여 있어서 로직을 이해하기가 쉽지 않다.

플래그를 두고 이를 변경하고 마지막에 확인해서 업데이트 하는 방법도 깔끔해 보이지 않는다.

코드가 깔끔해 보이지 않는 이유는 성격이 다른 여러 가지 로직이 한데 섞여 있기 때문이다.

if 블록 하나를 중심으로 살펴보자

```java
if(user.getLevel() == Level.BASIC && user.getLogin() >= 50) {
		user.setLevel(Level.SILVER)
		changed = true
}
...
if(changed) { userDao.update(user); }
```

- user.getLevel() == Level.BASIC → 현재 레벨이 무엇인지 파악하는 로직이다.
- user.getLogin() ≥ 50 → 업그레이드 조건을 담은 로직이다.
- user.setLevel(Level.SILVER) → 다음 단계의 레벨이 무엇이며 업그레이드를 위한 작업은 어떤 것인지가 함께 담겨 있다.
- changed = true → 이 자체로는 의미가 없고, 단지 멀리 떨어져 있는 userDao.update(user)의 작업이 필요함을 알려주는 역할이다.

관련이 있어 보이지만, 사실은 성격이 조금씩 다른 것들이 섞여 있거나 분리돼서 나타나는 구조다.

<br>

이런 if 조건 블록이 레벨 개수만큼 반복된다. 

새로운 레벨이 추가된다면 Level enum도 수정해야 하고, upgradeLevels()의 레벨 업그레이드 로직을 담은 코드에 if 조건식과 블록을 추가해줘야 한다.

업그레이드 작업에서 하는 일이 단지 level 필드를 변경하는 수준 이상이라면 upgradeLevels() 메소드는 점점 길어지고 복잡해지며 갈수록 이해하고 관리하기가 힘들어진다.

레벨과 업그레이드 조건을 동시에 변경하는 부분도 문제가 될 수 있다. 새로운 레벨이 추가되면 기존 if 조건들에 맞지 않을 테니 else 블록으로 이동할 것이다. 성격이 다른 두 가지 경우가 한 곳에서 처리되는 것은 이상하다.

**upgradeLevels() 리팩토링**

레벨을 업그레이드 하는 작업의 기본 흐름만 먼저 만들어보자.

```java
public void upgradeLevels() {
        List<User> users = userDao.getAll();
        for (User user : users) {
            if(canUpgradeLevel(user)) {
                upgradeLevel(user);
            }
        }
    }
```

모든 사용자 정보를 가져와 한 명씩 업그레이드가 가능한지 확인하고, 가능하면 업그레이드를 한다. 구체적인 내용은 모르겠지만 upgradeLevels() 메소드가 어떤 작업을 하는지는 쉽게 이해할 수 있다.

이제 하나씩 구체적인 내용을 담은 메소드를 만들면 된다.

<br>

canUpgradeLevel() 메소드는 주어진 user에 대해 업그레이드가 가능하면 true, 가능하지 않으면 false를 리턴하면 된다. 상태에 따라서 업그레이드 조건만 비교하면 되므로 역할과 책임이 명료해진다.

```java
private boolean canUpgradeLevel(User user) {
        Level currentLevel = user.getLevel();

        switch(currentLevel) {
            case BASIC -> user.getLogin() >= 50;
            case SILVER -> user.getRecommend() >= 30;
            case GOLD -> false;
            default -> throw new IllegalArgumentException("Unknown Level: " + currentLevel);
        };
    }
```

switch 문으로 레벨을 구분하고, 각 레벨에 대한 업그레이드 조건을 만족하는지 확인하고 업그레이드가 가능한지에 따라 true/false를 반환한다.

처리할 수 없는 레벨인 경우 예외를 던져주기 때문에 해당 등급에 대한 로직 처리를 하지 않았음을 쉽게 알 수 있다.

<br>

upgradeLevel() 메소드는 사용자의 레벨을 다음 단계로 바꿔주는 것과 변경사항을 DB에 업데이트 해준다.

```java
private void upgradeLevel(User user) {
				if(user.getLevel() == Level.BASIC) user.setLevel(Level.SILVER);
				else if(user.getLevel() == Level.SILVER) user.setLevel(Level.GOLD);				
        userDao.update(user);
 }
```

그런데 위 코드는 마음에 들지 않는다. 다음 단계가 무엇인가 하는 로직과 그때 사용자 오브젝트의 level 필드를 변경해준다는 로직이 함께 있는데다, 너무 노골적으로 드러나 있다. 또한 예외상황에 대한 처리도 없다.

<br>

이것도 더 분리해 보자. 먼저 레벨의 순서와 다음 단계 레벨이 무엇인지를 결정하는 일은 Level에게 맡기자.

```java
public enum Level {
    GOLD(3, null), SILVER(2, GOLD), BASIC(1, SILVER);

    private final int value;
    private final Level next;

    Level(int value, Level next) {
        this.value = value;
        this.next = next;
    }

    public Level nextLevel() {
        return next;
    }

    public int intValue() {
        return value;
    }

    public static Level valueOf(int value) {
        return switch (value) {
            case 1 -> BASIC;
            case 2 -> SILVER;
            case 3 -> GOLD;
            default -> throw new AssertionError("Unknown value: " + value);
        };
    }
}
```

레벨 업그레이드 순서에 대한 책임을 Level enum에 맡겼다. 다음 레벨이 무엇인지를 알고 싶다면 nextLevel() 메소드를 호출해주면 된다. 이제 다음 단계의 레벨이 무엇인지를 일일이 if 조건식을 만들어서 비즈니스 로직에 담아둘 필요가 없다.

<br>

이번엔 사용자 정보가 바뀌는 부분을 UserService 메소드에서 User로 옮겨보자. 

User의 내부 정보가 변경되는 것은 UserService보다는 User가 스스로 다루는 게 적절하다. User는 사용자 정보를 담고 있는 단순한 자바빈이긴 하지만 User도 엄연히 자바 오브젝트이고 내부 정보를 다루는 기능이 있을 수 있다. UserService가 일일이 레벨 업그레이드 시에 User의 어떤 필드를 수정한다는 로직을 갖고 있기보다는, User에게 레벨 업그레이드를 해야 하니 정보를 변경해달라고 요청하는 편이 낫다.

```java
public void upgradeLevel() {
        Level nextLevel = this.level.nextLevel();

        if (nextLevel == null) {
           throw new IllegalStateException(this.level + "은 업그레이드가 불가능합니다.");
        } else {
            this.level = nextLevel;
        }
    }
```

UserService의 canUpgradeLevel() 메소드에서 업그레이드 가능 여부를 미리 판단해주기는 하지만, User 오브젝트를 UserService만 사용하는 건 아니므로 스스로 예외상황에 대한 검증 기능을 갖고 있는 편이 안전하다.

User에 업그레이드 작업을 담당하는 독립적인 메소드를 두고 사용할 경우, 업그레이드 시 기타 정보도 변경이 필요해지면 그 장점이 무엇인지 알 수 있을 것이다. 가장 최근에 레벨을 변경한 일자를 User 오브젝트에 남겨두고 싶을 수도 있다. 이때는 lastUpgraded 필드를 추가하고 upgradeLevel()에  this.lastUpgraded = new Date()와 같은 코드를 넣어주기만 하면 된다.

**간결해진 UserService.upgradeLevel()**

```java
private void upgradeLevel(User user) {
      user.upgradeLevel();
      userDao.update(user);
}
```

if 문장이 많이 들어 있던 이전 코드보다 간결하고 작업 내용이 명확하게 드러나는 코드가 됐다. 각 오브젝트가 해야 할 책임도 깔끔하게 분리가 됐다.

<br>

지금 개선한 코드를 살펴보면 각 오브젝트와 메소드가 각각 자기 몫의 책임을 맡아 일을 하는 구조로 만들어졌음을 알 수 있을 것이다. UserServcice, User, Level이 내부 정보를 다루는 자신의 책임에 충실한 기능을 갖고 있으면서 필요가 생기면 이런 작업을 수행해달라고 서로 요청하는 구조다.

각자 자기 책임에 충실한 작업만 하고 있으니 코드를 이해하기도 쉽다. 또, 변경이 필요할 때 어디를 수정해야 할지도 쉽게 알 수  있다. 잘못된 요청이나 작업을 시도했을 때 이를 확인하고 예외를 던져줄 준비도 다 되어 있다. 각각을 독립적으로 테스트하도록 만들면 테스트 코드도 단순해진다.

객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다. 오브젝트에게 데이터를 요구하지 말고 작업을 요청하라는 것이 객체지향 프로그래밍의 가장 기본이 되는 원리이기도 하다.

**User 테스트**

```java
    User user;

		@BeforeEach
		public void setUp() {
				user = new User();
		}

    @Test
    public void upgradeLevel() {
        Level[] levels = Level.values();
        for (Level level : levels) {
            if(level.nextLevel() == null) continue;

            user.setLevel(level);
            user.upgradeLevel();
            assertEquals(user.getLevel(), level.nextLevel());
        }
    }

    @Test
    public void cannotUpgradeLevel() {
        Level[] levels = Level.values();
        assertThrows(IllegalStateException.class, () -> {
            for (Level level : levels) {
                if(level.nextLevel() != null) continue;

                user.setLevel(level);
                user.upgradeLevel();
            }
        });
    }
```

User 클래스에 대한 테스트는 굳이 스프링의 테스트 컨텍스트를 사용하지 않아도 된다. User 오브젝트는 스프링이 IoC로 관리해주는 오브젝트가 아니기 때문이다.

컨테이너가 생성한 오브젝트를 @Autowired로 가져오는 대신 생성자를 호출해서 테스트할 User 오브젝트를 만들면 된다.

굳이 이렇게까지 테스트를 하는 이유는 나중에 있을 변화에 대비하기 위해서이다. 나중에 upgradeLevel() 메소드에 좀 더 복잡한 기능이 추가되었을 때도 이 테스트를 확장해 사용할 수 있다.

<br>

**UserServiceTest 개선**

기존 테스트에서는 다음 레벨에 대한 정보를 직접 Level.SILVER 같은 방식으로 넣어주었다. 이것도 사실 중복이다.

Level이 가지고 있어야 할 다음 레벨이 무엇인가 하는 정보를 테스트에 직접 넣어둘 이유가 없다. 레벨이 추가되거나 변경되면 테스트도 따라서 수정해야 하니 번거롭다.

```java
	  @Test
    public void upgradeLevels() {
        for (User user : users) {
            userDao.add(user);
        }

        userService.upgradeLevels();

        checkLevelUpgraded(users.get(0), false);
        checkLevelUpgraded(users.get(1), true);
        checkLevelUpgraded(users.get(2), false);
        checkLevelUpgraded(users.get(3), true);
        checkLevelUpgraded(users.get(4), false);
    }

    private void checkLevelUpgraded(User user, boolean upgraded) {
        User userUpdate = userDao.get(user.getId());
				if(upgraded) {
						assertEquals(userUpdate.getLevel(), user.getLevel().nextLevel()));
				} else {
						assertEquals(userUpdate.getlevel(), user.getLevel()));
				}
    }
```

개선한 upgradeLevels() 테스트는 각 사용자에 대해 업그레이드를 확인하려는 것인지 아닌지가 좀 더 이해하기 쉽게 true,false로 나타나 있어서 보기 좋다.

<br>

다음은 코드에 나타난 중복을 제거해보자. 업그레이드 조건인 로그인 횟수와 추천 횟수가 애플리케이션 코드와 테스트 코드에 중복돼서 나타난다.

```java
case BASIC -> user.getLoginCount() >= **50**;
new User("joytouch", "강명성", "p2", Level.BASIC, **50**, 0)
```

테스트와 애플리케이션 코드에 나타난 이런 숫자의 중복도 제거해줘야 할까? 당연하다. 한 가지 변경 이유가 발생했을 때 여러 군데를 고치게 만든다면 중복이기 때문이다.

이런 상수 값을 중복하는 건 바람직하지 못하다. 기준이 되는 최소 로그인 횟수가 변경될 때도 한 번만 수정할 수 있도록 만들자. 가장 좋은 방법은 정수형 상수로 변경하는 것이다.

```java
public static final int MIN_LOGIN_COUNT_FOR_SILVER = 50;
public static final int MIN_RECOMMEND_COUNT_FOR_GOLD = 30;
```

<br>

좀 더 욕심을 내자면 레벨을 업그레이드하는 정책을 유연하게 변경할 수 있도록 개선하는 것도 생각해 볼 수 있다. 연말 이벤트나 새로운 서비스 홍보기간 중에는 레벨 업그레이드 정책음 다르게 적용할 필요가 있을 수도 있다. 그럴 때마다 중요한 사용자 관리 로직을 담은 Userservice의 코드를 직접 수정했다가 이벤트 기간이 끝나면 다시 이전 코드로 수정한다는 것은 상당히 번거롭고 위험한 방법이다.

이런 경우 사용자 업그레이드 정책을 UserService에서 분리하는 방법을 고려해볼 수 있다. 분리된 업그레이드 정책을 담은 오브젝트는 DI를 통해 UserService에 주입한다.

```java
public interface UserLevelUpgradePolicy {
  boolean canUpgradeLevel(User user);
  void upgradeLevel(User user);
}
```

## 트랜잭션 서비스 추상화

정기 사용자 레벨 관리 작업을 수행하는 도중에 네트워크가 끊기거나 서버에 장애가 생겨서 작업을 완료할 수 없다면 변경된 사용자의 레벨은 그대로 둬야 할까 아니면 모두 초기 상태로 되돌려 놓아야 할까?

사용자 레벨 조정 작업은 중간에 문제가 발생해서 작업이 중단된다면 그때까지 진행된 변경 작업도 모두 취소 시키도록 결정했다. 일부 사용자는 레벨이 조정됐는데 일부는 안 됐다면 사용자의 반발이 심할 것으로 예상되기 때문이다.

<br>

### 모 아니면 도

지금까지 만든 사용자 레벨 업그레이드는 모든 사용자에 대해 업그레이드 작업을 진행하다가 중간에 예외가 발생해서 작업이 중단된다면 어떻게 될까? 테스트를 만들어서 확인해 보자.

**테스트용 UserService 대역**

어떻게 작업 중간에 예외를 강제로 만들 수 있을까? 가장 쉬운 방법은 예외를 강제로 발생시키도록 애플리케이션 코드를 수정하는 것이다. 하지만 테스트를 위해 코드를 함부로 건드리는 것은 좋은 생각이 아니다.

그래서 이런 경우엔 테스트용으로 특별히 만들어진 UserService의 대역을 사용하는 방법이 좋다. UserService를 대신해서 테스트의 목적에 맞게 동작하는 클래스를 만들어 사용하자는 것이다.

<br>

UserService의 코드를 복사해서 새로운 클래스를 만들면 코드 중복도 발생하고 사용하기도 번거로워 보인다. 간단히 UserService를 상속해서 테스트에 필요한 기능을 추가하도록 일부 메소드를 오버라이딩하는 방법이 나을 것 같다.

테스트에서만 사용할 클래스라면 따로 파일을 만들지 말고 테스트 클래스 내부에 스태틱 클래스로 만드는 것이 간편하다. 그런데 상속을 받는다고 해도 private로 작성된 부분은 오버라이드 할 수 없기 때문에 기존 코드를 변경하는게 꺼림칙하긴 하지만 protected로 잠시만 변경하자.

```java
static class TestUserService extends UserService {
        private String id;

        public TestUserService(String id) {
            this.id= id;
        }

        @Override
        protected void upgradeLevel(User user) {
            if(user.getId().equals(this.id)) {
                throw new TestUserServiceException();
            }

            super.upgradeLevel(user);
        }

        static class TestUserServiceException extends RuntimeException {
        }
    }
```

미리 지정된 id를 가진 사용자가 발견되면 강제로 예외를 던지도록 만들었다.

**강제 예외 발생을 통한 테스트**

```java
    @Test
    public void upgradeAllOrNothing() {
				UserService testUserService = new TestUserService(users.get(3).getId());
				testUserService.setUserDao(this.userDao);

				userDao.deleteAll();
        for (User user : users) {
            userDao.add(user);
        }

				try {
						testUserService.upgradeLevels();
						fail("TestUserServiceException expected");
				} catch(TestUserServiceException e){}

				checkLevelUpgraded(users.get(1), false);
    }
```

테스트 메소드에서 직접 TestUserService의 오브젝트를 만들고, 동작하는데 필요한 DAO만 스프링이 만들어준 UserDao 오브젝트를 DI해준다.

컨테이너에 종속적이지 않은 평범한 자바 코드로 만들어지는 스프링 DI 스타일의 장점이 바로 이런 것이다. UserDao를 DI해주고 나면 testUserService 오브젝트는 스프링 설정에 의해 정의된 userService 빈과 동일하게 UserDao를 사용해 데이터 엑세스 기능을 이용할 수 있다.

<br>

5개의 사용자 정보를 등록하고 testUserService의 업그레이드 메소드를 실행한다. upgradeLevels(0에서는 DB에서 5개의 User를 가져와 차례로 업그레이드를 하다가 지정해둔 4번째 사용자 오브젝트 차례가 되면 TestUserServiceExcpetion을 발생시킬 것이다. 혹시라도 테스트 코드를 잘못 작성해서 예외 발생 없이 upgradeLevels() 메소드가 정상적으로 종료되면 fail() 메소드 때문에 테스트가 실패할 것이다.

우리가 기대하는 건 네 번째 사용자를 처리하다가 예외가 발생해서 작업이 중단됐으니 이미 레벨을 수정했던 두 번째 사용자도 원래 상태로 돌아가는 것이다.

테스트를 돌려보면 두번째 사용자의 레벨이 BASIC에서 SILVER로 바뀐 것이 네 번째 사용자 처리 중에 예외가 발생했지만 그대로 유지되고 있다.

**테스트 실패의 원인**

DB와 JDBC 프로그래밍에 대한 기본적인 지식이 있다면 왜 이런 결과가 나왔는지 쉽게 알 수 있다.

바로 트랜잭션 문제다. 모든 사용자의 레벨을 업그레이드하는 작업인 upgradeLevels() 메소드가 하나의 트랜잭션 안에서 동작하지 않았기 때문이다.

트랜잭션이란 더 이상 나눌 수 없는 단위 작업을 말한다. 작업을 쪼개서 작은 단위로 만들 수 없다는 것은 트랜잭션의 핵심 속성인 원자성을 의미한다.

### 트랜잭션 경계설정

DB는 그 자체로 완벽한 트랜잭션을 지원한다. SQL을 이용해 다중 ROW의 수정이나 삭제를 위한 요청을 했을 때 일부 ROW만 삭제되고 나머지는 안 된다거나, 일부 필드는 수정했는데 나머지 필드는 수정이 안 되고 실패로 끝나는 경우는 없다.

하나의 SQL 명령을 처리하는 경우는 DB가 트랜잭션을 보장해준다고 믿을 수 있다.

하지만 여러개의 SQL이 사용되는 작업을 하나의 트랜잭션으로 취급해야 하는 경우도 있다.

<br>

은행 계좌에서 누군가 돈을 송금했다면 입금 계좌의 돈은 늘어나야 하고 출금 계좌의 돈은 줄어들어야 한다. 이때 이체 프로그램은 DB에 두 번 요청을 보낸다. 적어도 DB 출금계좌의 잔고를 수정하는 것과 입금계좌 레코드의 잔고를 수정하는 두 개의 SQL이 필요하다.

문제는 첫 번째 SQL을 성공적으로 실행했지만 두 번째 SQL이 성공하기 전에 장애가 생겨서 작업이 중단되는 경우다. 이 때 두 작업이 하나의 트랜잭션이 되려면 앞에서 처리한 SQL도 취소시켜야 한다. 이런 취소 작업을 트랜잭션 롤백이라고 한다.

반대로 하나의 트랜잭션의 모든 작업이 정상적으로 이루어졌다면 모든 SQL의 수행 작업이 다 성공적으로 마무리됐다고 DB에 알려줘서 작업을 확정시켜야 한다. 이것을 트랜잭션 커밋이라고 한다.

**JDBC 트랜잭션의 트랜잭션 경계설정**

모든 트랜잭션은 시작하는 지점과 끝나는 지점이 있다. 시작하는 방법은 한 가지이지만 끝나는 방법은 두 가지다. 끝날때는 롤백 되거나 커밋 될 수 있다.

애플리케이션 내에서 트랜잭션이 시작되고 끝나는 위치를 트랜잭션의 경계라고 부른다.

복잡한 로직의 흐름 사이에서 정확하게 트랜잭션 경계를 설정하는 일은 매우 중요한 작업이다.

```java
Connection c = dataSource.getConnection();

c.setAutoCommit(false); // 트랜잭션 경계 시작
try {
  PreparedStatement st1 =
    c.prepareStatement("update users ...");
  st1.executeUpdate();

  PreparedStatement st2 =
    c.prepareStatement("delete users ...");
  st2.executeUpdate();

  c.commit(); // 트랜잭션 경계 끝지점 (커밋)
} catch(Exception e) {
  c.rollback(); // 트랜잭션 경계 끝지점 (롤백)
}

c.close();
```

JDBC의 트랜잭션은 하나의 Connection을 가져와 사용하다가 닫는 사이에서 일어난다. 트랜잭션의 시작과 종료는 Connection 오브젝트를 통해 이뤄지기 때문이다.

JDBC의 기본 설정은 DB 작업을 수행한 직후에 자동으로 커밋이 되도록 되어 있다. 작업마다 커밋해서 트랜잭션을 끝내버리므로 여러 개의 DB 작업을 모아서 트랜잭션을 만드는 기능이 꺼져 있는 것이다. 이 기능을 false로 설정해주면 새로운 트랜잭션이 시작되게 만들 수 있다. 트랜잭션이 한 번 시작되면 commit() 또는 rollback() 메소드가 호출될 때까지의 작업이 하나의 트랜잭션으로 묶인다.

이렇게 setAutoCommit(false)로 트랜잭션의 시작을 선언하고 commit() 또는 rollback()으로 트랜잭션을 종료하는 작업을 **트랜잭션의 경계설정**이라고 한다.

트랜잭션의 경계는 하나의 Connection이 만들어지고 닫히는 범위 안에 존재한다는 점도 기억해두자. 이렇게 하나의 DB 커넥션 안에서 만들어지는 트랜잭션을 **로컬 트랜잭션** 이라고도 한다. 2개 이상의 DB에서 만들어지는 트랜잭션은 **글로벌 트랜잭션** 이라고한다.

<br>

**UserService와 UserDao의 트랜잭션 문제**

현재까지 만든 코드에는 어디에도 트랜잭션 경계설정 코드가 존재하지 않을 뿐더러 JdbcTemplate을 사용하기 시작한 이후로부터 Connection 오브젝트도 본 적이 없다.

JdbcTemplate은 직접 만들어봤던 JdbcContext와 작업 흐름이 거의 동일하다. 템플릿 메소드 안에서 DataSource의 getConnection() 메소드를 호출해서 Connection 오브젝트를 가져오고 작업을 마치면 Connection을 확실하게 닫아주고 템플릿 메소드를 빠져나온다.

일반적으로 트랜잭션은 커넥션보다 존재 범위가 짧다. 따라서 템플릿 메소드가 호출될 때마다 트랜잭션이 새로 만들어지고 메소드를 빠져나오기 전에 종료된다. 결국 JdbcTemplate의 메소드를 사용하는 UserDao는 각 메소드마다 하나씩의 독립적인 트랜잭션으로 실행될 수 밖에 없다.

<br>

그렇다면 이전에 작성한 테스트에서도 각각의 사용자를 업데이트할 때마다 트랜잭션이 생겼다가 사라지는 것이므로 4번째 사용자를 수정하다가 예외가 발생해도 2번째 사용자의 레벨 업데이트 결과는 DB에 남아 있는 것이다.

데이터 엑세스 코드를 DAO로 만들어서 분리해놓았을 경우에는 이처럼 DAO 메소드를 호출할 때마다 하나의 새로운 트랜잭션이 만들어지는 구조가 될 수 밖에 없다. DAO 메소드에서 DB 커넥션을 매번 만들기 때문에 어쩔 수 없이 나타나는 결과다.

<br>

그렇다면 upgradeLevels()과 같이 여러 번 DB 업데이트를 해야 하는 작업을 하나의 트랜잭션으로 만들려면 어떻게 해야 할까? 하나의 트랜잭션으로 묶이려면 그 작업이 진행되는 동안 DB 커넥션도 하나만 사용돼야 한다. 

그러나 현재는 UserService에서 DB 커넥션을 다룰 수 있는 방법이 없다.

**비즈니스 로직 내의 트랜잭션 경계설정**

그렇다면 커넥션을 하나만 쓰기 위해 UserService 안에 잇는 upgradeLevels() 메소드를 커넥션을 다루고 있는 UserDao 안으로 옮겨보면 어떨까?

이 방식은 비즈니스 로직과 데이터 엑세스 로직을 한데 묶어버리는 한심한 결과를 초래한다. 지금까지 성격과 책임이 다른 코드를 분리하고, 느슨하게 연결해서 확장성을 좋게 하려고 많은 수고를 해왔는데, 여기서 트랜잭션 문제를 해결한답시고 JDBC API와 User의 업그레이드 정책을 담은 코드를 뒤죽박죽으로 만드는 건 용납할 수 없다.

<br>

이 문제를 해결하기 위해 차라리 UserDao는 같은 책임을 가지고 있고 트랜잭션의 경계설정 작업을 UserService 쪽으로 가져오게 해보자.

트랜잭션 경계를 upgradeLevels() 메소드 안에 두려면 DB 커넥션도 이 메소드 안에서 만들고 종료시킬 필요가 있다.

```java
public void upgradeLevels() throws Exception {
  // (1) DB Connection 생성
  // (2) 트랜잭션 시작
  try {
    // (3) DAO 메소드 호출
    // (4) 트랜잭션 커밋
  }
  catch(Exception e) {
    // (5) 트랜잭션 롤백
    throw e;
  }
  finally {
    // (6) DB Connection 종료
  }
}
```

트랜잭션을 사용하는 전형적인 JDBC 코드의 구조다. 그런데 여기서 생성된 Connection 오브젝트를 가지고 데이터 엑세스 작업을 진행하는 코드는 UserDao의 update() 메소드 안에 있어야 한다.

트랜잭션 때문에 DB 커넥션과 트랜잭션 관련 코드는 어쩔 수 없이 UserService로 가져왔지만, 순수한 데이터 엑세스 로직은 UserDao에 둬야 하기 때문이다.

<br>

UserService에서 만든 Connection 오브젝트를 UserDao에서 사용하려면 DAO 메소드를 호출할 때마다 Connection 오브젝트를 파라미터로 전달해줘야 한다. 결국 DAO 메소드들은 다음과 같이 변경되어야 한다.

```java
public interface UserDao {
  public void add(Connection c, User user);
  public User get(Connection c, String id);
  ...
  public void update(Connection c, User user);
}
```

이정도까지만 하면 될 것 같지만, UserService의 upgradeLevels()는 UserDao의 update()를 직접 호출하지 않는다. UserDao를 사용하는 것은 사용자별로 업그레이드 작업을 진행하는 upgradeLevel() 메소드다. 결국 UserService의 메소드 사이에도 Connection 오브젝트를 사용하도록 파라미터로 전달해줘야 한다.

이렇게 Connection 오브젝트를 전달해서 사용하면 UserService의 upgradeLevels() 안에서 시작한 트랜잭션에 UserDao의 메소드들도 참여하게 할 수 있다.

upgradeLevels() 메소드 안에서 트랜잭션의 경계 설정 작업이 일어나야 하고, 그 트랜잭션을 갖고 있는 DB 커넥션을 이용하도록 해야만 별도의 클래스에 만들어둔 DAO 내의 코드도 트랜잭션이 적용될테니 결국 이 방법을 사용할 수 밖에 없다.

**UserService 트랜잭션 경계설정의 문제점**

트랜잭션 문제는 해결할 수 있겠지만, 그 대신 여러 가지 새로운 문제가 발생한다.

- DB 커넥션을 비롯한 리소스의 깔끔한 처리를 가능하게 했던 JdbcTemplate을 더 이상 활용할 수 없다. JDBC API를 직접 사용하는 초기 방식으로 돌아가야 한다. try/catch/finally 블록은 이제 UserService 내에 존재하고, UserService의 코드는 JDBC 작업 코드의 전형적인 문제점을 그대로 가질 수 밖에 없다.
- DAO의 메소드와 비즈니스 로직을 담고 있는 UserService의 메소드에 Connection 파라미터가 추가돼야 한다. upgradeLevels()에서 사용하는 메소드의 어딘가에서 DAO를 필요로 한다면, 그 사이의 모든 메소드에 걸쳐서 Connection 오브젝트가 게속 전달돼야 한다.
- Connection 파라미터가 UserDao 인터페이스 메소드에 추가되면 UserDao는 더 이상 데이터 엑세스 기술에 독립적일 수가 없다. JPA나 하이버네이트로 UserDao의 구현 방식을 변경하려고 하면 Connection 대신 EntityManager나 Session 오브젝트를 UserDao 메소드가 전달 받도록 해야한다. 기껏 인터페이스를 사용해 DAO를 분리하고 DI를 적용했던 수고가 물거품이 되고 말 것이다.
- DAO 메소드에 Connection 파라미터를 받게 하면 테스트 코드에도 영향을 미친다. 지금까지 DB 커넥션은 전혀 신경 쓰지 않고 테스트에서 UserDao를 사용 할 수 있었는데, 이제는 테스트 코드에서 직접 Connection 오브젝트를 일일이 만들어서 DAO 메소드를 호출하도록 모두 변경해야 한다.

### 트랜잭션 동기화

스프링은 이 문제를 해결할 수 있는 멋진 방법을 제공해준다.

**Connection 파라미터 제거**

upgradeLevels() 메소드가 트랜잭션 경계설정을 해야 한다는 사실은 피할 수 없다. 따라서 그 안에서 Connection을 생성하고 트랜잭션 시작과 종료를 관리하게 한다.

대신 Connection 오브젝트를 메소드의 파라미터로 전달하다가 DAO를 호출할 때 사용하게 하는 건 피하고 싶다.

<br>

이를 위해 스프링이 제안하는 방법은 독립적인 **트랜잭션 동기화** 방식이다. 

트랜잭션 동기화란 UserService에서 트랜잭션을 시작하기 위해 만든 Conneciton 오브젝트를 특별한 저장소에 보관해두고, 이후에 호출되는 DAO의 메소드에서는 저장된 Connection을 사용하게 하는 것이다. 정확히는 DAO가 사용하는 JdbcTemplate이 트랜잭션 동기화 방식을 이용하도록 하는 것이다. 그리고 트랜잭션이 모두 종료되면, 그때는 동기화를 마치면 된다.

![image](https://github.com/gusals00/mentoring/assets/87007552/a8392383-8bb9-489f-9bf1-814f969a92cc)


1. UserService는 Connection을 생성한다.
2. 생성한 Connection을 트랜잭션 동기화 저장소에 저장해두고 Connection의 setAutoCommit(false)을 호출해 트랜잭션을 시작시킨 후에 DAO의 기능을 이용하기 시작한다.
3. 첫 번째 update() 메소드를 호출한다.
4. update() 메소드 내부에서 이용하는 JdbcTemplate 메소드에서는 가장 먼저 트랜잭션 동기화 저장소에 현재 시작된 트랜잭션을 가진 Connection 오브젝트가 존재하는지 확인한다. 2번에서 저장해둔 Connection을 발견하고 이를 가져온다.
5. 가져온 Connection을 이용해 PreparedStatement를 만들고 SQL을 실행한다. 트랜잭션 동기화 저장소에서 DB 커넥션을 가져왔을 때는 JdbcTemplate은 Connection을 닫지 않은 채로 작업을 마친다. 이렇게 트랜잭션 안에서 첫 번째 DB 작업을 마쳤다. 여전히 Connection은 열려 있고 트랜잭션은 진행 중인 채로 트랜잭션 동기화 저장소에 저장되어 있다.

 6~11. 동일하게 update()를 호출하고 트랜잭션 동기화 저장소에서 트랜잭션을 가져와 사용한다.

 12. 트랜잭션 내의 모든 작업이 정상적으로 끝났으면 Connection의 commit()을 호출해서 트랜잭션을 완료시킨다.

1. 트랜잭션 저장소가 더이상 Connection 오브젝트를 저장해두지 않도록 이를 제거한다.

위 과정 중 예외가 발생하면 Connection의 rollback()을 호출하고 종료할 수 있다.

<br>

트랜잭션 동기화 저장소는 작업 쓰레드마다 독립적으로 Connection 오브젝트를 저장하고 관리하기 때문에 다중 사용자를 처리하는 서버의 멀티쓰레드 환경에서도 충돌이 날 염려는 없다.

이렇게 트랜잭션 동기화 기법을 사용하면 파라미터를 통해 일일이 Connection 오브젝트를 전달할 필요가 없어진다. 트랜잭션의 경계설정이 필요한 upgradeLevels()에서만 Connection을 다루게 하고, 여기서 생성된 Connectio과 트랜잭션을 DAO의 JdbcTemplate이 사용할 수 있도록 별도의 저장소에 동기화하는 방법을 적용하기만 하면 된다.

<br>

더이상 로직을 담은 메소드에 Connection 타입의 파라미터가 전달될 필요도 없고, UserDao의 인터페이스에도 일일이 JDBC 인터페이스인 Connection을 사용한다고 노출할 필요가 없다.

**트랜잭션 동기화 적용**

문제는 멀티스레드 환경에서도 안전한 트랜잭션 동기화 방법을 구현하는 일이 기술적으로 간단하지 않다는 점인데, 스프링은 JdbcTemplate과 더불어 이런 트랜잭션 동기화 기능을 지원하는 간단한 유틸리티 메소드를 제공하고 있다.

아래는 트랜잭션 동기화 방법을 적용한 UserService 클래스의 코드다.

```java
private DataSource datasource;

public void setDataSource(DataSource dataSource) {
		this.dataSource = dataSource;
}

public void upgradeLevels() throws Exception{
        // 트랜잭션 동기화 관리자를 이용해 동기화 작업을 초기화한다.
        TransactionSynchronizationManager.initSynchronization();
        // DB 커넥션을 생성하고 트랜잭션을 시작한다.
        // 이후의 DAO 작업은 모두 여기서 시작한 트랜잭션 안에서 진행된다.
        // 아래 두 줄이 DB 커넥션 생성과 동기화를 함께 해준다.
        Connection c = DataSourceUtils.getConnection(dataSource);
        c.setAutoCommit(false);

        try {
            List<User> users = userDao.getAll();
            for (User user : users) {
                if (canUpgradeLevel(user)) {
                    upgradeLevel(user);
                }
            }

            c.commit();
        }catch(Exception e) {
            c.rollback();
            throw e;
        } finally {
            // 스프링 DataSourceUtils 유틸리티 메소드를 통해 커넥션을 안전하게 닫는다.
            DataSourceUtils.releaseConnection(c, dataSource);
            // 동기화 작업 종료 및 정리
            TransactionSynchronizationManager.unbindResource(this.dataSource);
            TransactionSynchronizationManager.clearSynchronization();
        }
    }
```

UserService에서 DB 커넥션을 직접 다룰 때 DataSource가 필요하므로 DataSource 빈에 대한 DI 설정을 해둬야 한다.

스프링이 제공하는 트랜잭션 동기화 관리 클래스는 TransactionSynchronizationManager다. 이 클래스를 이용해 먼저 트랜잭션 동기화 작업을 초기화하도록 요청한다.

그리고 DataSourceUtils에서 제공하는 getConnection() 메소드를 통해 DB 커넥션을 생성한다.

DataSource에서 Connection을 직접 가져오지 않고, 스프링이 제공하는 유틸리티 메소드를 쓰는 이유는 이 DataSourceUtils의 getConnection() 메소드는 Connection 오브젝트를 생성해줄 뿐만 아니라 트랜잭션 동기화에 사용하도록 저장소에 바인딩해주기 때문이다.

트랜잭션 동기화가 되어 있는 채로 JdbcTemplate을 사용하면 JdbcTemplate의 작업에서 동기화시킨 DB 커넥션을 사용하게 된다.

작업을 정상적으로 마치면 트랜잭션을 커밋해주고, 스프링 유틸리티 메소드의 도움을 받아 커넥션을 닫고 트랜잭션 동기화를 마치도록 요청하면 된다. 만약 예외가 발생하면 트랜잭션을 롤백해준다.

<br>

JDBC의 트랜잭션 경계설정 메소드를 사용해 트랜잭션을 이용하는 전형적인 코드에 간단한 트랜잭션 동기화 작업만 붙여줌으로써, 지저분한 Connection 파라미터의 문제를 깔끔히 해결했다.

**JdbcTemplate과 트랜잭션 동기화**

JdbcTemplate은 영리하게 동작하도록 설계되어 있다. 만약 미리 생성돼서 트랜잭션 동기화 저장소에 등록된 DB 커넥션이나 트랜잭션이 없는 경우에는 JdbcTemplate이 직접 DB 커넥션을 만들고 트랜잭션을 시작해서 JDBC 작업을 진행한다.

반면에 트랜잭션 동기화를 시작해놓았다면 그때부터 실행되는 JdbcTemplate의 메소드에서는 직접 DB 커넥션을 만드는 대신 트랜잭션 동기화 저장소에 들어 있는 DB 커넥션을 가져와서 사용한다. 이를 통해 이미 시작된 트랜잭션에 참여하는 것이다.

따라서 UserDao는 트랜잭션이 적용된다고 해서 따로 코드를 수정할 필요가 없다.

JDBC 코드의 try/catch/finally 작업 흐름 지원, SQLException의 예외 변환과 함께 JdbcTemplate이 제공해주는 세 가지 유용한 기능 중 하나다.

<br>

비즈니스 로직 레벨의 트랜잭션을 적용했지만 JdbcTemplate을 포기할 필요도 없고, 지저분한 Connection 파라미터를 계속 물고 다니지 않아도 된다. UserDao는 여전히 데이터 엑세스 기술에 종속되지 않는 깔끔한 인터페이스 메소드를 유지하고 있다. 그리고 테스트에서 DAO를 직접 호출해서 사용하는 것도 아무런 문제가 되지 않는다.

### 트랜잭션 서비스 추상화

지금까지 UserService와 UserDao, UserDaoJdbc는 JDBC API를 사용하고 트랜잭션을 적용했으면서도, 책임과 성격에 따라 데이터 엑세스 부분과 비즈니스 로직을 잘 분리, 유지할 수 있게 만든 뛰어난 코드다.

**기술과 환경에 종속되는 트랜잭션 경계설정 코드**

여기서 여러 DB에 걸쳐 트랜잭션 경계를 만들어야 하는 글로벌 트랜잭션 이라는 새로운 요구사항이 들어왔다고 가정하자. 

지금까지 사용한 JDBC의 Connection을 이용한 트랜잭션 방식인 로컬 트랜잭션으로는 하나의 DB Connection에 종속되기 때문에 불가능하다.

별도의 트랜잭션 관리자를 통해 트랜잭션을 관리하는 글로벌 트랜잭션 방식을 사용해야 한다.

<br>

글로벌 트랜잭션을 적용해야 트랜잭션 매니저를 통해 여러 개의 DB가 참여하는 작업을 하나의 트랜잭션으로 만들 수 있다. 또 JMS와 같은 트랜잭션 기능을 지원하는 서비스도 트랜잭션에 참여시킬 수 있다.

자바는 JDBC 외에 이런 글로벌 트랜잭션을 지원하는 트랜잭션 매니저를 지원하기 위한 API인 JTA(Java Transaction API)를 제공하고 있다.

![image](https://github.com/gusals00/mentoring/assets/87007552/5b5c12e4-00b5-4784-bb00-6b0ab34d426e)


위는 JTA를 이용해 여러개의 DB 또는 메세징 서버에 대한 트랜잭션을 관리하는 방법을 보여준다.

애플리케이션에서는 기존의 방법대로 DB는 JDBC, 메시징 서버라면 JMS같은 API를 사용해서 필요한 작업을 수행한다.

단, 트랜잭션은 JDBC나 JMS API를 사용해 직접 제어하지 않고 JTA를 통해 트랜잭션 매니저가 관리하도록 위임한다.

트랜잭션 매니저는 DB와 메시징 서버를 제어하고 관리하는 각각의 리소스 매니저와 XA 프로토콜을 통해 연결된다.

<br>

이를 통해 트랜잭션 매니저가 실제 DB와 메세징 서버의 트랜잭션을 종합적으로 제어할 수 있게 되는 것이다. JTA를 이용하여 트랜잭션 매니저를 활용하면 여러 개의 DB나 메시징 서버에 대한 작업을 하나의 트랜잭션으로 통합하는 분산 트랜잭션 또는 글로벌 트랜잭션이 가능해진다. 하나 이상의 DB가 참여하는 트랜잭션을 만들려면 JTA를 사용해야 한다는 사실을 기억해두자.

```java
// JNDI를 이용해 서버의 Transaction 오브젝트를 가져온다.
InitialContext ctx = new InitialContext();
UserTransaction tx = (UserTransaction)ctx.lookup(USER_TX_JNDI_NAME);

tx.begin();
// JNDI로 가져온 dataSource를 사용해야 한다.
Connection c = dataSource.getConnection();
try {
  // 데이터 액세스 코드
  tx.commit();
} catch (Exception e) {
  tx.rollback();
  throw e;
} finally {
  c.close();
}
```

JTA를 이용한 방법으로 바뀌긴 했지만 트랜잭션 경계 설정을 위한 구조는 JDBC를 사용했을 때와 비슷하다. Connection의 메소드 대신에 UserTransaction의 메소드를 사용한다는 점을 제외하면 트랜잭션 처리 방법은 별로 달라진 게 없다. 코드의 구조도 비슷하다.

문제는 JDBC 로컬 트랜잭션을 JTA를 이용하는 글로벌 트랜잭션으로 바꾸려면 UserService의 코드를 수정해야 한다는 점이다.

로컬 트랜잭션을 사용하면 충분한 고객에게는 JDBC를 이용한 트랜잭션 관리 코드를, 다중 DB를 위한 글로벌 트랜잭션을 필요로 하는 곳에는 JTA를 이용한 트랜잭션 관리 코드를 적용해야 한다는 문제가 생긴다.
UserService는 자신의 로직이 바뀌지 않았음에도 기술환경에 따라서 코드가 바뀌는 코드가 돼버리고 말았다.

이 상황에서 UserDao 인터페이스를 하이버네이트를 이용해 구현해야 하는 요구사항이 생기고, 그에 대한 트랜잭션 관리 코드를 구현해야 하는 요구사항이 생겼다고 가정해보자.

<br>

문제는 하이버네이트를 이용한 트랜잭션 관리 코드는 JDBC나 JTA의 코드와는 또 다르다는 것이다.
하이버네이트는 Connection을 직접 사용하지 않고 Session이라는 것을 사용하고, 독자적인 트랜잭션 관리 API를 사용한다. 그렇다면 이번엔 UserService를 하이버네이트의 Session과 Transaction 오브젝트를 사용하는 트랜잭션 경계 코드로 변경할 수 밖에 없게 됐다.

**트랜잭션 API의 의존관계 문제와 해결책**

UserDao가 DAO 패턴을 사용해 구현 데이터 엑세스 기술을 유연하게 바꿔서 사용할 수 있게 했지만 UserService에서 트랜잭션의 경계 설정을 해야 할 필요가 생기면서 다시 특정 데이터 엑세스 기술에 종속되는 구조가 되고 말았다.

JDBC에 종속적인 Connection을 이용한 트랜잭션 코드가 UserService에 등장하면서부터 UserService는 UserDaoJdbc에 간접적으로 의존하는 코드가 돼버렸다.

<br>

UserService의 코드가 특정 트랜잭션 방법에 의존적이지 않고 독립적일 수 있게 만들려면 어떻게 해야 할까? UserService 메소드 안에서 트랜잭션 경계설정 코드를 제거할 수는 없다. 하지만 특정 기술에 의존적인 Connection, UserTransaction, Session/Transaction API등에 종속되지 않게 할 방법은 있다.

트랜잭션의 경계설정을 담당하는 코드는 일정한 패턴을 갖는 유사한 구조다. 이렇게 여러 기술의 사용 방법에 공통점이 있다면 추상화를 생각해 볼 수 있다. 추상화란 하위 시스템의 공통점을 뽑아내서 분리시키는 것을 말한다. 그렇게 하면 하위 시스템이 어떤 것인지 알지 못해도, 또는 하위 시스템이 바뀌더라도 일관된 방법으로 접근 할 수가 있다.

<br>

DB에서 제공하는 DB 클라이언트 라이브러리와 API는 서로 전혀 호환이 안되는 독자적인 방식으로 만들어졌지만, SQL을 이용하는 방식이라는 공통점을 뽑아내 추상화한 것이 JDBC이다.

JDBC라는 추상화 기술이 있기 때문에 자바의 DB 프로그램 개발자는 DB의 종류에 상관없이 일관된 방법으로 데이터 액세스 코드를 작성할 수가 있다.
그렇다면 트랜잭션 코드에도 추상화를 도입할 수 있지 않을까? JDBC, JTA, 하이버네이트, JPA, JDO 심지어는 JMS도 트랜잭션 개념을 갖고 있으니 트랜잭션 경계설정 방법에서 공통점이 있을 것이다.

이 공통적인 특징을 모아서 추상화된 트랜잭션 관리 계층을 만들 수 있을 것이다. 그러면 특정 기술에 종속되지 않는 트랜잭션 경계 코드를 만들 수 있을 것이다.

**스프링의 트랜잭션 서비스 추상화**

스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공하고 있다. 이를 이용하면 특정 기술에 종속되지 않고 트랜잭션 경계 설정 작업이 가능해진다.

아래는 스프링이 제공하는 트랜잭션 추상화 계층구조이다.

![image](https://github.com/gusals00/mentoring/assets/87007552/fc4fbf43-2a6b-4bed-ac7e-96881cbf3626)


이를 UserService에 적용해보자.

```java
public void upgradeLevels() {
				// JDBC 트랜잭션 추상 오브젝트 생성
				PlatformTransactionManager transactionManager = new DataSourceTransactionManager(datasource);
        // 트랜잭션 시작
        TransactionStatus status =
                transactionManager.getTransaction(new DefaultTransactionDefinition());

        try {
            List<User> users = userDao.getAll();
            for (User user : users) {
                if (canUpgradeLevel(user)) {
                    upgradeLevel(user);
                }
            }

            transactionManager.commit(status);
        }catch(Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }
```

스프링이 제공하는 트랜잭션 경계설정을 위한 추상 인터페이스는 PlatformTransactionManager다.

JDBC의 로컬 트랜잭션을 이용한다면 PlatformTransactionManager를 구현한 DataSourceTransactionManager를 사용하면 된다.

JDBC를 이용하는 경우에는 먼저 Connection을 생성하고 나서 트랜잭션을 시작했다. 하지만 PlatformTransactionManager에서는 트랜잭션을 가져오는 요청인 getTransaction() 메소드를 호출하기만 하면 된다. 필요에 따라 트랜잭션 매니저가 DB 커넥션을 가져오는 작업도 같이 수행해주기 때문이다.

이렇게 생성된 트랜잭션은 TransactionStatus 타입의 변수에 저장된다. TransactionStatus는 트랜잭션에 대한 조작이 필요할 때 PlatformTransactionManager 메소드의 파라미터로 전달해주면 된다.

스프링의 트랜잭션 추상화 기술은 앞에서 적용해봤던 트랜잭션 동기화를 사용한다. 트랜잭션 동기화 저장소에 트랜잭션을 저장해두고 해당 트랜잭션을 이용해 데이터 엑세스 작업 수행 후 마지막에 commit과 rollback을 결정한다.

**트랜잭션 기술 설정의 분리**

이제는 JTA나 Hibernate 등으로 트랜잭션을 적용해도 UserService의 코드는 변경될 필요가 없다. 단순히 빈에 주입하는 DI만 다른 클래스로 바꿔주면 된다.

<br>

어떤 클래스든 스프링의 빈으로 등록할 때 먼저 검토해야 할 것은 싱글톤으로 만들어져 여러 쓰레드에서 동시에 사용해도 괜찮은가 하는 점이다. 상태를 갖고 있고, 멀티쓰레드 환경에서 안전하지 않은 클래스를 빈으로 무작정 등록하면 심각한 문제가 발생하기 때문이다.

스프링이 제공하는 PlatformTransactionManager의 구현 클래스는 싱글톤으로 사용이 가능하니 안심하고 스프링의 싱글톤 빈으로 등록해도 좋다.

## 서비스 추상화와 단일 책임 원칙

이제 스프링의 트랜잭션 서비스 추상화 기법을 이용해 다양한 트랜잭션 기술을 일관된 방식으로 제어할 수 있게 됐다.

설정을 고치는 것 만으로도 DB 연결 기술, 데이터 엑세스 기술, 트랜잭션 기술을 자유롭게 바꿔서 사용할 수 있게 되었다

**수직, 수평 계층구조와 의존관계**

이렇게 기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다.

UserDao와 UserService는 각각 담당하는 코드의 기능적인 관심에 따라 분리되고, 서로 불필요한 영향을 주지 않으면서 독자적으로 확장이 가능하도록 만든 것이다. 같은 애플리케이션 로직을 담은 코드이지만 내용에 따라 분리했다. 같은 계층에서 **수평적으로 분리**했다고 볼 수 있다.

트랜잭션의 추상화는 이와는 좀 다르다. 애플리케이션의 비즈니스 로직과 그 하위에서 동작하는 로우레벨의 트랜잭션 기술이라는 아예 다른 계층의 특성을 갖는 코드를 분리한 것이다.

![image](https://github.com/gusals00/mentoring/assets/87007552/87edbb45-257b-4c93-a723-8b3815ea00ea)


위는 지금까지 만들어진 사용자 관리 모듈의 의존관계를 나타낸다.

UserService와 UserDao는 애플리케이션의 로직을 담고 있는 애플리케이션 계층이다.

UserDao는 데이터를 어떻게 가져오고 등록할 것인가에 대한 데이터 엑세스 로직을 담고 있다. UserService는 순수하게 사용자 관리 업무의 비즈니스 로직을 담고 있다. 

<br>

UserDao와 UserService는 인터페이스와 DI를 통해 연결됨으로써 결합도가 낮아졌다. 결합도가 낮다라는건 데이터 엑세스 로직이 바뀌거나, 심지어는 데이터 엑세스 기술이 바뀐다고 할지라도 UserService의 코드에는 영향을 주지 않는다는 것이다. 서로 독립적으로 확장될 수 있다.

또 UserDao는 DB 연결을 생성하는 방법에 대해 독립적이다. DataSource 인터페이스와 DI를 통해 추상화된 방식으로 로우레벨의 DB 연결 기술을 사용하기 때문이다.

UserService와 트랜잭션 기술과도 스프링이 제공하는 PlatformTransactionManager 인터페이스를 통한 추상화 계층을 사이에 두고 사용하게 했기 때문에, 구체적인 트랜잭션 기술에 독립적인 코드가 됐다. 설령 서버가 바뀌고 로우레벨의 트랜잭션 기술이 변경된다고 해도 UserService는 영향을 받지 않는다.

<br>

UserDao와 DB 연결 기술, UserService와 트랜잭션 기술의 결합도가 낮은 분리는 애플리케이션 코드를 로우레벨의 기술 서비스와 환경에서 독립시켜준다.

애플리케이션 로직의 종류에 따른 수평적인 구분이든, 로직과 기술이라는 수직적인 구분이든 모두 결합도가 낮으며, 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들 수 있는 데는 스프링의 DI가 중요한 역할을 하고 있다.

DI의 가치는 이렇게 관리, 책임, 성격이 다른 코드를 깔끔하게 분리하는 데 있다.

**단일 책임 원칙**

이런 적절한 분리가 가져오는 특징은 객체지향 설계의 원칙 중의 하나인 **단일 책임 원칙**으로 설명할 수 있다.

단일 책임 원칙은 하나의 모듈은 한 가지 책임을 가져야 한다는 의미다. 하나의 모듈이 바뀌는 이유는 한 가지여야 한다고 설명할 수도 있다.

<br>

UserService에 JDBC Connection의 메소드를 직접 사용하는 트랜잭션 코드가 들어 있었을 때를 생각해보자. UserService는 어떻게 사용자 레벨을 관리할 것인가와 어떻게 트랜잭션을 관리할 것인가라는 두 가지 책임을 갖고 있었다.

두 가지 책임을 가진다는 것은 UserService 코드가 수정되는 이유가 두 가지라는 뜻이다.

위와 같이 두 가지 책임을 가지는 순간 단일 책임 원칙을 지키지 못하는 것이다.

<br>

하지만 이렇게 트랜잭션 서비스의 추상화 방식을 도입하고, 이를 DI를 통해 외부에서 제어하도록 만들고 나서는 어떻게 됐을까? 이제 UserService가 바뀔 이유는 한 가지 뿐이다.

사용자 관리 로직이 바뀌거나 추가되지 않는 한 UserService의 코드에는 손댈 이유가 없다. 따라서 단일 책임 원칙을 충실하게 지키고 있다고 말할 수 있다.

**단일 책임 원칙의 장점**

이렇게 단일 책임 원칙을 지키는 코드가 되면 어떤 장점이 있을까?

어떤 변경이 필요할 때 수정 대상이 명확해진다. 기술이 바뀌면 기술 계층과의 연동을 담당하는 기술 추상화 계층의 설정만 바꿔주면 된다. 데이터를 가져오는 테이블의 이름이 바뀌었다면 데이터 엑세스 로직을 담고 있는 UserDao를 변경하면 된다.

<br>

DAO가 각각 수백 개가 되고, 서비스 클래스도 그만큼 많다고 생각해보자. 서비스 하나가 여러 개의 DAO를 사용하는 경우가 많아질 것이다. 의존관계가 매우 복잡해진다.

그런데 DAO 하나를 수정할 경우 그에 의존하고 있는 서비스 클래스도 같이 수정해야 하는 구조라면 어떻게 될까?

기술적인 수정사항도 마찬가지다. 애플리케이션 계층의 코드가 특정 기술에 종속돼서 기술이 바뀔 때마다 코드의 수정이 필요하다면 어떨지 상상해보자.

단지 수정하는 작업량만의 문제가 아니다. 많은 코드를 수정하는 작업에선 그만큼 실수가 일어날 확률이 높다. 치명적인 버그가 도입될 가능성도 있다. 개발 중이 아니라 운영 중인 코드에 이런 수정이 필요하다면 엄청난 부담이 될 것이다.

그래서 적절하게 책임과 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 다양한 추상화 기법을 도입하고, 애플리케이션 로직과 기술/환경을 분리하는 등의 작업은 갈수록 복잡해지는 앤터프라이즈 애플리케이션에는 반드시 필요하다. 이를 위한 핵심적인 도구가 바로 스프링이 제공하는 DI다.스프링이 제공하는 DI가 없었다면 인터페이스를 도입해서 나름 추상화를 했더라도 적지 않은 코드 사이의 결합이 남아 있게 된다.

<br>

객체지향 설계와 프로그래밍 원칙은 서로 긴밀하게 관련이 있다. 단일 책임 원칙을 잘 지키는 코드를 만들려면 인터페이스를 도입하고 이를 DI로 연결해야 하며, 그 결과로 단일 책임 원칙뿐 아니라 개방 폐쇄 원칙도 잘 지키고, 모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고, 같은 이유로 변경이 단일 책임에 집중되는 응집도 높은 코드가 나오게 된다.

지금까지 코드를 개선하고 발전시켜온 과정을 생각해보면 한 번도 DI가 빠진 적이 없었다. 이렇게 스프링의 의존관계 주입 기술인 DI는 모든 스프링 기술의 기반이 되는 핵심 엔진이자 원리이며, 스프링이 지지하고 지원하는, 좋은 설계와 코드를 만드는 모든 과정에서 사용되는 가장 중요한 도구다.

스프링을 DI 프레임워크라고 부르는 이유는 외부 설정정보를 통한 런타임 오브젝트 DI라는 단순한 기능을 제공하기 때문이 아니다. 오히려 스프링이 DI에 담긴 원칙과 이를 응용하는 프로그래밍 모델을 자바 엔터프라이즈 기술의 많은 문제를 해결하는 데 적극적으로 활용하고 있기 때문이다. 또 스프링과 마찬가지로 스프링을 사용하는 개발자가 만드는 코드 또한 이런 DI를 활용해서 깔끔하고 유연한 코드와 설계를 만들어낼 수 있도록 지원하고 지지해주기 때문이다.

## 정리

- 비즈니스 로직을 담은 코드는 데이터 엑세스 로직을 담은 코드와 깔끔하게 분리되는 것이 바람직하다. 비즈니스 로직 코드 또한 내부적으로 책임과 역할에 따라서 깔끔하게 메소드로 정리돼야 한다.
- 이를 위해서는 DAO의 기술 변화에 서비스 계층의 코드가 영향을 받지 않도록 인터페이스와 DI를 잘 활용해서 결합도를 낮춰줘야 한다.
- DAO를 사용하는 비즈니스 로직에는 단위 작업을 보장해주는 트랜잭션이 필요하다.
- 트랜잭션의 시작과 종료를 지정하는 일을 트랜잭션 경계설정이라고 한다. 트랜잭션 경계설정은 주로 비즈니스 로직 안에서 일어나는 경우가 많다.
- 시작된 트랜잭션 정보를 담은 오브젝트를 파라미터로 DAO에 전달하는 방법은 매우 비효율적이기 때문에 스프링이 제공하는 트랜잭션 동기화 기법을 활용하는 것이 편리하다.
- 자바에서 사용되는 트랜잭션 API의 종류와 방법은 다양하다. 환경과 서버에 따라서 트랜잭션 방법이 변경되면 경계설정 코드도 함께 변경돼야 한다.
- 트랜잭션 방법에 따라 비즈니스 로직을 담은 코드가 함께 변경되면 단일 책임 원칙에 위배되며, DAO가 사용하는 특정 기술에 대해 강한 결합을 만들어낸다.
- 트랜잭션 경계설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 하려면 스프링이 제공하는 트랜잭션 서비스 추상화를 이용하면 된다.
- 서비스 추상화는 로우레벨의 트랜잭션 기술과 API의 변화에 상관없이 일관된 API를 가진 추상화 계층을 도입한다.
- 서비스 추상화는 테스트하기 어려운 JavaMail과 같은 기술에도 적용할 수 있다. 테스트를 편리하게 작성하도록 도와주는 것만으로도 서비스 추상화는 가치가 있다.
- 테스트 대상이 사용하는 의존 오브젝트를 대체할 수 있도록 만든 오브젝트를 테스트 대역이라고 한다.
- 테스트 대역은 테스트대상 오브젝트가 원활하게 동작할 수 있도록 오두면서 테스트를 위해 간접적인 정보를 제공해주기도 한다.
- 테스트 대역 중에서 테스트 대상으로부터 전달 받은 정보를 검증할 수 있도록 설계된 것을 목 오브젝트라고 한다.
