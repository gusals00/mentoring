# 스프링 프로젝트 시작하기

## 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션

스프링으로 만들 수 있는 애플리케이션의 종류에는 제한이 없다. 자바 언어를 사용하는 모든 종류의 프로젝트라면 어디든 사용할 수 있다. 

웹을 이용하는 자바 엔터프라이즈 시스템 개발에도 사용할 수 있고, 스윙이나 이클립스 RCP로 만드는 독립형 프로그램에도 적용 가능하다. 심지어 스프링을 핵심 엔진으로  사용하는 엔터프라이즈 미들웨어 제품도 있다.

<br>

하지만 스프링은 주로 자바 엔터프라이즈 환경에서 동작하는 애플리케이션을 개발하는 목적으로 사용된다. 서버에서 동작하는 엔터프라이즈 애플리케이션을 제외한 다른 형태의 애플리케이션에 스프링을 제대로 적용하기 위해서는 SpringRCP 프로젝트나 Spring.ME 같은 추가적인 스프링 지원기술이 필요하다.

### 클라이언트와 백엔드 시스템

가장 많이 사용되는 구조는 클라이언트가 웹 브라우저이고 백엔드 시스템이 DB인 구성이다. 간단히 ‘DB를 사용하는 웹 애플리케이션’이라고 한다.

웹 클라이언트와 DB가 사용되지 않는 시스템은 거의 없으니, 이를 스프링이 사용되는 애플리케이션의 기본 구조라고 생각할 수도 있다.

그런 면에서 스프링의 주요 기능은 웹 브라우저를 클라이언트로 하고 DB에 데이터를 저장, 조회하는 데 집중되어 있다.

<br>

그렇다고 꼭 클라이언트는 웹 브라우저여야 하며 백엔드 시스템은 DB를 이용해야 하는 것만은 아니다. HTML을 사용하는 표준 웹 클라이언트 외에도 Flex나 X 인터넷 제품처럼 독립적으로 강력한 기능을 가진 RIA 클라이언트가 사용되기도 한다. 또는 HTTP 프로토콜을 이용해 통신하는 다른 엔터프라이즈 시스템일 때도 있다.

자바 서버가 받아들일 수 있는 방식으로 요청을 보내기만 한다면 어떤 종류의 클라이언트든 상관없다.

![image](https://github.com/gusals00/mentoring/assets/87007552/247ed072-d1c1-49dd-816a-933aec2b2b69)


### 애플리케이션 서버

스프링으로 만든 애플리케이션을 자바 서버환경에 배포하려면 JavaEE 서버가 필요하다.

JavaEE 표준을 따르는 애플리케이션 서버는 크게 두 가지로 구분할 수 있다. 하나는 JavaEE의 대부분의 표준 기술을 지원하고 다양한 형태의 모듈로 배포가 가능한 완전한 웹 애플리케이션 서버(WAS)이고, 다른 하나는 웹 모듈의 배포만 가능한 경량급 WAS 또는 서블릿/JSP 컨테이너이다.

<br>

- 경량급 WAS/ 서블릿 컨테이너
    - 스프링은 기본적으로 톰캣이나 제티 같은 가벼운 서블릿 컨테이너만 있어도 충분하다. EJB나 리소스 커넥터, WAS가 제공하는 분산 서비스 등이 굳이 필요하지 않다면 서블릿 컨테이너로도 엔터프라이즈 애플리케이션에 필요한 핵심기능을 모두 이용할 수 있다.
- WAS
    - 물론 고가의 WAS를 사용하면 그만큼 장점이 있다. 성능 면에서는 대단히 낫지 않더라도 미션 크리티컬한 시스템에서 요구하는 고도의 안정성이나 고성능 시스템에서 필수적인 안정적인 리소스 관리, 레거시 시스템의 연동이나 기존 EJB로 개발된 모듈을 함께 사용하는 등의 필요가 있다면 상용 또는 오픈소스 WAS를 이용할 수 있다.
    - 또 WAS는 상대적으로 관리 기능이나 모니터링 기능이 뛰어나서 여러 대의 서버를 동시에 운영할 때 유리한 점이 많다.

**스프링소스 tcServer**

실제로 개발환경과 운영환경에서 가장 많이 사용되는 자바 서버는 웹 모듈만 지원하는 서블릿 컨테이너인 아파치 톰캣이다.

톰캣 전문가인 이들이 중심이 돼서 톰캣을 기반으로 엔터프라이즈 스프링 애플리케이션에 최적화된 경량급 애플리케이션 서버인 tcServer를 개발했다. tcServer를 이용하면 기존 톰캣에서는 아쉬웠던 고급 서버 관리 기능, 배포 기능과 진단 기능을 포함해서 톰캣 전문가에게 받는 기술지원도 함께 제공받을 수 있다.

### 스프링 애플리케이션의 배포 단위

스프링으로 만든 애플리케이션은 다음 세 가지 단위로 배포할 수 있다.

- 독립 웹 모듈
    - 스프링은 보통 war로 패키징된 독립 웹 모듈로 배포된다. 톰캣 같은 서블릿 컨테이너를 쓴다면 독립 웹 모듈이 유일한 방법이다.
- 엔터프라이즈 애플리케이션
    - 경우에 따라선 확장자가 ear인 엔터프라이즈 애플리케이션으로 패키징해서 배포할 수도 있다. 하나 이상의 웹 모듈과 별도로 분리된 공유 가능한 스프링 컨텍스트를 엔터프라이즈 애플리케이션으로 묶어줄 수 있다.
- 백그라운드 서비스 모듈
    - rar 패키징 방법도 있다. rar은 리소스 커넥터를 만들어 배포할 때 사용하는 방식인데, 만약 스프링으로 만든 애플리케이션이 UI를 가질 필요는 없고 서버 내에서 백그라운드 서비스처럼 동작할 필요가 있다면 rar 모듈로 만들어 배포할 수 있다. 이때는 WAS가 반드시 필요하다.

## 애플리케이션 아키텍처

클라이언트와 백엔드 시스템의 종류와 사용 기술, 연동 방법을 결정했다면 시스템 레벨의 아키텍처는 대략 구성된 셈이다. 다음으로 결정할 사항은 스프링 웹 애플리케이션의 아키텍처다.

<br>

아키텍처는 여러 가지 방식으로 정의되고 이해될 수 있는 용어다. 가장 단순한 정의를 보자면 여러 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것이라고 할 수 있다.

아키텍처는 단순히 정적인 구조를 나타내는 것으로만 생각하기 쉽지만 실제로는 그 구조에서 일어나는 동적인 행위와 깊은 관계가 있다.

### 계층형 아키텍처

성격이 다른 모듈이 강하게 결합되어 한데 모여 있으면 한 가지 이유로 변경이 일어날 때 그와 상관이 없는 요소도 함께 영향을 받게 된다. 따라서 불필요한 부분까지 변경이 일어나고 그로 인해 작업은 더뎌지고 오류가 발생할 가능성이 높아진다. 따라서 인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업이 필요하다.

**아키텍처와 SoC**

지금까지는 주로 오브젝트 레벨에서 이런 분리의 문제에 대해 생각해봤다. 이런 원리는 아키텍처 레벨에서 좀 더 큰 단위에 대해서도 동일하게 적용할 수 있다.

애플리케이션을 구성하는 오브젝트들을 비슷한 성격과 책임을 가진 것들끼리 묶을 수 있다. 

예를 들면 데이터 엑세스 로직을 담당하는 DAO들은 하나의 단위로 생각해도 좋다. 또 비즈니스 로직을 구현해놓은 비즈니스 서비스 오브젝트들도 같은 성격으로 묶을 수 있다.

<br>

이렇게 성격이 다른 것은 아키텍처 레벨에서 분리해주는 것이 좋다. 이렇게 분리된 각 오브젝트는 독자적으로 개발과 테스트가 가능해서 개발과 변경 작업이 모두 빨라질 수 있다. 또 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연하다.

이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 **계층형 아키텍처**라고 부른다. 보통 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 **3계층 애플리케이션**이라고도 한다.

<br>

**3계층 아키텍처와 수직 계층**

3계층 아키텍처는 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할을 하는 데이터 엑세스 계층, 비즈니스 로직을 담고 있는 서비스 계층, 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 프레젠테이션 계층으로 구분한다.

![image](https://github.com/gusals00/mentoring/assets/87007552/866ee6e8-1e33-41e9-b816-6b19bf3c2f2f)


- 데이터 엑세스 계층
    - 데이터 엑세스 계층은 DAO 계층이라고도 불린다. DAO 패턴을 보편적으로 사용하기 때문이다.
    - 또한 DB 외에도 ERP, 레거시 시스템, 메인프레임 등에 접근하는 역할을 하기 때문에 EIS 계층이라고도 한다.
    - 또 외부 시스템을 호출해서 서비스를 이용하는 것은 기반(infrastructure) 계층으로 따로 분류하기도 한다.
    - 기본 3계층은 기술 계층보다는 역할에 따라 구분한 것이므로 보통 그림으로 나타낼 때도 가로로 배열한다. 반면에 같은 책임을 가졌지만 추상화 레벨에 따라 구분하는 경우는 세로로 배열해서 표현한다.
    
    ![image](https://github.com/gusals00/mentoring/assets/87007552/f99c113a-f4b3-42e3-b63d-140a1aa5dc68)

    
- 서비스 계층
    - 잘 만들어진 서비스 계층 클래스는 이상적인 POJO로 작성된다.
    - POJO로 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연하게 확장할 수 있다.
    - 서비스 계층은 DAO 계층을 호출하고 이를 활용해서 만들어진다. 때로는 데이터 엑세스를 위한 기능 외에 서버나 시스템 레벨에서 제공하는 기반 서비스를 활용할 필요도 있다.
    - 메일 또는 메세징 서비스를 이용하는 것이 대표적인 예다. 이런 기반 서비스는 3계층 어디에서나 접근이 가능하도록 만들 수도 있고, 반드시 서비스 계층을 통해 사용되도록 제한할 수도 있다.
    - 서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없다. 기술 API를 직접 다루는 코드가 아니기 때문에 기술에 일관된 방식으로 접근하게 하거나 편하게 사용하게 해주는 추상화는 필요 없기 때문이다.
    - 원칙적으로는 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안 된다. 서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어서 특정 구현과 기술에 대한 종속성을 제거하거나 AOP를 통해서 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용해야 한다.
    
    ![image](https://github.com/gusals00/mentoring/assets/87007552/ea26b6e0-8610-46ed-9001-b5f141f13f5d)

    
- 프레젠테이션 계층
    - 엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다.
    - 프레젠테이션 계층은 다른 계층과 달리 클라이언트까지 그 범위가 확장될 수도 있다. 초기 클라이언트 모델은 단순히 HTML로 만들어진 결과를 사람이 볼 수 있도록 그려주고, 폼을 통해 입력받은 값을 전달하는 것이었다. 하지만 최근에는 점점 많은 프레젠테이션 로직이 클라이언트로 이동하고 있다. RIA라고 불리는 기술이나 SOFEA 아키텍처가 대표적인 예다.

**계층형 아키텍처 설계의 원칙**

각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 한다.

각 계층은 자신의 역할에만 충실해야 하고 자신과 관련된 기술이 아닌 다른 기술 API를 사용을 삼가해야 한다.

각 계층이 자신의 책임에 충실하게 작성되어 있다면 필요한 그 밖의 작업은 인터페이스를 통해 다른 계층에 요청하게 하고, 계층 간에 사용되는 인터페이스 메소드에는 특정 계층의 기술이 최대한 드러나지 않게 해야 한다.

```java
public ResulteSet findUsersByName(String name) throw SQLException;
```

위와 같은 메소드는 ResultSet을 반환하기 때문에 JDBC라는 특정 데이터 엑세스 계층에 종속된다.

또한 체크 예외로 인해 서비스 계층에서 SQLException을 해석해서 예외상황을 분석하고 이를 처리하는 코드를 만들어야 한다. 특정 데이터 엑세스 계층의 구현에 종속되는 강한 결합이 만들어진다.

계층 간에 강한 결합이 생기면 유연성이 떨어지기 때문에 각 계층의 내부 구현이 변화되면 다른 계층의 코드도 함께 수정해줘야 한다.

```java
public List<User> findUsersByName(String name) throw DataAccessException;
```

따라서 위와 같은 메소드로 수정해야 한다. 결과는 이렇게 특정 계층에 종속되지 않는 단순한 오브젝트의 형태로 전달해야 한다. 또 데이터 엑세스 예외와 같이 특별한 경우에만 전달될 가능성이 있는 것은 런타임 예외로 만들어야 한다.

<br>

또, 흔히 저지르는 실수 중 하나는 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하는 것이다. 서블릿의 HttpServletRequest나 HttpSession 같은 타입을 서비스 계층 메소드의 파라미터 타입으로 사용하면 안된다.

계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 오브젝트 형태로 변환해줘야 한다.

### 애플리케이션 정보 아키텍처

엔터프라이즈 시스템은 본질적으로 동시에 많은 작업이 빠르게 수행돼야 하는 시스템이다.

엔터프라이즈 애플리케이션은 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지한다. 애플리케이션의 주요 상태정보는 클라이언트나 백엔드 시스템에 분산돼서 보관된다. 비교적 장기간 보관되는 상태정보는 주로 DB나 메인프레임 같은 EIS 백엔드 시스템에 저장된다.

하나의 업무 작업이 여러 번의 요청과 페이지에 걸쳐 일어나는 경우에 유지돼야 하는 임시 상태정보는 클라이언트에 일시적으로 보관되기도 하고 서버의 사용자별 세션 메모리에 저장되기도 한다.

<br>

이렇게 애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다. 엔터프라이즈 애플리케이션에 존재하는 정보를 **단순히 데이터로 다루는 경우**와 **오브젝트로 다루는 경우** 두 가지 기준으로 구분해볼 수 있다.

<br>

데이터 중심 아키텍처는 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조다. DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고 그 값을 취급하는 코드를 만들어 로직을 구현하고 값을 그대로 프레젠테이션 계층의 뷰와 연결해주는 것이다.

이런 방식은 객체지향 기술이나 언어를 사용하지 않던 시절의 엔터프라이즈 애플리케이션과 크게 다를 바 없다. 데이터 중심 설계의 특징은 비즈니스 로직이 DB 내부의 저장 프로시저나 SQL에 담겨 있는 경우가 많다는 점이다.

데이터 중심 아키텍처는 핵심 비즈니스 로직을 어디에 많이 두는지에 따라서 DB에 무게를 두는 구조와 서비스 계층의 코드에 무게를 두는 구조로 구분할 수 있다.

<br>

**DB/SQL 중심의 로직 구현 방식**

데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다. 예를 들어 사용자의 이름으로 사용자 정보를 검색해서 일치하는 사용자의 아이디,비밀번호,이름 등을 보여주는 작업이 있다고 하자.

이것이 하나의 업무 단위가 되면 모든 계층의 코드가 이 기준에 맞춰서 만들어진다. 사용자 조회라는 단위 업무를 위해서만 존재하는 각 계층의 코드가 만들어진다는 뜻이다.

![image](https://github.com/gusals00/mentoring/assets/87007552/38fbac9b-362f-449f-8fe5-7f5795ffb6aa)


이런 식의 개발 방법과 아키텍처는 자바 기술이 발전하기 이전의 엔터프라이즈 시스템에서 흔히 발견할 수 있다. 굳이 자바라는 객체지향 언어와 프로그래밍 기술을 사용하지 않더라도 3계층 구조로 만드는 전통적인 개발 방법에서, 또는 서비스 계층이 별 의미가 없으므로 주요 로직을 클라이언트의 독립 프로그램에 담아두고 DB 처리 로직만 DB에 분리해둔 2계층 구조에서도 비슷하게 발견할 수 있다.

이런 방식은 개발하기 쉽다는 장점이 있다. 하지만 이런 방식은 자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락시키는 것이다. 자바의 오브젝트는 단지 HTTP 서비스 채널을 만들어주고 JDBC를 이용해 DB 기능을 사용하게 하는 스크립트 정도로 역할이 축소된다.

또한 이런 개발 방식은 변화에 매우 취약하다. 객체지향의 장점이 별로 활용되지 못하는데다 각 계층의 코드가 긴밀하게 연결되어 있기 때문이다. 중복을 제거하기도 쉽지 않다.

로직을 DB보다는 애플리케이션으로 가져오는 편이 유리한 점이 많다. 비용도 저렴해지고 안정성도 높아지고 코드를 검증하기도 편하다. 게다가, SQL이나 저장 프로시저에 담긴 로직은 테스트하기 힘들다.

<br>

**거대한 서비스 계층 방식**

DB에서 가져온 데이터가 애플리케이션에 흘러다니는 정보의 중심이 되는 아키텍처이긴 하지만 DB에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의 비중을 높이는 방법이 있다.

DB에는 부하가 걸리지 않도록 저장 프로시저나 복잡한SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 것이다.

<br>

여전히 SQL의 결과를 그대로 담고 있는 단순한 오브젝트나 맵을 이용해 데이터를 주고받지만, 많은 비스니스 로직을 서비스 계층의 오브젝트로 옮겨왔기 때문에 애플리케이션 코드의 비중이 커진다. 그만큼 구조는 단순해지고 객체지향 개발의 장점을 살릴 기회가 많아진다.

상대적으로 단순한 DAO 로직을 사용하고, 비즈니스 로직의 대부분을 서비스 계층에 집중하는 이런 접근 방법은 결국 거대한 서비스 계층을 만들게 된다.

![image](https://github.com/gusals00/mentoring/assets/87007552/3460ae05-31d3-41dd-a1e5-aeb226312e1a)


거대 서비스 계층의 장점은 애플리케이션의 코드에 비즈니스 로직이 담겨 있기 때문에 자바 언어의 장점을 활용해 로직을 구현할 수 있고 테스트도 수월하다는 점이다. 또한 DAO가 다루는 SQL이 복잡하지 않고 프레젠테이션 계층의 뷰와 1:1로 매핑되지 않아도 되기 때문에 일부 DAO 코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다.

하지만 데이터 엑세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다. 그래서 계층 간의 결합도가 여전히 크다. 서비스 계층의 메소드는 크기가 큰 업무 트랜잭션 단위로 만들어지기 때문에 비슷한 기능의 코드가 여러 메소드에서 중복돼서 나타나기 쉽다.

<br>

데이터 중심 아키텍처의 특징은 계층 사이의 결합도가 높은 편이고 응집도는 떨어진다는 점이다. 화면을 중심으로 하는 업무 트랜잭션 단위로 코드가 모이기 때문에 처음엔 개발하기 편하지만 중복이 많아지기 쉽고 장기적으로 코드를 관리하고 발전시키기 힘들다는 단점이 있다.

### 오브젝트 중심 아키텍처

오브젝트 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용한다는 것이다.

그래서 오브젝트 중심 아키텍처는 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용한다. 대개 도메인 모델은 DB와 엔티티 설계에도 반영되기 때문에 관계형 DB의 엔티티 구조와도 유사한 형태일 가능성이 높다.

<br>

이렇게 오브젝트를 만들어두고 오브젝트 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것이 오브젝트 중심 아키텍처다.

<br>

오브젝트 방식에서는 데이터 중심 아키텍처와 다르게 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담긴다. 도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖는다. 따라서 도메인 모델이 반영된 도메인 오브젝트도 전 계층에서 일관된 구조를 유지한 채로 사용될 수 있다.

<br>

**도메인 오브젝트를 사용하는 코드**

오브젝트 중심 방식에서 비즈니스 로직의 구현이 얼마나 간단하고 명확한지 살펴보자.

어떤 카테고리에 포함된 상품의 모든 가격을 계산해야 하는 로직이 필요하다면 서비스 계층의 오브젝트 안에 아래와 같은 메소드를 만들어 사용하면 된다. 어떤 DAO를 이용해서 Category를 가져왔는지는 중요하지 않다.

```java
public int calcTotalOfProductPrice(Category cate) {
		int sum = 0;
		for(Product prd : cate.getProducts()) {
				sum += prd.getPrice();
		}
		return sum;
}
```

모데인 모델을 알고 있다면 calcTotalOfProductPrice() 메소드가 무슨 작업을 하는지 이해하기 어렵지 않다. 테스트를 만들어 검증하기도 간단하고, 로직이 변경될 때 코드를 수정하기도 수월하다.

<br>

오브젝트 구조로 정보를 갖고 있으면 어떤 식으로든 활용하기 편리하다. 자바에서는 ‘.’을 이용해 레퍼런스 변수를 따라가면 관련된 정보를 손쉽게 이용할 수 있다. Product 오브젝트가 하나 주어졌을 때, 해당 Product의 Category에는 상품이 모두 몇 개가 있는지 알고 싶다면 다음과 같이 간단한 코드를 사용할 수 있다.

```java
int count = product.getCategory().getProducts().size();
```

**도메인 오브젝트 사용의 문제점**

일관된 의미를 가지고 유연하며 애플리케이션 전반에 공유 가능한 도메인 모델을 따르는 오브젝트로 정보를 다루면 많은 장점이 있다. 코드는 이해하기 쉽고 로직을 작성하기도 수월하다.

하지만 단점도 있다. 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금은 손해를 감수해야 할 수도 있다. DAO는 비즈니스 로직의 사용 방식을 알지 못하므로, 도메인 오브젝트의 모든 필드 값을 다 채워서 전달하는 경우가 대부분이기 때문에 낭비일 수도 있다.

<br>

이런 문제를 해결하는 접근 방법은 여러 가지가 있다.

지연된 로딩(lazy loading) 기법을 이용하면 일단 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 다이내믹하게 DB에서 다시 읽어올 수 있다.

물론 도메인 오브젝트를 사용하는 코드는 이런 사실을 전혀 의식하지 않고 처음부터 모든 오브젝트의 정보가 다 제공된다고 생각하고 작성하면 된다.

필드가 너무 많은 테이블이 있다면 그중에서 자주 사용되는 것을 골라내서 별도의 오브젝트로 정의해두고 필요에 따라 구분해서 사용하게 할 수 있다. 물론 그에따라 DAO 메소드가 추가돼야 하고 어느 DAO를 사용할지를 서비스 계층에서 알고 있어야 하기 때문에 약하긴 하지만 계층 사이의 결합이 발생한다.

<br>

사실 가장 이상적인 방법은 RDB매핑(ORM) 기술을 사용하는 것이다. 이런 데이터 엑세스 기술은 기본적으로 지연된 로딩 기법 등을 제공해주기 때문에 번거로운 코드를 만들지 않고도 도메인 오브젝트의 생성을 최적화할 수 있다.

그래서 도메인 오브젝트를 사용하는 오브젝트 중심 아키텍처에서는 가능하다면 ORM과 같은 오브젝트 중심 데이터 엑세스 기술을 사용하는 것을 권장한다.

<br>

도메인 오브젝트는 자바오브젝트다. 오브젝트는 원래 데이터를 저장하기 위해서만 사용하는 것이 아니다. 내부의 정보를 이용하는 기능도 함께 갖고 있어야 한다. 클래스는 속성과 행위의 조합이다.

오브젝트 중심 아키텍처는 오브젝트의 활용 방법을 기준으로 다시 구분해볼 수 있다.

<br>

**빈약한 오브젝트 방식**

도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 갖고 있지 않다면 이는 온전한 오브젝트라고 보기 힘들다. 그래서 이런 오브젝트를 빈약한 오브젝트라고 부른다.

물론 이렇게라도 도메인 모델을 반영한 오브젝트에 정보를 담아 활용하는 편이 도메인 오브젝트를 전혀 사용하지 않는 것보다는 훨씬 낫다.

<br>

도메인 오브젝트에 넣을 수 있는 기능은 어떤 것일까? 도메인 모델을 반영해서 만들어진 도메인 오브젝트이니 그 기능이라고 하면 도메인의 비즈니스 로직이라고 볼 수 있다.

그렇다면 빈약한 도메인 오브젝트 방식에서는 비즈니스 로직이 어디에 존재할까? 바로 서비스 계층이다. 사실 다루는 정보의 구조가 다를 뿐이지 빈약한 도메인 오브젝트 방식은 데이터 중심 아키텍처의 거대 서비스 계층구조와 비슷하다.

하지만 비즈니스 로직이 복잡하지 않다면 가장 만들기 쉽고 3계층 구조의 특징을 잘 살려서 개발할 수 있는 유용한 아키텍처다.

![image](https://github.com/gusals00/mentoring/assets/87007552/78427da7-e71d-4b3c-8066-4f70a2163ea3)

<br>


**풍성한 도메인 오브젝트 방식**

풍성한 도메인 오브젝트 또는 영리한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특징을 잘 사용할 수 있도록 개선한 것이다.

어떤 비즈니스 로직은 특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있다. 이런 로직을 서비스 계층의 코드가 아니라 도메인 오브젝트에 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것이다.

<br>

앞에서 서비스 계층의 코드로 만들었던 calcTotalOfProductPrice()는 Category라는 오브젝트와 그 관련 Product의 정보만을 사용하는 간단한 로직이다. 이것을 굳이 서비스 계층의 메소드에 별도로 만들지 않고 Category 클래스의 메소드에 넣을 수도 잇다.

이렇게 도메인 오브젝트 안에 로직을 담아두면 이 로직을 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높다. 데이터와 그것을 사용하는 기능이 한곳에 모여있기 때문이다.

<br>

풍성한 도메인 오브젝트 방식은 도메인 오브젝트를 사용한다는 면에서 빈약한 도메인 오브젝트 방식과 비슷하지만, 실제 작성된 코드를 살펴보면 훨씬 간결하고 객체지향적이라는 사실을 알 수 있다. 객체지향 분석과 설계를 통해 만들어진 도메인 모델의 정보를 정적인 구조뿐 아니라 동적인 동작 방식에도 적극 활용할 수 있다.

물론 도메인 오브젝트에 비즈니스 로직을 넣는다고 해서 비즈니스 로직을 담고 있던 서비스 계층 오브젝트가 필요 없어지는 건 아니다. 여전히 서비스 계층은 필요하며 중요한 역할을 하고 있다. 여러 종류의 도메인 오브젝트의 기능을 조합해서 복잡한 비즈니스 로직을 만들었다면 특정 도메인 오브젝트에 넣기는 힘들다. 이런 비즈니스 로직은 서비스 계층의 오브젝트에 두는 것이 적당하다.

또한 도메인 오브젝트는 직접 데이터 엑세스 계층이나 기반 계층 또는 다른 서비스 계층의 오브젝트에 접근할 수 없기 때문에 서비스 계층이 필요하기도 하다.

<br>

왜 도메인 오브젝트는 DAO 오브젝트를 DI 받을 수 없을까? 그것은 도메인 오브젝트는 스프링 컨테이너가 관리하는 오브젝트, 즉 빈이 아니기 때문이다.

도메인 오브젝트는 애플리케이션의 코드 또는 기타 프레임워크나 라이브러리 등에 의해 필요할 때마다 새롭게 만들어진다. 따라서 스프링이 생성하거나 관리하는 오브젝트가 아니므로 DI를 받을 수 없다.

![image](https://github.com/gusals00/mentoring/assets/87007552/8dc66da9-ae6f-4444-b17a-d1f70856263c)


물론 빈약한 도메인 오브젝트 방식이 항상 나쁘고 피해야 할 것은 아니다. 도메인 모델링과 기능 분석을 통해 이상적인 도메인 오브젝트 설계를 하고 사전에 내부 기능을 충분히 구현해두지 않았다면, 도메인 오브젝트를 활용해서 비즈니스 로직을 구현해야 하는 개발자는 혼란을 느낄 수 있다.

도메인 오브젝트에 이미 구현된 코드가 있는데도 이를 이용하지 못하고 서비스 계층에 비슷한 기능을 중복해서 만들 수도 있고, 도메인 오브젝트의 코드를 일부 서비스 계층의 개발자가 임의로 변경해서 같은 오브젝트를 사용하는 다른 모듈의 작업자가 만든 코드가 제대로 동작하지 못하게 되기도 한다.

그래서 충실한 도메인 모델링과 도메인 오브젝트 개발이 선행되고 그 내용이 개발자에게 사전에 충분히 공유되지 않았다면 차라리 빈약한 도메인 오브젝트 방식이 혼란을 피할 수 있고 쉽게 접근할 수 있는 대산이 될 수도 있다. 하지만 시스템이 복잡해지면 단점이 드러날 것은 각오해야 한다.

<br>

**도메인 계층 방식**

도메인 오브젝트에 담을 수 있는 비즈니스 로직은 데이터 엑세스 계층에서 가져온 내부 데이터를 분석하거나, 조건에 따라 오브젝트 정보를 변경, 생성하는 정도에 그칠 수밖에 없다. 이렇게 변경된 정보가 다시 DB 등에 반영되려면 서비스 계층 오브젝트의 부가적인 작업이 필요하다.

<br>

도메인 오브젝트가 스스로 필요한 정보는 DAO를 통해 가져올 수 있고, 생성이나 변경이 일어났을 때 직접 DAO에게 변경사항을 반영해달라고 요청할 수는 없을까?

도메인 계층의 역할과 비중을 극대화하려다 보면 기존의 풍성한 도메인 오브젝트 방식으로는 만족할 수 없다. 그래서 등장한 것이 바로 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 게층 방식이다.

도메인 오브젝트가 독립된 계층을 이뤘기 때문에 기존 방식과는 다른 두 가지 특징을 갖게 된다.

1. 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행된다.
2. 도메인 오브젝트가 기존 데이터 엑세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다.

<br>

도메인 오브젝트는 빈이 아니기 때문에 다른 빈을 DI를 받을 수 없다고 했다. 그렇다면 도메인 계층의 도메인 오브젝트들은 어떻게 다른 빈을 이용할 수 있을까? 물론 방법은 DI다.

스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP가 필요하다. 물론 스프링 AOP는 부가기능을 추가할 수 있는 위치가 메소드 호출 과정으로 한정되고 AOP의 적용 대상도 스프링의 빈 오브젝트뿐이다. 

하지만 AspectJ AOP를 사용하면 클래스의 생성자가 호출되면서 오브젝트가 만들어지는 시점을 조인 포인트로 사용할 수 있고 스프링 빈이 아닌 일반 오브젝트에도 AOP 부가 기능을 적용할 수 있다.

<br>

이 방법을 이용하면 도메인 오브젝트가 만들어질 때 스프링의 빈 오브젝트를 DI받게 할 수 있다. 물론 도메인 오브젝트에 담긴 기능은 자신과 관련 오브젝트에 대한 작업으로 한정돼야 한다.

도메인 계층 방식은 이전의 어떤 방식보다 도메인 오브젝트에 많은 비즈니스 로직을 담아낼 수 있다. 그럼에도 서비스 계층의 역할이 완전히 사라지는 건 아니다. 때로는 여러 도메인 오브젝트의 기능을 조합해서 복잡한 작업을 진행해야 하는 경우가 있다. 또 트랜잭션 경계를 설정하거나 특정 도메인 로직에 포함되지는 않지만 애플리케이션에서 필요로 하는 기반 서비스를 이용해야 하는 작업을 위해서라도 서비스 계층은 필요하다.

<br>

도메인 오브젝트를 독립적인 계층으로 만들려고 할 때 고려해야 할 중요한 사항이 있다. 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정해야 한다.

도메인 오브젝트가 계층을 이루기 전에는 모든 계층에 걸쳐 사용되는 일종의 정보 전달 도구 같은 역할을 했다. 하지만 독자적인 계층을 이뤘을 때는 상황이 달라질 수 있다.

1. 여전히 모든 계층에서 도메인 오브젝트를 사용한다.
    1. 도메인 계층은 물론이고 서비스 계층이나 그 앞의 프레젠테이션 계층, 뷰에서도 직접 도메인 오브젝트를 전달받아 사용할 수 있게 하는 것이다.
    2. 하지만 주의하지 않으면 심각한 혼란을 초래할 수 있다. 도메인 오브젝트의 메소드는 이제 단순한 값의 조작이나 분석, 변환 정도가 아니라 중요한 도메인/비즈니스 로직을 담당하고 있다. 그런데 이런 막강한 기능을 가진 도메인 오브젝트를 프레젠테이션 계층이나 뷰 등에서 사용하게 해주면 이를 함부로 사용하는 위험이 따를 수 있다.
    3. 철저한 개발 가이드라인을 만들어두고 이를 강력하게 적용하는 것이 필요하다.
2. 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 한다.
    1. 도메인 계층 밖으로 전달될 때는 별도로 준비된 정보 전달용 오브젝트에 도메인 오브젝트의 내용을 복사해서 넘겨줘야 한다. 이런 오브젝트를 DTO라고 한다.
    2. DTO는 상태의 변화를 허용하지 않고 읽기전용으로 만들어지기도 한다. 반대로 사용자가 등록한 값이나 외부 시스템으로부터 전달 받은 정보를 도메인 계층으로 전달하는 경우에도 DTO를 이용할 수 있다.
    3. DTO는 기능을 갖지 않으므로 사용하기 안전하다. 또, 도메인 오브젝트를 외부 계층의 코드로부터 보호해준다. 반면에 도메인 오브젝트와 비슷한 구조를 가진 오브젝트를 따로 만들어야 하고 이를 매번 변환해줘야 하는 번거로움이 있다.

이 두 가지 방법 중 어느 것이 더 낫다고 말하기는 힘들다.

![image](https://github.com/gusals00/mentoring/assets/87007552/27b3766e-6b8c-41a9-88b4-263c4b3867d0)


여러 가지 제약과 불편을 감수하면서도 이 방식을 택해야 하는 경우는 매우 복잡하고 변경이 잦은 도메인을 가졌을 때다. 복잡한 도메인의 구조와 로직을 최대한 도메인 계층의 오브젝트에 반영하고, 도메인 모델과 설계에 변경이 발생했을 때 도메인 계층의 오브젝트도 빠르게 대응해서 변경해주기 위해서다.

### 스프링 애플리케이션을 위한 아키텍처 설계

**상태 관리와 빈 스코프**

아키텍처 설계에서 한 가지 더 신경 써야 할 사항은 상태 관리다. 크게는 사용자 로그인 세션 관리부터, 작게는 하나의 단위 작업이지만 여러 페이지에 걸쳐 진행되는 위저드 기능까지 애플리케이션은 하나의 HTTP 요청의 범위를 넘어서 유지해야 하는 상태정보가 있다.

엔터프라이즈 애플리케이션은 특정 사용자가 독점해서 배타적으로 사용되지 않는다. 하나의 애플리케이션이 동시에 수많은 사용자의 요청을 처리하게 하기 위해 매번 간단한 요청을 받아서 그 결과를 돌려주는 방식으로 동작한다. 따라서 서버의 자원이 특정 사용자에게 일정하게 할당되지 않는다.

그래서 서버 기반의 애플리케이션은 원래 지속적으로 유지되는 상태를 갖지 않는다(stateless)는 특징이 있다.

<br>

하지만 어떤 식으로든 애플리케이션의 상태와 장시간 진행되는 작업정보는 유지돼야 한다. 이를 위해서 웹 클라이언트에 URL, 파라미터, 폼 히든 필드, 쿠키 등을 이용해 상태정보 또는 서버에 저장된 상태정보에 키 값 등을 전달해야 한다.

클라이언트와 서버 사이에서 많은 양의 정보를 계속해서 주고받을 수는 없으므로 중요한 상태정보는 파일시스템, DB등에 저장되기도 한다.

<br>

이렇게 상태를 저장, 유지하는 데 어떤 방식을 사용할지 결정하는 일은 매우 중요하다. 스프링은 기본적으로 상태가 유지되지 않는 빈과 오브젝트를 사용하는 것을 권장한다. 웹의 생리에 가장 잘 들어맞고 개발하기 쉽기 때문이다. 또, 서버를 여러 대로 확장하기가 매우 쉽다.

## 정리

- 스프링은 어떤 플랫폼에서도 사용될 수 있지만, 기본적으로는 자바 엔터프라이즈 플랫폼(JavaEE)에 최적화되어 있다. HTTP를 통해 접근하는 웹 클라이언트와 백엔드 DB를 사용하는 애플리케이션에 적합하다.
- 스프링은 의존 라이브러리가 방대하기 때문에 라이브러리 관리와 의존관계를 관리하는 데 많은 노력을 기울여야 한다. 가능하면 스프링이 의존관계 정보를 제공해주는 Maven이나 Ivy같은 빌드 툴을 사용해 의존 라이브러리를 관리하는 것이 바람직하다.
- 스프링 애플리케이션은 역할에 따라 3계층으로 분리되고, 다시 기술의 추상도에 따라 세분화되는 계층형 아키텍처를 사용하는 것이 좋다.
- 아키텍처는 애플리케이션이 다루는 정보의 관점에서 데이터 중심과 오브젝트 중심으로 구분할 수 있다.
- 스프링에 가장 잘 어울리는 아키텍처는 오브젝트 중심의 아키텍처다.
- 스프링이 직접 지원하지 않는 서드파티 기술도 스프링 스타일의 접근 방식을 따라서 사용할 수있도록 준비해둬야 한다.
