**JDBC**

자바에서 데이터베이스 프로그래밍을 할 때에는 JDBC API를 사용한다. 자바는 DBMS의 종류에 상관없이 하나의 JDBC API를 사용해서 데이터베이스 작업을 처리할 수 있다.

구조

![image](https://github.com/gusals00/mentoring/assets/87007552/5ec76f1a-6007-44ca-9f8f-471b757d386b)


각각의 DBMS는 자신에게 알맞은 JDBC 드라이버를 제공하고 있고 JDBC API는 JDBC 드라이버를 거쳐 데이터베이스와 통신을 한다.

JDBC 프로그램의 전형적인 실행 순서는 다음과 같다

1. JDBC 드라이버 로딩
2. 데이터베이스 커넥션 구함
3. 쿼리 실행을 위한 Statement 객체 생성
4. 쿼리 실행
5. 쿼리 실행 결과 사용
6. Statement 종료
7. 데이터베이스 커넥션 종료

PreparedStatement는 Statement와 동일한 기능을 제공하지만 SQL 쿼리의 틀을 미리 생성해 놓고 값을 나중에 지정한다는 차이가 있다.

PreparedStatement의 장점

- 값 변환을 자동으로 해준다.
    - TIMESTAMP나 DATE 같은 타입은 DBMS마다 날짜와 시간을 표현하는 방식이 다르기 때문에 Statement를 이용해서 직접 쿼리에 값을 지정하면 DBMS마다 코드가 달라진다. 하지만 PreparedStatement를 사용하면 DBMS에 상관없이 동일한 코드를 사용할 수 있다.
- 코드가 깔끔해진다.
    - Statement는 지정할 값이 많아질 경우 코드 작성 과정에서 오류가 발생할 수 있고 따옴표가 복잡하게 얽힌다.

**트랜잭션**

![image](https://github.com/gusals00/mentoring/assets/87007552/cbf8d306-bd2c-4e8e-ab93-09a24167a16c)


트랜잭션이 시작되면 이후로 실행되는 쿼리 결과는 DBMS에 곧바로 반영되지 않고 임시로 보관된다. 이후 트래잭션을 커밋하면 임시 보관한 모든 쿼리 결과를 실제 데이터에 반영하고,트랜잭션을 커밋하기 전에 에러가 발생하면 트랜잭션을 반영하지 않고 롤백한다.

**커넥션 풀**

WAS가 실행되면서 DB와 미리 커넥션을 해놓은 객체들을 pool에 저장해두었다가, 클라이언트 요청이 오면 커넥션을 빌려주고, 처리가 끝나면 다시 커넥션을 반납받아 pool에 저장하는 방식을 말한다.

- **사용 이유**
    - 커넥션 객체를 생성하고 해제하는 과정은 시간이 오래 걸리고 자원을 많이 소모하기 때문에 커넥션 풀을 사용하면 미리 생성된 커넥션을 재사용할 수 있어 성능이 향상됨
    - 커넥션 수를 제한할 수 있어 과도한 접속으로 인한 서버 자원 고갈 방지가 가능함.

- **커넥션 풀을 무조건 크게 만들면 성능이 좋아질까?**
    - WAS와 DB와의 연결은 쓰레드가 담당한다. 그리고 쓰레드 또한 쓰레드 풀을 가지고 있다. 쓰레드 풀의 크기보다 커넥션 풀의 크기가 더 크면 메모리상에서 남은 커넥션들은 작업을 하지 못하고 놀게 되기 때문에 메모리만 차지하게 된다.
    - 그렇다고 무작정 쓰레드 풀의 크기를 늘린다고 해결되지 않는다. 쓰레드의 증가는 Context switching으로 인한 한계가 존재한다.

- **이상적인 커넥션 풀의 크기는 얼마일까?**
    - MySQL의 공식문서에서는 600명의 유저에 대해 15~20개의 크기가 적당하고, 그 이상부터는 적절하게 부하 테스트를 진행하며 적당한 값을 직접 찾는 것을 추천하고 있다.
    - HikariCP wiki 에서는 Tn * (Cm - 1) + 1 공식대로 풀 크기를 설정하면 데드락을 피할 수 있다고 하고 있다.
        - Tn : 전체 쓰레드 개수
        - Cm : 하나의 Task에서 동시에 필요한 커넥션 수

- **라이브러리**
    - Commons DBCP
        - Apache에서 제공하는 커넥션 풀 라이브러리
    - tomcat-jdbc-pool
        - tomcat에 내장되어 사용되고 있다.
        - Commons DBCP 라이브러리를 바탕으로 만들어져 있다.
        - 스프링 부트 2.0 하위 버전에서 사용하는 기본 DBCP이다.
    - HikariCP
        - 스프링 부트 2.0부터 사용하는 커넥션 풀이다.
        - 동작 방식
            - 쓰레드가 커넥션을 요청하면 커넥션 풀의 방식에 따라 유휴 커넥션을 찾아 반환한다. 이전에 사용했던 커넥션이 존재하는지 확인하고, 이를 우선적으로 반환하는 특징이 있다.
        
        ![image](https://github.com/gusals00/mentoring/assets/87007552/e2036e61-fafc-443d-8128-e70d1ec6cdf0)

        
        - 가능한 커넥션이 존재하지 않으면, handOffQueue를 Polling하면서 다른 쓰레드가 커넥션을 반납하기를 기다린다.(지정한 timeout 시간까지 대기하다가 시간이 만료되면 예외를 던짐)
        
        ![image](https://github.com/gusals00/mentoring/assets/87007552/21b8a9ff-8326-498f-aebe-4837c873e11c)

        
        - 최종적으로 사용한 커넥션을 반납하면 커넥션 풀이 커넥션 사용 내역을 기록하고 handOffQueue에서 커넥션을 받으려고 기다리는 쓰레드가 있다면 handOffQueue에 커넥션을 삽입한다. handOffQueue를 Polling하던 쓰레드는 커넥션을 획득하고 작업을 이어나간다.
            
            ![image](https://github.com/gusals00/mentoring/assets/87007552/067d15da-eccc-447e-997a-05eb9a83a6ff)

            

- **커넥션 풀 옵션**
    - 라이브러리에 따라 다르지만 일반적인 커넥션 풀에서 제공하는 주요 옵션들은 다음과 같다.
        - 초기 풀 크기 : 커넥션 풀이 시작될 때 생성되는 커넥션의 수
        - 최대 풀 크기 : 커넥션 풀에서 유지할 수 있는 최대 커넥션 수
        - 최소 풀 크기 : 커넥션 풀에서 유지하는 최소한의 커넥션 수
        - 커넥션 타임아웃 : 이용 가능한 커넥션이 없을 때 클라이언트가 커넥션을 얻기 위해 대기하는 최대 시간
        - 커넥션 휴식 시간 : 커넥션이 휴식 상태로 놀고 있는 최대 시간
        - 커넥션 최대 수명 : 풀에서 커넥션을 유지할 수 있는 최대 수명

**커스텀 태그**

JSP는 새로운 태그를 만들어서 사용할 수 있도록 지원하고 있고, 이렇게 원하는 목적에 맞게 작성한 태그를 커스텀 태그라고 한다.

장점은 아래와 같다.

- 재사용 : 한 번 작성한 커스텀 태그는 어떤 JSP 컨테이너에서도 사용 가능하다
- 쉽고 단순한 JSP 코드 작성
- 코드 가독성 향상

**서블릿**

서블릿은 JSP 표준이 나오기 전에 만들어진 표준으로 자바로 웹 애플리케이션을 개발할 수 있도록 하기 위해 만들어졌다.

일반적인 서블릿의 개발 과정은 다음과 같다

1. 서블릿 규약에 따라 자바 코드를 작성한다.
2. 자바 코드를 컴파일해서 클래스 파일을 생성한다.
3. /WEB-INF/classes 폴더에 클래스 파일을 패키지에 알맞게 위치시킨다.
4. web.xml 파일에 서블릿 클래스를 설정한다.
5. 톰캣 등의 컨테이너를 실행한다.
6. 웹 브라우저에서 확인한다.

서블릿 클래스를 구현하려면 먼저 HttpServlet 클래스를 상속받은 클래스를 작성해야 한다. HttpServlet 클래스를 상속받았다면 처리하고자 하는 HTTP 방식(method)에 따라 알맞은 메소드를 재정의해서 구현해야 한다. 

예를 들어, 서블릿이 GET 방식의 요청을 처리해야 한다면 doGet() 메소드를 재정의하면 된다. doGet() 메소드는 HttpServletRequest와 HttpServletResponse의 두 파라미터를 갖는데, 이 두 파라미터는 각각 JSP의 request 기본 객체와 response 기본 객체에 해당한다.

재정의한 메소드는 request를 이용해서 웹 브라우저의 요청 정보를 읽어오던가 response를 이용해서 응답을 전송할 수 있다.

서블릿 버전 3.0부터는 web.xml 파일에 서블릿으로 등록하지 않아도 @WebServlet 어노테이션을 사용해서 서블릿으로 등록할 수 있다.

**서블릿 로딩과 초기화**

![image](https://github.com/gusals00/mentoring/assets/87007552/fb926146-8a64-416d-8027-8c2fb12680c1)


서블릿 컨테이너는 처음 서블릿을 실행할 때 서블릿 객체를 생성하고, 이후 요청이 오면 앞서 생성한 서블릿 객체를 그대로 사용한다.

웹 컨테이너가 서블릿 객체를 생성하고 init() 메소드를 호출하는 과정을 서블릿 로딩이라고 한다.

init() 메소드의 기본 구현은 다음과 같다.

```java
//GenericServlet 구현
public void init(ServletConfig config) throws ServletException {
	this.config = config;
	this.init();
}

public void init() throws ServletException {
}
```

서블릿 컨테이너는 서블릿을 초기화하기 위해 ServletConfig 파라미터를 갖는 init() 메소드를 실행한다. 위 코드처럼 init(ServletConfig) 메소드는 다시 파라미터가 없는 init() 메소드를 호출한다.

따라서 초기화가 필요한 서블릿은 파라미터가 없는 init() 메소드를 재정의하면 된다.

하지만 보통 초기화 작업은 상대적으로 시간이 오래 걸리기 때문에, 처음 서블릿을 사용하는 시점보다는 웹 컨테이너를 처음 구동하는 시점에 초기화를 진행하는 것이 좋다. 

web.xml 파일의 <load-on-startup> 태그를 사용하거나 @WebServlet 태그를 사용하는 경우 loadOnStartup 속성을 사용하면 웹 애플리케이션을 시작할 때 서블릿을 로딩한다. 즉 톰캣을 구동하는 시점에 서블릿 객체를 생성하고 init() 메소드를 실행하게 된다.

**URL 패턴 매핑 규칙**

서블릿 규약에 따르면, URL 패턴은 다음 규칙에 따라 서블릿을 매핑한다.

- ‘/’로 시작하고 ‘/*’로 끝나는 url 패턴은 경로 매핑을 위해서 사용한다.
- ‘*. ‘로 시작하는 url 패턴은 확장자에 대한 매핑을 할 때 사용한다.
- 오직 ‘/’만 포함하는 경우 애플리케이션의 기본 서블릿으로 매핑한다.
- 이 규칙외, 나머지 다른 문자열은 정확한 매핑을 위해서 사용한다.

**모델 1 구조**

![image](https://github.com/gusals00/mentoring/assets/87007552/870614ab-5c66-4bbc-aee1-ac4db10f58ef)


모델 1 구조는 사진과 같이 웹 브라우저의 요청을 JSP가 직접 처리한다. 웹 브라우저의 요청을 받은 JSP는 자바빈이나 서비스 클래스를 사용해서 웹 브라우저가 요청한 작업을 처리하고 그 결과를 클라이언트에 출력한다.

JSP 페이지에서 웹 브라우저가 요청한 것들을 처리한다는 것은 JSP 페이지에 비즈니스 로직을 처리하기 위한 코드와 웹 브라우저에 결과를 출력하는 코드가 섞인다는 것을 의미한다.

**모델 2 구조**

![image](https://github.com/gusals00/mentoring/assets/87007552/5355b531-e4c7-4c29-bfa8-989dfce38ec8)


모델 2 구조는 모델 1 구조와 달리 웹 브라우저의 요청을 하나의 서블릿이 받는다.

 서블릿은 웹 브라우저의 요청을 알맞게 처리한 후 그 결과를 보여줄 JSP 페이지로 포워딩한다.

 포워딩을 통해 요청 흐름을 받은 JSP 페이지는 결과 화면을 클라이언트에 전송한다. 이 과정에서 서블릿이 로직을 처리한다.

하나의 서블릿이 웹 브라우저의 모든 요청을 받기 때문에, 서블릿은 웹 브라우저의 요청을 구분하는 방법이 필요하다. 서블릿은 웹 브라우저의 요청을 처리한 후 웹 브라우저에 보이게 될 응답 화면을 생성할 JSP를 선택한다. 모델 2 구조의 이러한 특징 때문에, MVC 패턴을 이용해서 웹 애플리케이션을 구현할 때 모델 2 구조를 사용한다.

**MVC 패턴**

MVC 패턴은 모델, 뷰, 컨트롤러의 세 부분으로 구성되며, 다음과 같은 역할을 담당한다.

- 모델 : 비즈니스 영역의 로직을 처리한다.
- 뷰 : 비즈니스 영역에 대한 사용자가 보게 될 결과 화면을 담당한다.
- 컨트롤러 : 사용자의 입력 처리와 흐름 제어를 담당한다.

![image](https://github.com/gusals00/mentoring/assets/87007552/57575160-60a7-4328-ad0c-9b47e3dba0c1)


사용자는 원하는 기능을 처리하기 위한 모든 요청을 컨트롤러에 보낸다. 

모델은 비즈니스와 관련된 기능을 제공하는데, 컨트롤러는 이 모델을 이용해서 사용자의 요청을 처리한다. 

모델을 사용하여 알맞은 비즈니스 로직을 처리한 후 컨트롤러는 사용자에게 보여줄 뷰 화면을 선택한다. 

선택된 뷰는 사용자에게 알맞은 결과 화면을 보여준다.

MVC 패턴의 핵심은 다음과 같다

- 비즈니스 로직을 처리하는 모델과 결과 화면을 보여주는 뷰를 분리한다.
- 애플리케이션의 흐름 제어나 사용자의 처리 요청은 컨트롤러에 집중된다.

MVC 패턴을 사용함으로써 유지보수 작업이 쉬워지고 애플리케이션을 쉽게 확장할 수 있게 된다.

**MVC 패턴과 모델 2 구조의 매핑**

JSP의 모델 2 구조와 MVC 패턴은 완벽하게 일치한다. 이 둘 사이의 관계를 살펴보면 다음과 같다.

- 컨트롤러 = 서블릿
    - 서블릿은 MVC 패턴의 컨트롤러 역할을 한다. 서블릿은 웹 브라우저의 요청과 웹 애플리케이션의 전체적인 흐름을 제어한다.
    - 서블릿은 다음의 과정을 거쳐 웹 브라우저의 요청을 처리한다.
        1. 웹 브라우저가 전송한 HTTP 요청을 받는다. 서블릿의 doGet() 메소드나 doPost() 메소드가 호출된다.
        2. 웹 브라우저가 어떤 기능을 요청했는지 분석한다.
        3. 모델을 사용하여 요청한 기능을 수행한다.
        4. 모델로부터 전달받은 결과물을 알맞게 가공한 후 request나 session의 setAttribute() 메소드를 사용해 결과값을 속성에 저장한다.
        5. 웹 브라우저에 결과를 전송할 JSP를 선택한 후, 해당 JSP로 포워딩한다. 경우에 따라 리다이렉트를 하기도 한다.
- 모델 = 로직 처리 클래스, 자바빈
    - 비즈니스 로직을 처리해주면 모델이 될 수 있다. 모델이 제공해야 하는 기능은 웹 브라우저의 요청을 처리하는데 필요한 기능이다.
- 뷰 = JSP
    - 모델 2 구조에서 JSP는 뷰 역할을 담당한다. 비즈니스 로직과 관련된 코드가 없는 점을 제외하면 일반 JSP와 동일한 형태를 취한다.

**모델 1 구조와 모델 2 구조 장단점**

모델 1

- 장점 : 배우기 쉽고, 기능과 JSP가 직관적으로 연결된다.
- 단점 : 로직 코드와 뷰 코드가 혼합되어 JSP 코드가 복잡해진다, 유지보수가 힘들다

모델 2

- 장점 : 로직 코드와 뷰 코드를 분리해서 유지보수가 쉬워진다, 컨트롤러 서블릿에서 권한 검사나 인증과 같은 공통 처리가 가능하다, 확장이 용이하다.
- 단점 : 작업량이 많다.

**필터**

필터는 HTTP 요청과 응답을 변경할 수 있는 재사용 가능한 클래스이다. 

![image](https://github.com/gusals00/mentoring/assets/87007552/4626b66e-2cbc-41ba-9ea0-c98f9b66576e)


필터는 객체의 형태로 존재하며 클라이언트에서 오는 요청과 최종 자원(JSP, 서블릿, 기타 자원) 사이에 위치하여 클라이언트의 요청 정보를 알맞게 변경할 수 있다.

또한 최종 자원과 클라이언트로 가는 응답 사이에 위치하여 최종 자원의 요청 결과를 알맞게 변경할 수도 있다.

클라이언트와 자원 사이에 한 개의 필터만 존재할 수 있는 것은 아니며, 여러개의 필터가 모여 하나의 필터 체인을 형성하게 된다.

필터를 구현하는데 있어 핵심은 다음 3개 타입이다.

- Filter 인터페이스 : 클라이언트와 최종 자원 사이에 위치하는 필터를 나타내는 객체가 구현해야 하는 인터페이스이다.
    - 필터 인터페이스는 당므과 같은 메소드를 선언하고 있다.
        - public void init(FilterConfig filterConfig)
            - 필터를 초기화할 때 호출된다.
        - public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            - 필터 기능을 수행한다. chain을 이용해서 체인의 다음 필터로 처리를 전달할 수 있다.
        - public void destroy()
            - 필터가 웹 컨테이너에서 삭제될 때 호출된다.
- ServletRequestWrapper 클래스 : 필터가 요청을 변경한 결과를 저장하는 래퍼이다.
- ServletResponseWrapper 클래스 : 필터가 응답을 변경하기 위해 사용하는 래퍼이다.
    - 위 두 가지의 Wrapper 클래스를 이용하면 다음을 할 수 있다.
        - 요청 정보를 변경하여 최종 자원인 서블릿/JSP/기타 자원에 전달한다.
        - 최종 자원으로부터 응답을 변경하여 새로운 응답 정보를 클라이언트에 보낸다.

보통 다음과 같은 기능에 필터를 적용한다.

- 사용자 인증
- 캐싱 필터
- 자원 접근에 대한 로깅
- 응답 데이터 변환
- 공통 기능 실행

**ServletContextListener**

웹 컨테이너는 웹 애플리케이션(컨텍스트)이 시작되거나 종료되는 시점에 특정 클래스의 메소드를 실행할 수 있는 기능을 제공하고 있다.

아래와 같이 코드를 작성하면 된다.

1. ServletContextListener 인터페이스를 구현한 클래스를 작성한다.
2. web.xml 파일에 1번에서 작성한 클래스를 등록하거나 @WebListener 어노테이션을 리스너 클래스에 적용해 등록한다.

ServletContextListener 인터페이스는 아래의 두 메소드를 정의하고 있다.

- public void contextInitialized(ServletContextEvent sce)
    - 웹 애플리케이션을 초기화할 때 호출한다.
- public void contextDestroyed(ServletContextEvent sce)
    - 웹 애플리케이션을 종료할 때 호출한다.
