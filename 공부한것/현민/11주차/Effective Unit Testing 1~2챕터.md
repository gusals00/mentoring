테스트란 단순히 기능 검증 수단만이 아닌 요구사항을 명시한 문장이고, 모듈과 API 설계 수단이며, 사용설명서이자, 최고의 인수인계/유지보수 자료이기까지 하다.

# 1. 좋은 테스트의 약속

**더 좋은 테스트를 작성하기 위한 현황 점검**

테스트 선행 방식에서는 자동화된 테스트를 단순한 오류 예방 목적으로 뿐 아니라, 코딩 전에 그 코드에 기대하는 동작을 정의하는 설계 보조 수단으로 까지 활용한다.

구현까지 다 끝나야 검증을 시작하는 게 아니라 애초에 설계부터 검증하고 들어가는 것이다.

자동화된 테스트는 여러분의 생산성을 높이고 개발 속도를 빠른 상태로 유지해준다.

### **테스트의 가치**

테스트는 실수를 바로잡아준다.

100% 코드 커버리지 달성이 중요한 게 아니다. 테스트의 가치는 테스트가 확인하지 못한 코드가 어떤 것인가와 테스트가 프로그래밍 실수를 얼마나 정확하게 잡아내는가에 좌우된다.

100%를 달성했다고 해서 결함이 없다고 보장해주는 건 아니다. 애플리케이션 동작이 올바른가와는 상관없이, 그저 모든 코드를 한 번씩은 실행해보았다는 것만을 보장할 뿐이다.

테스트는 실사용에 적합한 설계를 이끌어내준다.

테스트가 단순한 품질 보증이나 실수 재발 방지 수단만은 아니다. 테스트는 분명 코드를 설계하는 한 방식이기도 하다.

테스트는 원하는 동작을 명확히 알려주어 군더더기를 없애준다.

테스트 추종 개발자들은 처음에는 시간을 좀먹는 부끄러운 실수를 예방할 생각으로 자동화된 단위 테스트를 작성하기 시작하고, 시간이 지날수록 안전장치로써의 역할은 전체 그밀의 일부일 뿐임을 깨닫게 된다.

오히려 테스트를 코딩에 접목하면서 경험하는 사고 과정이 더 가치 있을 것이다.

자동화된 단위 테스트는 개발자가 직접 작성해야 한다는 인식은 이미 널리 퍼져있지만, 어떤 테스트를 얼마나 많이 작성해야 하는가에 대한 인식은 여전히 부족하다.

테스트를 작성해야 한다는 데에는 누구나 동의하지만, 커버리지가 100%에 근접해질수록 테스트를 더 작성해야 하는가에 대해서는 확신이 줄어든다. 작성할 테스트를 거의 다 작성했다면 나머지 코드에서 문제가 발견될 가능성은 낮아지기 때문이다. 이것을 수확 체감이라고 한다.

하지만 테스트를 작성해서 얻게되는 가장 큰 수확은 테스트 자체가 아니라 작성 과정에서 얻는 깨달음이다.

![image](https://github.com/gusals00/mentoring/assets/87007552/d76aebfe-1086-4aec-b484-4b82f037bb56)


테스트를 품질 보증 수단으로만 인식하는 한 얻을 수 있는 잠재적 가치는 그림의 낮은 곡선을 벗어날 수 없다. 사고의 틀을 깨고 테스트를 프로그래밍 도구, 즉 설계 도구로 인식하는 순간 품질 고지를 뛰어넘어 설계 고지에 도달하는 길이 열리게 된다.

### **생산성에 영향을 주는 요소**

테스크 코드는 제품 코드보다 간결한 게 보통이다. 그렇다고 해서 테스트 코드를 허투루 작성하고 문제를 심어 놓으면, 나중에 분명 발목 잡힐 날이 온다. 중복도 많고 쓸데없이 복잡한 테스트 코드는 생산성을 떨어뜨리고 테스트의 긍정적 효과마저 앗아간다는 걸 명심하자.

생산성에 직접 영향을 주는 피드백 주기와 디버깅 시간에 주목해보자. 실수하자마자 곧바로 알아차릴 수만 있다면 지루한 디버깅을 상당수 피할 수 있지만, 피드백 주기가 길어질수록 디버깅 시간도 길어지기 마련이다.

**테스트 실행 속도**는 변경사항을 검증하고 확인하기 위해 기다리는 시간에 직결된다.

**가독성**이 떨어지면 자연스럽게 분석이 더뎌지고 디버거를 사용해야 할 상황까지 만들 수 있다. 실수한 곳을 찾기 어려워 더 많은 **결함**이 만들어지고, 늘어난 결함은 디버깅 시간 증가로 이어진다.

**테스트 결과의 정확성**도 발견하지 못하고 놓치는 결함의 수에 많은 영향을 준다. 실수로 결함을 만들어도 테스트 스위트가 찾아줄 거라며 믿고 의지하고 싶다면 정확성이라도 반드시 보장되어야 한다. **신뢰성**과 **안정성**이 이 테스트 정확성과 직접 연관되어 있다.

### 설계 잠재력 곡선

대표적인 시나리오와 구조상 가장 치명적인 부분, 나머지 주요 기능도 모두 검사하고 getter/setter 등의 사소한 기능만 남았다고 하자.

이 상태에서 마지막 남은 사소한 테스트는 작성해봤자 큰 가치가 없다. 이는 수확 체감에 다다랐다는 신호로 단지 테스트만 작성해서는 얻을 수 있는 가치의 한계점에 도달한 것이다.

이곳이 바로 일반적인 방식으로 도달할 수 있는 최고점인 품질 고지다. 한계를 뛰어넘어 한 차원 높은 생산성을 맛보고자 한다면 지금까지 가지고 있던 테스트에 관한 사고의 틀을 깨야만 한다.

실수가 반복되는 것을 예방한다는, 방어적이고 검증 지향적인 가치가 아닌, 더 창조적이고 설계 지향적인 가치가 바로 그것이다.

테스트의 잠재 가치를 전부 끌어내고 두 고지를 모두 정복하려면 다음처럼 하면 된다.

1. 테스트 코드도 제품 코드를 다루듯 하라. 믿고 의지할 수 있을 만큼 철저하게 리팩토링하고 높은 품질을 유지하라.
2. 테스트를 제품 코드가 목적과 쓰임새에 적합한 구조가 되게끔 이끌어주는 설계 수단으로 활용하라.

### 설계 수단으로써의 테스트

프로그래머가 작성한 자동화된 테스트는 전통적으로 크게 두 가지 목적을 위한 품질보증 수단이었다.

첫째는 코드를 작성하는 즉시 정확하게 구현했는지 검사하는 것이고, 둘째는 그 후에 코드베이스가 커져도 계속 잘 동작하는지 지속해서 확인하는 것이다.

자동화된 테스트를 설계 수단으로 이용하기 시작하면 모든 것이 뒤바뀐다.

테스트를 코드 설계용으로 사용하면 익숙했던 **설계,코딩, 테스트**의 순서가 **테스트, 코딩, 설계**로 바뀐다. 마지막의 설계 단계는 **리팩토링**이라는 이름으로 더 유명하다.

결과적으로 **테스트 → 코딩 → 리팩토링**의 순서가 된다.

**테스트 주도 개발(TDD)**

테스트를 먼저 작성하면 소위 **테스트로 설계**한 제품 코드가 만들어진다. 여기에는 다음과 같은 긍정적인 효과가 따라온다.

- 사용 가능한 코드가 만들어진다. 즉 제품 코드의 설계와 API가 활용 시나리오에 적합한 모습으로 거듭난다.
- 코드가 가벼워진다. 실제로 활용할 시나리오에서 요구하는 기능만을 담게 된다.

**행위 주도 개발(BDD)**

댄 노스라는 런던의 컨설턴트는 TDD에서 말하는 테스트라는 용어가 사람들을 잘못된 길로 인도함을 깨달았다. 그래서 자신만의 TDD 방식을 만들고 행위 주도 개발이라는 이름을 붙였다.

테스트 메소드가 코드의 동작을 보장하는 효과적인 방법인 건 확실하다. 그런데 그 테스트가 시스템의 행위를 올바로 기술하지 못한다면, 분명 잘못이 있는데도 개발자는 아무 문제 없다고 믿는 상황을 만든다.

TDD에서 테스트가 들어가야 할 자리를 행위로 바꿔 사용하기 시작했다. 테스트의 이름을 짓는 건 정말 쉬워졌다. 검사하려는 행위를 기술하는 문장이면 된다. 테스트할 범위를 정하는 문제의 답도 간단하다. 답은 한 문장으로 기술할 수 있는 만큼의 행위다.

### 요약

프로그래머가 마구잡이식 코딩에서 벗어난 지는 한참이 지났다.

코드 전반을 보호해주는 자동화된 테스트 스위트의 가치를 더는 부정할 수 없다.

1장에서는 두 개의 고지가 무엇인지 배웠다.

이미 매우 높은 커버리지를 달성하여 테스트를 더 만들어봐야 얻을 게 거의 없는 지점이 바로 첫 번째 고지다.

테스트의 품질까지 신경 쓴다면 첫 번째 고지를 박차고 올라 더 위로 올라설 수 있다.

전자가 테스트를 갖춰야 하는 이유라면 후자는 좋은 테스트를 갖춰야 하는 이유다.

# 2. 좋은 테스트란?

무엇이 테스트를 좋게 만드는 것일까? 다음과 같은 고려 사항이 있다.

- 테스트 코드의 가독성과 유지보수성
- 프로젝트 안에서, 그리고 소스 파일 안에서 코드는 적절히 구조화되어 있는가?
- 테스트가 무엇을 검사하는가?
- 테스트는 안정적이고 반복 가능한가?
- 테스트가 테스트 더블을 잘 활용하는가?

이 목록은 아직 완벽하지 않다. 테스트 품질에 영향을 주는 요소를 모두 나열하자면 끝도 없기 때문이다. 더구나 어떤 요소는 상황에 따라 별로 중요하지 않을 수도 있다.

또한 테스트 코드의 품질을 평가하는 기준도 사람마다 다르다. 코드가 좋다는 건 보통 개인 취향에 좌우된다.

### 읽기 쉬운 코드가 유지보수도 쉽다

읽기 어려운 코드는 이해하는 데만 해도 너무 많은 에너지가 소비되기 때문에 유지보수 하기가 녹록하지 않다. 그뿐만 아니라 가독성과 결함 밀도는 반비례 한다는 연구 결과도 있다. 즉 읽기 어려운 코드일수록 결함 수가 많다.

자동화된 테스트는 결함을 효과적으로 막아주지만, 테스트 역시 코드인지라 가독성 문제에서 벗어날 수는 없다. 읽기 어려운 코드는 검증하기도 어렵고, 결과적으로 테스트를 조금만 작성하는 사태로까지 이어진다.

또 그렇게 작성된 테스트는 우리가 생각하는 좋은 테스트와는 거리가 멀다. 제품의 구조와 API가 테스트를 고려하지 않고 만들어졌다면 아무리 날고 기는 테스트 작성자가 와도 결국 끔찍한 구조의 이해하기 어려운 테스트밖에 만들 수 없기 때문이다.

### **구조화가 잘 되어 있다면 이해하기 쉽다**

구조화해두면 좋다는 점 뿐만 아니라 제대로 구조화하지 않으면 역으로 피해를 본다는 사실도 기억해둘 필요가 있다.

아무 구조나 다 코드를 이해하는데 도움이 되는 건 아니다. 이해할 수 있는 구조가 필요한 것이다. 깊은 생각 없이 코드를 여러 소스 파일, 클래스, 메소드로 흩어버려도 한 번에 들여다봐야 할 코드의 양이 줄어드는 건 사실이다. 단, 당면한 주제인 프로그램 로직을 분해하고 이해하는 데는 별다른 도움이 되지 못한다. 그래서 제대로 된 구조가 필요하다는 것이다. 

고수준 개념을 구현된 코드에 빠르고 정확하게 대입할 수 있는 구조면 된다.

결국은 읽기 쉽고, 찾기 쉽고, 이해하기 쉽도록 한 가지 기능에 충실한 테스트가 필요한 것이다. 그러면 다음과 같은 이점이 생긴다.

- 현재 작업과 관련된 테스트 클래스를 찾을 수 있다.
- 그 클래스에서 적절한 테스트 메소드를 고를 수 있다.
- 그 메소드에서 사용하는 객체의 생명주기를 이해할 수 잇다.

### 엉뚱한 걸 검사하는 건 좋지 않다

가끔은 테스트의 이름을 너무 믿어버리는 실수를 저지르곤 한다. 보통은 테스트의 이름을 보면 그 테스트가 검사하는 내용을 알 수 있는데, 실제로는 이름과 전혀 관련 없는 것을 검사하는 경우가 종종 있다.

이는 구조를 잘 잡는 일과도 관련이 있다. 테스트의 이름이 검사 내용과 다르다는 건 마치 낭떠러지로 안내하는 도로 표지판을 믿고 운전하는 것과 같다. 하지만 우리는 자신의 테스트를 신뢰할 수 있어야 한다.

올바른 것을 검사하는 것 못지않게 올바른 것을 똑바로 검사하는 것도 중요하다.

특히 유지보수 관점에서는 어떻게 구현했느냐가 아니라 의도한 대로 구현했느냐를 검사하는 게 중요하다.

### 독립적인 테스트는 혼자서도 잘 실행된다

테스트 코드의 경우에는 테스트가 얼마나 독립적인가를 잘 살펴야 한다. 이때 아키텍처의 경계 부분이 특히 중요하다.

경계에서 일어나는 일을 관찰하면서 수많은 코드 냄새를 맡을 수 있는데, 다음 요소와 관련이 있다면 각별한 주의가 필요하다.

- 시간(Time)
- 임의성(Randomness)
- 동시성(Concurrency)
- 인프라(Infrastructure)
- 기존 데이터(Pre-existing Data)
- 영속성(Persistency)
- 네트워킹(Networking)

격리와 독립성이 중요한 이유는 그것이 없다면 테스트를 실행하고 관리하기가 훨씬 어렵기 때문이다. 단위 테스트를 실행하기 위해 개발자가 해야 할 귀찮은 작업이 훨씬 많아진다.

파일시스템의 특정 위치에 빈 디렉터리를 만들어둬야 하거나, MySQL의 버전과 포트 번호를 확인하거나, 테스트가 사용할 로그인 정보를 데이터베이스에 미리 추가하거나, 환경 변수를 잔뜩 설정하는 일 등이 여기 해당한다.

이 모두는 개발자가 하지 않아도 됐을 작업이다. 이런 작은 하나하나가 모두 작업량을 늘리고 기묘한 테스트 실패를 일으키는 원인이 된다.

이러한 종속성은 우리가 제어할 수 없다는 특징이 있다.

시간, 임의성, 동시성, 인프라, 영속성, 기존 데이터, 네트워킹 관련 코드를 검사할 때는 특별히 더 신경 써야 한다.

이들과의 종속성은 가능하다면 피하는 게 최선이고, 아니면 작고 격리된 단위로 구분해서 이 복잡한 상황으로부터 다른 테스트를 보호해야 한다.

실전에서는 다음과 같은 방법을 시도해볼 수 있다.

- 테스트 더블로 서드파티 라이브러리와의 종속성을 제거한다. 손수 만든 어댑터로 적절히 감싸주는 것이다. 성가신 부분이 어댑터 안으로 감춰지므로 나머지 애플리케이션 로직과 분리해서 검사할 수 있다.
- 테스트에 필요한 자원을 테스트 코드와 같은 위치에 둔다. 자바 프로젝트라면 같은 패키지에 두면 된다.
- 테스트가 사용할 자원을 직접 만들도록 한다.
- 테스트가 필요한 문맥을 직접 설정하게 한다. 절대 다른 테스트에 의존하지 말자.
- 영속성이 필요한 통합 테스트라면 인메모리 데이터베이스를 활용한다.
- 스레드를 사용하는 코드는 동기식과 비동기식을 구분 지어서 골치 아픈 동시성 문제는 소규모의 전문 테스트 그룹에 맡긴다. 평범한 동기식 코드로 작성된 나머지 로직 대부분은 별다른 어려움 없이 검사할 수 있게 된다.

### 믿음직한 테스트라야 기댈 수 있다.

예상과는 전혀 다른 걸 검사하는 테스트도 종종 있다. 하지만 더 뒷목 잡는 경우는 아무것도 검사하지 않는 테스트다.

실패하지 않는 테스트는 있으나 마나다. 같은 맥락에서, 띄엄띄엄 성공하거나 띄엄띄엄 실패하는 테스트도 프로그래머에게는 똑같이 골치 아픈 짐 덩어리다.

테스트를 믿고 의지하려면 반복할 수 있게 만들어야 한다. 열 번 실행하면 열 번 모두 반드시 같은 결과가 나와야 한다.

애플리케이션이 비동기적 요소나 현재 시각에 종속된 코드를 포함한다면 그 부분을 인터페이스로 감싸 격리해야 한다. 그렇게 하면 테스트 더블로 대체할 수 있어 반복 가능한 테스트를 만들 수 있다.

### 모든 일이 그렇듯 테스트에도 도구가 쓰인다

테스트 더블이란 프로그래머들이 흔히 스텁, 가짜 객체, Mock 객체 등으로 알고 있는 개념들을 통칭하는 용어다. 근복적으로는 테스트를 위해 실제 구현체와 교체할 수 있는 객체다.

테스트 더블은 테스트 추종 프로그래머의 최고의 친구라 할 수 있다. 테스트를 위해 수많은 것을 개선해주고 사용하기도 쉽기 때문이다. 다음은 그 중 일부다.

- 원래의 로직을 간소화된 코드로 대체하여 테스트 속도를 개선한다.
- 만들어내기 어려운 특수한 상황을 시뮬레이션한다.
- 대상 객체의 내부 상태나 동작 등 테스트가 접근할 수 없던 정보를 얻어낸다.

가상 필수적인 도구라면 뭐니뭐니해도 JUnit과 같은 테스트 프레임워크를 꼽을 수 있다.

자동화된 테스트 작성에 꼭 필요한 세 번째 도구는 바로 빌드 도구다. 자동화된 테스트를 통합하지 않는 빌드는 결코 용납 될 수 없다.

### 요약

이들 대부분은 좋은 테스트를 만드는 절대적인 진리라기 보다는 처한 상황에 따라 달라짐을 알게 되었다.

테스트의 필수 미덕 중 하나인 가독성부터 시작해보았다. 아무리 애를 써도 이해할 수 없는 테스트 코드는 그 자체가 곧 큰 골칫거리가 되어 유지보수하기 어렵게 한다. 이렇게 되면 유지 비용이 너무 커져서 차라리 지워버리는 길을 선택하곤 한다.

잘 구조화된 테스트라면 원하는 코드를 빠르게 찾을 수 있고 논리 흐름도 쉽게 이해할 수 있다. 가독성과 직결되는 특성이기도 하다.

엉뚱한 걸 검사하는 테스트는 개발자를 잘못된 길로 안내하거나 본질을 흐려버려서 테스트가 의도했던 진짜 논리를 감추고 가독성을 떨어뜨리는 결과를 낳는다.

가끔 의심스러운 동작을 하는 테스트도 큰 문제였다. 이런 불신을 키우는 공통 원인을 찾아내고 반복할 수 있게 만드는 것이 테스트에 얼마나 중요한가를 강조했다.

자동화된 테스트 작성을 보조해주는 필수 도구 세 가지는 테스트 프레임워크, 프레임워크로 작성한 테스트를 실행해줄 자동 빌드, 검사할 수 있는 범위를 넓혀주는 테스트 더블이다.
