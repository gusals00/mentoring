## item 69 예외는 진짜 예외 상황에만 사용하라

```java
try{
	int i = 0;
	while(true){
		range[i++].climb();
}catch(ArrayIndexOutOfBoundsException e){
}
```

- 위처럼 예외를 사용한 반복문의 해악은 코드를 헷갈리게 하고 성능을 떨어뜨리며, 제대로 동작하지 않을 수 있다.

<br>

**예외는 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안된다.**
<br>
### 핵심 정리
- 예외는 예외 상황에서 쓸 의도로 설계되었다.
- 정상적인 제어 흐름에서 사용해서는 안 되며, 이를 프로그래머에게 강요하는 API를 만들어서도 안 된다.

<br><br><br><br>

## item 70 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

**호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라**
- 복구할 수 있는 조건일 때 발생
- 따라서 호출자가 예외 상황에서 벗어나는 데 필요한 정보를 알려주는 메서드를 함께 제공하는 것이 중요

<br>

**프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자**
- 런타임 예외 대부분은 전제조건을 만족하지 못했을 때 발생
    - 전제 조건 위배 → 클라이언트가 해당 API의 명세에 기록된 제약을 지키지 못했다는 뜻
- 복구 가능하다고 확신하기 어려우면 런타임 예외를 선택하자.

<br>

**검사 예외도 아니고 런타임 예외도 아닌  throwable은 언제 사용하는 것이 좋을까?**
- 사용하지 말아라

<br>

### 핵심 정리
- 복구할 수 있는 상황이면 검사 예외, 프로그래밍 오류라면 비검사 예외를 던지자
    - 확실하지 않다면 비검사 예외를 던져라
    - 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.
- 검사 예외도 아니고 런타임 예외도 아닌 throwable은 정의하지도 말자

<br><br><br><br>

## item 71 필요 없는 검사 예외 사용은 피하라

검사 예외는 제대로 활용하면 API와 프로그램의 질을 높일 수 있다.
하지만 검사 예외를 과하게 사용시 오히려 쓰기 불편한 API가 된다.
<br>

**검사 예외를 회피하는 가장  방법**
- 적절한 결과 타입을 담은 옵셔널을 반환하는 것
    - 단점
        - 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없음
        - 반면, 예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다.
- 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 변경
    - 검사 예외를 던지는 메서드 - 리팩터링 전
        
        ```java
        try{
        	obj.action(args);
        }catch(TheCheckedException e){
        	... // 예외 상황에 대처
        }
        ```
        
    - 상태 검사 메서드와 비검사 예외를 던지는 메서드 - 리팩터링 후
        
        ```java
        if(obj.actionPermitted(args)){
        	obj.action(args);
        }else{
        	... // 예외 상황에 대처
        }
        ```
        
<br>

### 핵심 정리
- 꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다.
- API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.
    - 복구가 가능하고 호출자가 그 처리를 해주길 바라면 우선 옵셔널을 반환해도 될지 고민하자.
    - 옵셔널만으로 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자

<br><br><br><br>

## item 72 표준 예외를 사용하라
- 예외도 재사용하는 것이 좋으며, 자바 라이브러리는 대부분 API에서 쓰기에 충분한 수의 예외를 제공
<br>

**표준 예외 사용시 얻는 이점**
- 내가 만든 API가 다른 사람이 익히고 사용하기 쉬워진다는 것 → 많은 개발자에게 이미 익숙해진 규약을 그대로 따르기 때문
- 예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸림

<br>

**Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자**
- 이 예외들은 다른 예외들의 상위 클래스이므로, 즉 여러 성격의 예외들을 포괄하는 클래스이므로 안정적으로 테스트할 수 없음

<br>

**널리 재사용되는 예외들**
- IllegalArgumentException : 허용하지 않는 값이 이누로 건네졌을 때(null은 따로 NullPointerException으로 처리)
- IllegalStateException : 객체가 메서드를 수행하기에 적절하지 않은 상태일 때
- NullPointerException : null을 허용하지 않는 메서드에 null을 건넸을 때
- IndexOutOfBoundsException : 인덱스가 범위를 넘어섰을 때
- ConcurrentModificationException : 허용하지 않는 동시 수정이 발견됐을 때
- UnsupportedOperationException : 호출한 메서드를 지원하지 않을 때

<br><br><br><br>

## item 73 추상화 수준에 맞는 예외를 던져라

- 메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 때 종종 수행하는 일과 관련없는 예외가 튀어나온다
    
    → 이는 내부 구현 방식을 드러내어 윗 레벨 API를 오염시킨다.
    
    다음 릴리스에서 구현 방식이 바뀌면 다른 예외가 튀어나와 기존 클라이언트 프로그램을 깨지게 할 수 있다.
    
- 위와 같은 문제를 피하려면 **상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다.**
    
    이를 **예외 번역(exception translation)**이라고 한다.
    

- 예외 번역시 저수준 예외가 디버깅에 도움이 되면 예외 연쇄(exception chaining)를 사용하는 것이 좋음
    - 예외 연쇄 : 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식

<br>

**무턱대고 예외를 전파하는 것보다야 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 곤란하다.**
- 가능하다면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선
- 때론 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 미리 검사하는 방법으로 이 목적을 달성할 수 있음

<br>

### 핵심 정리
- 아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라.
- 이때 예외 연쇄를 이용하면 상위 계층에 어울리는 고수준 예외를 던지면서 근본 원인도 알려주어 오류를 분석하기 좋다.

<br><br><br><br>

## item 74 추상화 수준에 맞는 예외를 던져라
- 메서드가 던지는 예외는 그 메서드를 올바르게 사용하는 데 아주 중요한 정보 → 메서드가 던지는 예외를 문서화하는 데 충분한 시간을 쏟아야 함

**검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자**
- 자바 언어가 요구하는 것은 아니지만 비검사 예외도 검사 예외처럼 문서화해두면 좋음
    
    → 자신이 일으킬 수 있는 오류를 알게되어 프로그래머는 자연스럽게 해당 오류가 나지 않도록 코딩하게 됨
    
<br>

**메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.**

<br>

### 핵심 정리
- 메서드가 던질 가능성이 있는 모든 예외를 문서화해라
- 검사 예외만 메서드 선언의 throws 문에 일일이 선언하고, 비검사 예외는 메서드 선언에는 기입하지 말자.

<br><br><br><br>

## item 75 예외의 상세 메시지에 실패 관련 정보를 담으라
- 사후 분석을 위해 실패 순간의 상황을 정확히 포착해 예외의 상세 메시지에 담아야 한다.

<br><br><br><br>



## item 76 가능한 한 실패 원자적으로 만들라

- 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 함 → 이러한 특성을 **실패 원자적(fail-atomic)**이라고 함

<br>

### 메서드를 실패 원자적으로 만드는 방법

1. 불변 객체로 설계하는 것
    - 불변 객체는 태생적으로 실패 원자적 → 불변 객체의 상태는 생성 시점에 고정되어 절대 변하지 않기 때문
2. 가변 객체 메서드 내 작업 수행에 앞서 매개변수의 유효성을 검사하는 것
    - 객체 내부 상태를 변경하기 전에 잠재적 예외의 가능성 대부분을 걸러낼 수 있는 방법
3. 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 것
    - 데이터를 임시 자료구조에 저장해 작업하는 게 더 빠를 때 적용하기 좋은 방식
4. 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법
    - 주로 (디스크 기반의) 내구성(durability)을 보장해야 하는 자료구조에 쓰이고, 자주 쓰이는 방법은 아님

<br>

메서드 명세에 기술한 예외라면 설혹 예외가 발생하더라도 객체의 상태는 메서드 호출 전과 똑같이 유지돼야 한다는 것이 기본 규칙

- 이 규칙을 지키지 못하면 실패 시의 객체 상태를 API 설명에 명시해야 함

<br><br><br><br>

## item 77 예외를 무시하지 말라

API 설계자가 메서드 선언에 예외를 명시한 까닭은, 그 메서드를 사용할 때 적절한 조치를 취해달라는 말하는 것이다.

따라서 예외를 무시하지 말아야 한다.

예측할 수 있는 예외 상황이든 프로그래밍 오류든, 빈 catch 블록으로 못 본 척 지나가면 그 프로그램은 오류를 내재한 채 동작하게 된다.

- 그러다 어느 순간 갑자기 문제 원인과 상관없는 곳에서 죽을 수도 있다.

예외를 적절히 처리하면 오류를 완전히 피할 수 있고, 무시하지 않고 밖으로 전파되게만 놔둬도 최소한 디버깅 정보를 남긴 채 프로그램이 신속히 중단되게는 할 수 있다.

<br>

**실패 순간을 포착하려면 발생한 예외에 관여한 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다.**
- 실패를 적절히 포착하려면 필요한 정보를 예외 생성자에서 모두 받아서 상세 메시지까지 미리 생성해놓는 방법도 괜찮음

포착한 실패 정보는 예외 상황을 복구하는 데 유용할 수 있으므로 접근자 메서드는 비검사 예외보다는 검사 예외에서 더 빛을 발한다.
