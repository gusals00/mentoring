## item 78 공유 중인 가변 데이터는 동기화해 사용하라

### Synchronized 키워드 수행 기능 2가지

- 배타적 수행
    - 한 스레드가 변경하는 중이라서 상태가 일관되지 않은 순간의 객체를 다른 스레드가 보지 못하게 막음
- 스레드간 안정적인 통신
    - 한 스레드가 변경한 값이 다른 스레드에게 보이도록 보장 → 가장 최근에 기록된 값을 읽게 됨을 보장

<br>

**volatile 한정자**

- 배타적 수행과는 상관없지만 항상 가장 최근에 기록된 값을 읽게 됨을 보장 → **스레드간 안정적인 통신을 보장**

<br>

**안전실패(safety failure)**

- 예시
    
    ```java
    private static volatile int nextSerialNumber = 0;
    
    public static int generateSerialNumber(){
    	return nextSerialNumber;
    }
    ```
    
    - nextSerialNumber 필드는 int로 원자적으로 접근할 수 있고 어떤 값이든 허용한다.
    - 문제는 증가 연산자(++) → 코드상으로는 하나지만 실제로는 nextSerialNumber 필드에 두번 접근한다.
        - 먼저 값을 읽고 1을 증가하는 도중에 다른 스레드가 들어와 값을 조회하면 잘못된 결과를 얻게 된다.
        - 이처럼 프로그램이 잘못된 결과를 계산해내는 이런 오류(데이터 훼손)를 **안전 실패**라고 한다.

<br>

**락 없이도 스레드 안전한 프로그래밍을 지원하는 클래스**

- java.util.concurrent.atomic.AtomicLong
    - 락 없이도 슬레드 안전한 프로그래밍이 가능
    - 안정적인 통신 기능과 원자성(배타적 실행)까지 지원

<br>

**가변 데이터는 단일 스레드에서만 사용하자**

### 핵심 정리

- 여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화해야 한다.
    - 동기화하지 않으면 한 스레드가 수행한 변경을 다른 스레드가 보지 못할 수 있음
    - 동기화하는데 실패하면 응답 불가 상태(데드락) 또는 안전실패(데이터 훼손)로 이어질 수 있음
- 배타적 실행은 필요 없고 스레드끼리 안전한 통신만 필요하다면 volatile 한정자만으로 동기화할 수 있다.

<br><br><br><br>

## item 79 과도한 동기화는 피하라

**과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고 심지어는 예측할 수 없는 동작을 낳기도 한다.**

<br>

**응답불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안된다.**

- 예를 들어 동기화된 영역 안에서는 재정의할 수 있는 메서드는 호출해서는 안되며, 클라이언트가 넘겨준 함수 객체를 호출해서도 안된다.
    - 이런 메서드는 바깥 세상에서 온 외계인이고 이러한 메서드는 통제할 수 없다.

<br>

**기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다.**
- 동기화가 초래하는 비용은 다음과 같다
    - 경쟁하느라 낭비하는 시간, 즉 병렬로 실행할 기회를 잃고 모든 코어가 메모리를 일관되게 보기 위한 지연시간이 진짜 비용이다.
    - 가상머신의 코드 최적화를 제한한다는 점도 과도한 동기화의 또 다른 숨은 비용이다.

<br>

**가변 클래스를 작성하려거든 다음 두가지 선택지 중 하나를 따르자**
1. 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자
    - java.util이 이 방법을 택함
2. 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자
    - java.util.concurrent는 이 방식을 취함
    - 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 위 방법을 선택해야 함

<br>

### 핵심 정리
- 교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자
    - 일반화하면, 동기화 영역 안에서의 작업은 최소한으로 줄이자.
- 가변 클래스를 설계할 때는 스스로 동기화할지 고민하자.
    - 멀티 코어 세상인 지금은 과도한 동기화는 피하는 게 과거 어느 때보다 중요하다.
    - 합당한 이유가 있을 때만 내부에서 동기화하고, 동기화했는지 여부를 문서에 명확히 밝히자.

<br>
<br>
<br>
<br>

## item 81 wait와 notify보다는 동시성 유틸리티를 애용하라

**wait와 notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하자.**

<br>

**java.util.concurrent의 고수준 유틸리티 범주**
- 실행자 프레임워크
- 동시성 컬렉션(concurrent collection)
    - 표준 컬렉션 인터페이스(List, Queue, Map)에 동시성을 가미해 구현한 고성능 컬렉션
    - 높은 동시성을 도달하기 위해 동기화를 각자의 내부에서 수행 → **동시성 컬렉션에서 동시성을 무력화하는 것은 불가능하며 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다**
- 동기화 장치(synchronizer)

<br>

**Collections.synchronizedMap보다는 ConcurrentHashMap을 사용하는 게 훨씬 좋음** → 동기화된 맵을 동시성 맵으로 교체하는 것만으로도 동시성 애플리케이션의 성능을 극적으로 개선할 수 있어서

<br>

### 핵심정리
- wait와 notify를 직접 사용하는 것보다는 java.util.concurrent를 사용하자.
    - 코드를 새로 작성한다면 wait와 notify를 쓸 이유가 거의 없다.

<br>
<br>
<br>
<br>


## item 82 스레드 안전성 수준을 문서화하라

**멀티스레드 환경에서도 API를 안전하게 사용하게 하려면 클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야 함.**

<br>

**스레드 안정성 수준**
- 불변(immutable)
    - 인스턴스가 마치 상수와 같아서 외부 동기화가 필요 X
    - String, Long, BigInteger
- 무조건적 스레드 안전(unconditionally thread-safe)
    - 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 동시에 사용해도 안전
    - AtomicLong, ConcurrentHashMap
- 조건부 스레드 안전(conditionally thread-safe)
    - 무조건적 스레드 안전과 같으나, 일부 메서드는 동시에 사용하려면 외부 동기화기 필요
    - Collections.synchronized 래퍼 클래스가 반환한 컬렉션들이 속함(해당 컬렉션들이 반환한 반복자는 외부에서 동기화해야 함)
    - 주의해서 문서화해야 함 → 어떤 순서로 호춣할 때 외부 동기화가 필요한지, 그 순서로 호출하려면 어떤 락 혹은 (드물게)락들을 얻어야 하는지를 알려줘야 함
- 스레드 안전하지 않음(not thread-safe)
    - 인스턴스는 수정될 수 있고, 동시에 사용하려면 각각의 메서드 호출은 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야 함
    - ArrayList, HashMap
- 스레드 적대적(thread-hostile)
    - 이 클래스는 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티 스레드 환경에서 안전하지 않음
    - 스레드 적대적으로 밝혀진 클래스나 메서드는 일반적으로 문제를 고쳐 재배포하거나 사용 자제 API로 지정

<br>

### 핵심 정리
- 모든 클래스가 자신의 스레드 안전성 정보를 명확히 문서화해야 함
- synchronized 한정자는 문서화와 관련이 없음
- 조건부 스레드 안전 클래스 → 메서드를 어떤 순서로 호출할 때 외부 동기화가 요구되고, 그때 어떤 락을 얻어야 하는지도 알려줘야 함
- 무조건적 안전 클래스 작성 시 → synchronized 메서드가 아닌 비공개 락 객체를 사용하자
    - 클라이언트나 하위 클래스에서 동기화 메커니즘을 깨뜨리는 걸 예방할 수 있음

<br>
<br>
<br>
<br>

## item 84 프로그램의 동작을 스레드 스케쥴러에 기대지 말라

정확성이나 성능이 스레드 스케쥴러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.

<br>

**견고하고 빠릿하고 이식성 좋은 프로그램을 작성하는 좋은 방법**

- 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것
- 실행 준비가 된 스레드들은 맡은 작업을 완료할 때까지 계속 실행되도록 만들자. → 스레드 스케쥴링 정책이 아주 상이한 시스템에서도 동작이 크게 달라지지 않는다.

<br>

스레드는 절대 바쁜 대기(busy waiting) 상태가 되면 안된다.

- 공유 객체의 상태가 바뀔 때까지 쉬지 않고 검사해서는 안된다
- 바쁜 대기는 스레드 스케쥴러의 변덕에 취약하고, 프로세서에 큰 부담을 주어 다른 유용한 작업이 실행될 기회를 박탈한다.

<br>

### 핵심정리

- 프로그램의 동작을 스레드 스케쥴러에 기대지 말자
    
    → 견고성과 이식성을 모두 해치는 행위
    
    → Thread.yield와 스레드 우선순위에 의존해서도 안됨 → 스레드 스케쥴러에 제공하는 힌트일 뿐임.
    
- 스레드 우선순위는 이미 잘 동작하는 프로그램의 서비스 품질을 높이기 위해 드물게 쓸 수 있지만, 간신히 동작하는 프로그램을 고치는 용도로 사용해서는 절대 안된다.
